{"add-two-numbers":{"title":"Add Two Numbers","description":"You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.","tags":["medium","linked-list"],"link":"https://leetcode.com/problems/add-two-numbers/","images":["https://assets.leetcode.com/uploads/2020/10/02/addtwonumber1.jpg"],"preview":"### Description\r\n\r\nYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\r\n\r\n\r\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\r\n\r\n### Example 1\r\n\r\n![](https://assets.leetcode.com/uploads/2020/10/02/addtwonumber1.jpg)\r\n\r\n```bash\r\nInput: l1 = [2,4,3], l2 = [5,6,4]\r\nOutput: [7,0,8]\r\nExplanation: 342 + 465 = 807.\r\n```\r\n\r\n### Example 2\r\n\r\n```bash\r\nInput: l1 = [0], l2 = [0]\r\nOutput: [0]\r\n```\r\n\r\n### Example 3\r\n\r\n```bash\r\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\r\nOutput: [8,9,9,9,0,0,0,1]\r\n```\r\n\r\n### Constraints:\r\n\r\n- The number of nodes in each linked list is in the range [1, 100]. \r\n- 0 <= Node.val <= 9 \r\n- It is guaranteed that the list represents a number that does not have leading zeros.","basename":"add-two-numbers"},"balanced-binary-tree":{"title":"Balanced Binary Tree","description":"Given a binary tree, determine if it is height-balanced.","tags":["easy","binary-tree"],"link":"https://leetcode.com/problems/balanced-binary-tree/","images":["https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg"],"preview":"### Description\r\n\r\nGiven a binary tree, determine if it is height-balanced.\r\n\r\n### Example 1\r\n\r\n\r\n![](https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg)\r\n\r\n```bash\r\nInput: root = [3,9,20,null,null,15,7]\r\nOutput: true\r\n```\r\n\r\n### Example 2\r\n\r\n![](https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg)\r\n\r\n```bash\r\nInput: root = [1,2,2,3,3,null,null,4,4]\r\nOutput: false\r\n```\r\n\r\n### Example 3\r\n\r\n```bash\r\nInput: root = []\r\nOutput: true\r\n```\r\n\r\n### Constraints:\r\n\r\n- The number of nodes in the tree is in the range [0, 5000]. \r\n- -10^4 <= Node.val <= 10^4","basename":"balanced-binary-tree"},"binary-search":{"title":"Binary Search","description":"Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.","tags":["medium","binary-search"],"link":"https://leetcode.com/problems/binary-search/","images":[],"preview":"### Description\r\n\r\nGiven an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.\r\n\r\nYou must write an algorithm with O(log n) runtime complexity.\r\n\r\n### Example 1\r\n\r\n```bash\r\nInput: nums = [-1,0,3,5,9,12], target = 9\r\nOutput: 4\r\nExplanation: 9 exists in nums and its index is 4\r\n```\r\n\r\n### Example 2\r\n\r\n```bash\r\nInput: nums = [-1,0,3,5,9,12], target = 2\r\nOutput: -1\r\nExplanation: 2 does not exist in nums so return -1\r\n```\r\n\r\n### Constraints:\r\n\r\n-     1 <= nums.length <= 104\r\n-     -104 < nums[i], target < 104\r\n-     All the integers in nums are unique.\r\n-     uunums is sorted in ascending order.","basename":"binary-search"},"binary-tree-level-order-traversal":{"title":"Binary Tree Level Order Traversal","description":"Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).","tags":["medium","binary-tree"],"link":"https://leetcode.com/problems/binary-tree-level-order-traversal/","images":["https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg"],"preview":"### Description\r\n\r\nGiven the `root` of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).\r\n\r\n### Example 1\r\n\r\n![](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)\r\n\r\n```bash\r\nInput: root = [3,9,20,null,null,15,7]\r\nOutput: [[3],[9,20],[15,7]]\r\n```\r\n\r\n### Example 2\r\n\r\n```bash\r\nInput: root = [1]\r\nOutput: [[1]]\r\n```\r\n\r\n### Constraints:\r\n\r\n- The number of nodes in the tree is in the range [0, 2000]. \r\n- -1000 <= Node.val <= 1000","basename":"binary-tree-level-order-traversal"},"binary-tree-maximum-path-sum":{"title":"Binary Tree Maximum Path Sum","description":"Given the root of a binary tree, return the maximum path sum of any non-empty path.","tags":["hard","binary-tree"],"link":"https://leetcode.com/problems/binary-tree-maximum-path-sum/","images":["https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg","https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg"],"preview":"### Description\r\n\r\nA path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.\r\n\r\nThe path sum of a path is the sum of the node's values in the path.\r\n\r\nGiven the root of a binary tree, return the maximum path sum of any non-empty path.\r\n\r\n### Example 1\r\n\r\n![](https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg)\r\n\r\n```bash\r\nInput: root = [1,2,3]\r\nOutput: 6\r\nExplanation: The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6.\r\n```\r\n\r\n### Example 2\r\n\r\n![](https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg)\r\n\r\n```bash\r\nInput: root = [-10,9,20,null,null,15,7]\r\nOutput: 42\r\nExplanation: The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42.\r\n```\r\n\r\n### Constraints:\r\n\r\n- The number of nodes in the tree is in the range [1, 3 * 10^4]. \r\n- -1000 <= Node.val <= 1000","basename":"binary-tree-maximum-path-sum"},"binary-tree-right-side-view":{"title":"Binary Tree Right Side View","description":"Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.","tags":["medium","binary-tree"],"link":"https://leetcode.com/problems/binary-tree-right-side-view/","images":["https://assets.leetcode.com/uploads/2021/02/14/tree.jpg"],"preview":"### Description\r\n\r\nGiven the `root` of a binary tree, imagine yourself standing on the **right side** of it, return the values of the nodes you can see ordered from top to bottom.\r\n\r\n### Example 1\r\n\r\n![](https://assets.leetcode.com/uploads/2021/02/14/tree.jpg)\r\n\r\n\r\n```bash\r\nInput: root = [1,2,3,null,5,null,4]\r\nOutput: [1,3,4]\r\n```\r\n\r\n### Example 2\r\n\r\n```bash\r\nInput: root = [1,null,3]\r\nOutput: [1,3]\r\n```\r\n\r\n### Constraints:\r\n\r\n- The number of nodes in the tree is in the range [0, 100]. \r\n- -100 <= Node.val <= 100","basename":"binary-tree-right-side-view"},"car-fleet":{"title":"Car Fleet","description":"There are n cars going to the same destination along a one-lane road. The destination is target miles away.","tags":["medium","stack"],"link":"https://leetcode.com/problems/car-fleet/","images":[],"preview":"### Description\r\n\r\nThere are `n` cars going to the same destination along a one-lane road. The destination is `target` miles away.\r\n\r\nYou are given two integer array position and speed, both of length n, where position[i] is the position of the ith car and speed[i] is the speed of the ith car (in miles per hour).\r\n\r\nA car can never pass another car ahead of it, but it can catch up to it and drive bumper to bumper at the same speed. The faster car will slow down to match the slower car's speed. The distance between these two cars is ignored (i.e., they are assumed to have the same position).\r\n\r\nA car fleet is some non-empty set of cars driving at the same position and same speed. Note that a single car is also a car fleet.\r\n\r\nIf a car catches up to a car fleet right at the destination point, it will still be considered as one car fleet.\r\n\r\nReturn the number of car fleets that will arrive at the destination.\r\n\r\n### Example 1\r\n\r\n```bash\r\nInput: target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]\r\nOutput: 3\r\nExplanation:\r\nThe cars starting at 10 (speed 2) and 8 (speed 4) become a fleet, meeting each other at 12.\r\nThe car starting at 0 does not catch up to any other car, so it is a fleet by itself.\r\nThe cars starting at 5 (speed 1) and 3 (speed 3) become a fleet, meeting each other at 6. The fleet moves at speed 1 until it reaches target.\r\nNote that no other cars meet these fleets before the destination, so the answer is 3.\r\n```\r\n\r\n### Example 2\r\n\r\n```bash\r\nInput: target = 10, position = [3], speed = [3]\r\nOutput: 1\r\nExplanation: There is only one car, hence there is only one fleet.\r\n```\r\n\r\n### Example 3\r\n\r\n```bash\r\nInput: target = 100, position = [0,2,4], speed = [4,2,1]\r\nOutput: 1\r\nExplanation:\r\nThe cars starting at 0 (speed 4) and 2 (speed 2) become a fleet, meeting each other at 4. The fleet moves at speed 2.\r\nThen, the fleet (speed 2) and the car starting at 4 (speed 1) become one fleet, meeting each other at 6. The fleet moves at speed 1 until it reaches target.\r\n```\r\n\r\n### Constraints:\r\n\r\n-      n == position.length == speed.length     \r\n-      1 <= n <= 105\r\n-      0 < target <= 106\r\n-      0 <= position[i] < target\r\n-      All the values of position are unique.\r\n-      0 < speed[i] <= 106","basename":"car-fleet"},"character-replacement":{"title":"Character Replacement","description":"Longest Repeating Character Replacement","tags":["medium","sliding-window"],"preview":"### Description\r\n\r\nYou are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times.\r\n\r\nReturn the length of the longest substring containing the same letter you can get after performing the above operations.\r\n\r\n### Example 1\r\n```bash\r\nInput: s = \"ABAB\", k = 2\r\nOutput: 4\r\nExplanation: Replace the two 'A's with two 'B's or vice versa.\r\n```\r\n\r\n### Example 2\r\n```bash\r\nInput: s = \"AABABBA\", k = 1\r\nOutput: 4\r\nExplanation: Replace the one 'A' in the middle with 'B' and form \"AABBBBA\".\r\nThe substring \"BBBB\" has the longest repeating letters, which is 4.\r\n```\r\n\r\n### Constraints:\r\n\r\n- 1 <= s.length <= 105\r\n- s consists of only uppercase English letters.\r\n- 0 <= k <= s.length","basename":"character-replacement"},"clone-graph":{"title":"Clone Graph","description":"Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.","tags":["medium","graphs"],"link":null,"images":[],"preview":"### Description\r\n\r\nGiven an `m x n` 2D binary grid `grid` which represents a map of `'1's` (land) and `'0's` (water), return the number of islands.\r\n\r\nAn **island** is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\r\n\r\n### Example 1\r\n\r\n```bash\r\nInput: grid = [\r\n  [\"1\",\"1\",\"1\",\"1\",\"0\"],\r\n  [\"1\",\"1\",\"0\",\"1\",\"0\"],\r\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\r\n  [\"0\",\"0\",\"0\",\"0\",\"0\"]\r\n]\r\nOutput: 1\r\n```\r\n\r\n### Example 2\r\n\r\n```bash\r\n\r\n```\r\n\r\n### Constraints:\r\n\r\n-","basename":"clone-graph"},"combination-sum-ii":{"title":"Combination Sum II","description":"Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.","tags":["medium","backtracking"],"link":null,"images":[],"preview":"### Description\r\n\r\nGiven a collection of candidate numbers (`candidates`) and a target number (`target`), find all unique combinations in `candidates` where the candidate numbers sum to target.\r\n\r\nEach number in candidates may only be used **once** in the combination.\r\n\r\n**Note**: The solution set must not contain duplicate combinations.\r\n\r\n### Example 1\r\n\r\n```bash\r\nInput: candidates = [10,1,2,7,6,1,5], target = 8\r\nOutput: \r\n[\r\n[1,1,6],\r\n[1,2,5],\r\n[1,7],\r\n[2,6]\r\n]\r\n```\r\n\r\n### Example 2\r\n\r\n```bash\r\nInput: candidates = [2,5,2,1,2], target = 5\r\nOutput: \r\n[\r\n[1,2,2],\r\n[5]\r\n]\r\n```\r\n\r\n### Constraints:\r\n\r\n- 1 <= candidates.length <= 100 \r\n- 1 <= candidates[i] <= 50 \r\n- 1 <= target <= 30","basename":"combination-sum-ii"},"combination-sum":{"title":"Combination Sum","description":"The test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input.","tags":["medium","backtracking"],"link":"https://leetcode.com/problems/combination-sum/","images":[],"preview":"### Description\r\n\r\nGiven an array of **distinct** integers candidates and a target integer target, return a list of all **unique combinations** of candidates where the chosen numbers sum to target. You may return the combinations in **any order**.\r\n\r\nThe **same** number may be chosen from candidates an **unlimited number of times**. Two combinations are unique if the frequency of at least one of the chosen numbers is different.\r\n\r\nThe test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input.\r\n\r\n \r\n\r\n### Example 1\r\n\r\n```bash\r\nInput: candidates = [2,3,6,7], target = 7\r\nOutput: [[2,2,3],[7]]\r\nExplanation:\r\n2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\r\n7 is a candidate, and 7 = 7.\r\nThese are the only two combinations.\r\n```\r\n\r\n### Example 2\r\n\r\n```bash\r\nInput: candidates = [2,3,5], target = 8\r\nOutput: [[2,2,2,2],[2,3,3],[3,5]]\r\n```\r\n\r\n### Constraints:\r\n\r\n- 1 <= candidates.length <= 30\r\n- 2 <= candidates[i] <= 40\r\n- All elements of candidates are distinct.\r\n- 1 <= target <= 40","basename":"combination-sum"},"construct-binary-tree-from-preorder-and-inorder-traversal":{"title":"Construct Binary Tree from Preorder and Inorder Traversal","description":"Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.","tags":["medium","binary-tree"],"link":"https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/","images":["https://assets.leetcode.com/uploads/2021/02/19/tree.jpg"],"preview":"### Description\r\n\r\nGiven two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.\r\n\r\n### Example 1\r\n\r\n![](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg)\r\n\r\n```bash\r\nInput: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]\r\nOutput: [3,9,20,null,null,15,7]\r\n```\r\n\r\n### Example 2\r\n\r\n```bash\r\nInput: preorder = [-1], inorder = [-1]\r\nOutput: [-1]\r\n```\r\n\r\n### Constraints:\r\n\r\n- 1 <= preorder.length <= 3000 \r\n- inorder.length == preorder.length\r\n- -3000 <= preorder[i], inorder[i] <= 3000 \r\n- preorder and inorder consist of unique values. \r\n- Each value of inorder also appears in preorder. \r\n- preorder is guaranteed to be the preorder traversal of the tree. \r\n- inorder is guaranteed to be the inorder traversal of the tree.","basename":"construct-binary-tree-from-preorder-and-inorder-traversal"},"container-with-most-water":{"title":"Container With Most Water","description":"A container with most water example","tags":["two-pointers","medium"],"images":["https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg"],"preview":"## Container With Most Water\r\n\r\nYou are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\r\n\r\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\r\n\r\nReturn the maximum amount of water a container can store.\r\n\r\nNotice that you may not slant the container.\r\n\r\n![](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg)\r\n\r\n\r\n```\r\nInput: height = [1,8,6,2,5,4,8,3,7]\r\nOutput: 49\r\nExplanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\r\n```\r\n\r\n\r\n### Example 2\r\n\r\n```\r\nInput: height = [1,1]\r\nOutput: 1\r\n```","basename":"container-with-most-water"},"copy-list-with-random-pointer":{"title":"Copy List with Random Pointer","description":"A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null.","tags":["medium","linked-list"],"link":"https://leetcode.com/problems/copy-list-with-random-pointer/","images":["https://assets.leetcode.com/uploads/2019/12/18/e1.png","https://assets.leetcode.com/uploads/2019/12/18/e2.png","https://assets.leetcode.com/uploads/2019/12/18/e3.png"],"preview":"### Description\r\n\r\nA linked list of length `n` is given such that each node contains an additional random pointer, which could point to any node in the list, or `null`.\r\n\r\nConstruct a deep copy of the list. The deep copy should consist of exactly n **brand new **nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. **None of the pointers in the new list should point to nodes in the original list.**\r\n\r\nFor example, if there are two nodes X and Y in the original list, where X.random --> Y, then for the corresponding two nodes x and y in the copied list, x.random --> y.\r\n\r\nReturn the head of the copied linked list.\r\n\r\nThe linked list is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where:\r\n\r\n- `val`: an integer representing `Node.val`\r\n- `random_index`: the index of the node (range from `0` to `n-1`) that the `random pointer` points to, or null if it does not point to any node.\r\n\r\nYour code will **only** be given the head of the original linked list.\r\n\r\n### Example 1\r\n\r\n![](https://assets.leetcode.com/uploads/2019/12/18/e1.png)\r\n\r\n```bash\r\nInput: head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\r\nOutput: [[7,null],[13,0],[11,4],[10,2],[1,0]]\r\n```\r\n\r\n### Example 2\r\n\r\n![](https://assets.leetcode.com/uploads/2019/12/18/e2.png)\r\n\r\n\r\n```bash\r\nInput: head = [[1,1],[2,1]]\r\nOutput: [[1,1],[2,1]]\r\n```\r\n\r\n### Example 3\r\n\r\n![](https://assets.leetcode.com/uploads/2019/12/18/e3.png)\r\n\r\n```bash\r\nInput: head = [[3,null],[3,0],[3,null]]\r\nOutput: [[3,null],[3,0],[3,null]]\r\n```\r\n\r\n### Constraints:\r\n\r\n- 0 <= n <= 1000\r\n- -104 <= Node.val <= 104\r\n- Node.random is null or is pointing to some node in the linked list.","basename":"copy-list-with-random-pointer"},"count-good-nodes-in-binary-tree":{"title":"Count Good Nodes in Binary Tree","description":"Given a binary tree root, a node X in the tree is named good if in the path from root to X there are no nodes with a value greater than X.","tags":["medium","binary-tree"],"link":"https://leetcode.com/problems/count-good-nodes-in-binary-tree/","images":["https://assets.leetcode.com/uploads/2020/04/02/test_sample_1.png","https://assets.leetcode.com/uploads/2020/04/02/test_sample_2.png"],"preview":"### Description\r\n\r\nGiven a binary tree root, a node X in the tree is named good if in the path from root to X there are no nodes with a value greater than X.\r\n\r\nReturn the number of **good** nodes in the binary tree.\r\n\r\n \r\n\r\n### Example 1\r\n\r\n![](https://assets.leetcode.com/uploads/2020/04/02/test_sample_1.png)\r\n\r\n```bash\r\nInput: root = [3,1,4,3,null,1,5]\r\nOutput: 4\r\n\r\n\r\nExplanation: Nodes in blue are good.\r\nRoot Node (3) is always a good node.\r\nNode 4 -> (3,4) is the maximum value in the path starting from the root.\r\nNode 5 -> (3,4,5) is the maximum value in the path\r\nNode 3 -> (3,1,3) is the maximum value in the path.\r\n```\r\n\r\n### Example 2\r\n\r\n![](https://assets.leetcode.com/uploads/2020/04/02/test_sample_2.png)\r\n\r\n```bash\r\n\r\n```bash\r\nInput: root = [3,3,null,4,2]\r\nOutput: 3\r\nExplanation: Node 2 -> (3, 3, 2) is not good, because \"3\" is higher than it.\r\n```\r\n\r\n### Example 3\r\n\r\n```bash\r\nInput: root = [1]\r\nOutput: 1\r\nExplanation: Root is considered as good.\r\n```\r\n\r\n### Constraints:\r\n\r\n- The number of nodes in the binary tree is in the range [1, 10^5]. \r\n- Each node's value is between [-10^4, 10^4].","basename":"count-good-nodes-in-binary-tree"},"course-schedule-ii":{"title":"Course Schedule II","description":"Return the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.","tags":["medium","graph","topological-sort"],"link":"https://leetcode.com/problems/course-schedule-ii/","images":[],"preview":"### Description\r\n\r\nThere are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where `prerequisites[i] = [ai, bi]` indicates that you must take course bi first if you want to take course ai.\r\n\r\nFor example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\r\nReturn the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return **an empty array**.\r\n\r\n### Example 1\r\n\r\n```bash\r\nInput: numCourses = 2, prerequisites = [[1,0]]\r\nOutput: [0,1]\r\nExplanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].\r\n```\r\n\r\n### Example 2\r\n\r\n```bash\r\nInput: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]\r\nOutput: [0,2,1,3]\r\nExplanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.\r\nSo one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].\r\n```\r\n\r\n### Example 3\r\n\r\n```bash\r\nInput: numCourses = 1, prerequisites = []\r\nOutput: [0]\r\n```\r\n\r\n### Constraints:\r\n\r\n- 1 <= numCourses <= 2000 \r\n- 0 <= prerequisites.length <= numCourses * (numCourses - 1)\r\n- prerequisites[i].length == 2 \r\n- 0 <= ai, bi < numCourses \r\n- ai != bi \r\n- All the pairs [ai, bi] are distinct.","basename":"course-schedule-ii"},"course-schedule":{"title":"Course Schedule","description":"Return true if you can finish all courses. Otherwise, return false.","tags":["medium","graph","topological-sort"],"link":"https://leetcode.com/problems/course-schedule/","images":[],"preview":"### Description\r\n\r\nThere are a total of `numCourses` courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where `prerequisites[i] = [ai, bi]` indicates that you **must** take course bi first if you want to take course ai.\r\n\r\nFor example, the pair `[0, 1]`, indicates that to take course 0 you have to first take course 1.\r\nReturn true if you can finish all courses. Otherwise, return `false`.\r\n\r\n### Example 1\r\n\r\n```bash\r\nInput: numCourses = 2, prerequisites = [[1,0]]\r\nOutput: true\r\nExplanation: There are a total of 2 courses to take. \r\nTo take course 1 you should have finished course 0. So it is possible.\r\n```\r\n\r\n### Example 2\r\n\r\n```bash\r\nInput: numCourses = 2, prerequisites = [[1,0],[0,1]]\r\nOutput: false\r\nExplanation: There are a total of 2 courses to take. \r\nTo take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.\r\n```\r\n\r\n### Constraints:\r\n\r\n- 1 <= numCourses <= 2000 \r\n- 0 <= prerequisites.length <= 5000 \r\n- prerequisites[i].length == 2 \r\n- 0 <= ai, bi < numCourses \r\n- All the pairs prerequisites[i] are unique.","basename":"course-schedule"},"daily-temperatures":{"title":"Daily Temperatures","description":"Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.","tags":["medium","stack","sliding-window"],"link":"https://leetcode.com/problems/daily-temperatures/","images":[],"preview":"### Description\r\n\r\nGiven an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.\r\n\r\n### Example 1\r\n\r\n```bash\r\nInput: temperatures = [73,74,75,71,69,72,76,73]\r\nOutput: [1,1,4,2,1,1,0,0]\r\n```\r\n\r\n### Example 2\r\n\r\n```bash\r\nInput: temperatures = [30,40,50,60]\r\nOutput: [1,1,1,0]\r\n```\r\n\r\n### Constraints:\r\n\r\n-     1 <= temperatures.length <= 105\r\n-     30 <= temperatures[i] <= 100","basename":"daily-temperatures"},"design-add-and-search-words-data-structure":{"title":"Design Add and Search Words Data Structure","description":"Design a data structure that supports adding new words and finding if a string matches any previously added string.","tags":["medium","trie"],"link":"https://leetcode.com/problems/design-add-and-search-words-data-structure/","images":[],"preview":"### Description\r\n\r\nDesign a data structure that supports adding new words and finding if a string matches any previously added string.\r\n\r\nImplement the `WordDictionary` class:\r\n\r\n- WordDictionary() Initializes the object.\r\n- void addWord(word) Adds word to the data structure, it can be matched later.\r\n- bool search(word) Returns true if there is any string in the data structure that matches word or false otherwise. word may contain dots '.' where dots can be matched with any letter.\r\n\r\n### Example 1\r\n\r\n```bash\r\nInput\r\n[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"]\r\n[[],[\"bad\"],[\"dad\"],[\"mad\"],[\"pad\"],[\"bad\"],[\".ad\"],[\"b..\"]]\r\nOutput\r\n[null,null,null,null,false,true,true,true]\r\n\r\nExplanation\r\nWordDictionary wordDictionary = new WordDictionary();\r\nwordDictionary.addWord(\"bad\");\r\nwordDictionary.addWord(\"dad\");\r\nwordDictionary.addWord(\"mad\");\r\nwordDictionary.search(\"pad\"); // return False\r\nwordDictionary.search(\"bad\"); // return True\r\nwordDictionary.search(\".ad\"); // return True\r\nwordDictionary.search(\"b..\"); // return True\r\n```\r\n\r\n\r\n### Constraints:\r\n\r\n- 1 <= word.length <= 25\r\n- word in addWord consists of lowercase English letters.\r\n- word in search consist of '.' or lowercase English letters.\r\n- There will be at most 3 dots in word for search queries.\r\n- At most 104 calls will be made to addWord and search.","basename":"design-add-and-search-words-data-structure"},"design-twitter":{"title":"Design Twitter","description":"https://leetcode.com/problems/design-twitter/","tags":["medium","heap"],"link":"https://leetcode.com/problems/design-twitter/","images":[],"preview":"### Description\r\n\r\nDesign a simplified version of Twitter where users can post tweets, follow/unfollow another user, and is able to see the 10 most recent tweets in the user's news feed.\r\n\r\nImplement the `Twitter` class:\r\n\r\n- Twitter() Initializes your twitter object.\r\n- void postTweet(int userId, int tweetId) Composes a new tweet with ID tweetId by the user userId. Each call to this function will be made with a unique tweetId.\r\n- List<Integer> getNewsFeed(int userId) Retrieves the 10 most recent tweet IDs in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user themself. Tweets must be ordered from most recent to least recent.\r\n- void follow(int followerId, int followeeId) The user with ID followerId started following the user with ID followeeId.\r\n- void unfollow(int followerId, int followeeId) The user with ID followerId started unfollowing the user with ID followeeId.\r\n\r\n### Example 1\r\n\r\n```bash\r\nInput\r\n[\"Twitter\", \"postTweet\", \"getNewsFeed\", \"follow\", \"postTweet\", \"getNewsFeed\", \"unfollow\", \"getNewsFeed\"]\r\n[[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]\r\nOutput\r\n[null, null, [5], null, null, [6, 5], null, [5]]\r\n\r\nExplanation\r\nTwitter twitter = new Twitter();\r\ntwitter.postTweet(1, 5); // User 1 posts a new tweet (id = 5).\r\ntwitter.getNewsFeed(1);  // User 1's news feed should return a list with 1 tweet id -> [5]. return [5]\r\ntwitter.follow(1, 2);    // User 1 follows user 2.\r\ntwitter.postTweet(2, 6); // User 2 posts a new tweet (id = 6).\r\ntwitter.getNewsFeed(1);  // User 1's news feed should return a list with 2 tweet ids -> [6, 5]. Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.\r\ntwitter.unfollow(1, 2);  // User 1 unfollows user 2.\r\ntwitter.getNewsFeed(1);  // User 1's news feed should return a list with 1 tweet id -> [5], since user 1 is no longer following user 2.\r\n```\r\n\r\n### Example 2\r\n\r\n```bash\r\n\r\n```\r\n\r\n### Constraints:\r\n\r\n- 1 <= userId, followerId, followeeId <= 500\r\n- 0 <= tweetId <= 10^4\r\n- All the tweets have unique IDs.\r\n- At most 3 * 10^4 calls will be made to postTweet, getNewsFeed, follow, and unfollow.","basename":"design-twitter"},"diameter-of-binary-tree":{"title":"Diameter of Binary Tree","description":"Given the root of a binary tree, return the length of the diameter of the tree.","tags":["easy","binary-tree"],"link":"https://leetcode.com/problems/diameter-of-binary-tree/","images":["https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg"],"preview":"### Description\r\n\r\nGiven the `root` of a binary tree, return the **length** of the diameter of the tree.\r\n\r\nThe **diameter** of a binary tree is the **length** of the longest path between any two nodes in a tree. This path may or may not pass through the root.\r\n\r\nThe **length** of a path between two nodes is represented by the number of edges between them.\r\n\r\n### Example 1\r\n\r\n![](https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg)\r\n\r\n```bash\r\nInput: root = [1,2,3,4,5]\r\nOutput: 3\r\nExplanation: 3 is the length of the path [4,2,1,3] or [5,2,1,3].\r\n```\r\n\r\n### Example 2\r\n\r\n```bash\r\nInput: root = [1,2]\r\nOutput: 1\r\n```\r\n\r\n### Constraints:\r\n\r\n- The number of nodes in the tree is in the range [1, 104]. \r\n- -100 <= Node.val <= 100","basename":"diameter-of-binary-tree"},"evaluate-polish-reverse-notation":{"title":"Evaluate Reverse Polish Notation","description":"You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation.  Evaluate the expression. Return an integer that represents the value of the expression.","tags":["medium","stack"],"link":"https://leetcode.com/problems/evaluate-reverse-polish-notation/","preview":"### Description\r\n\r\nYou are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation.\r\n\r\nEvaluate the expression. Return an integer that represents the value of the expression.\r\n\r\nNote that:\r\n\r\n    The valid operators are '+', '-', '*', and '/'.\r\n    Each operand may be an integer or another expression.\r\n    The division between two integers always truncates toward zero.\r\n    There will not be any division by zero.\r\n    The input represents a valid arithmetic expression in a reverse polish notation.\r\n    The answer and all the intermediate calculations can be represented in a 32-bit integer.\r\n\r\n\r\n### Example 1\r\n\r\n```bash\r\nInput: tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"]\r\nOutput: 9\r\nExplanation: ((2 + 1) * 3) = 9\r\n```\r\n\r\n### Example 2\r\n\r\n```bash\r\nInput: tokens = [\"4\",\"13\",\"5\",\"/\",\"+\"]\r\nOutput: 6\r\nExplanation: (4 + (13 / 5)) = 6\r\n```\r\n\r\n### Constraints:\r\n\r\n- 1 <= tokens.length <= 104\r\n- tokens[i] is either an operator: \"+\", \"-\", \"*\", or \"/\", or an integer in the range [-200, 200].","basename":"evaluate-polish-reverse-notation"},"find-median-from-data-stream":{"title":"Find Median from Data Stream","description":"The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.","tags":["hard","heap"],"link":"https://leetcode.com/problems/find-median-from-data-stream/","images":[],"preview":"### Description\r\n\r\nThe **median** is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.\r\n\r\n- For example, for arr = [2,3,4], the median is 3.\r\n- For example, for arr = [2,3], the median is (2 + 3) / 2 = 2.5.\r\n\r\nImplement the MedianFinder class:\r\n\r\n- MedianFinder() initializes the MedianFinder object.\r\n- void addNum(int num) adds the integer num from the data stream to the data structure.\r\n- double findMedian() returns the median of all elements so far. Answers within 10-5 of the actual answer will be accepted.\r\n\r\n### Example 1\r\n\r\n```bash\r\nInput\r\n[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"]\r\n[[], [1], [2], [], [3], []]\r\nOutput\r\n[null, null, null, 1.5, null, 2.0]\r\n\r\nExplanation\r\nMedianFinder medianFinder = new MedianFinder();\r\nmedianFinder.addNum(1);    // arr = [1]\r\nmedianFinder.addNum(2);    // arr = [1, 2]\r\nmedianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2)\r\nmedianFinder.addNum(3);    // arr[1, 2, 3]\r\nmedianFinder.findMedian(); // return 2.0\r\n```\r\n\r\n\r\n### Constraints:\r\n\r\n- -10^5 <= num <= 10^5 \r\n- There will be at least one element in the data structure before calling findMedian. \r\n- At most 5 * 10^4 calls will be made to addNum and findMedian.\r\n\r\n\r\n### Follow up:\r\n\r\n- If all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?\r\n- If 99% of all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?","basename":"find-median-from-data-stream"},"find-min":{"title":"Find Minimum in Rotated Sorted Array","description":"Given the sorted rotated array nums of unique elements, return the minimum element of this array.","tags":["medium","binary-search"],"link":"https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/","preview":"### Description\r\n\r\nSuppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:\r\n\r\n    `[4,5,6,7,0,1,2]` if it was rotated 4 times.\r\n    `[0,1,2,4,5,6,7]` if it was rotated 7 times.\r\n\r\nNotice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].\r\n\r\nGiven the sorted rotated array nums of unique elements, return the minimum element of this array.\r\n\r\nYou must write an algorithm that runs in O(log n) time.\r\n\r\n### Example 1\r\n\r\n```bash\r\nInput: nums = [3,4,5,1,2]\r\nOutput: 1\r\nExplanation: The original array was [1,2,3,4,5] rotated 3 times.\r\n```\r\n\r\n### Example 2\r\n\r\n```bash\r\nInput: nums = [4,5,6,7,0,1,2]\r\nOutput: 0\r\nExplanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.\r\n```\r\n\r\n### Constraints:\r\n\r\n-      n == nums.length     \r\n-      1 <= n <= 5000     \r\n-      -5000 <= nums[i] <= 5000     \r\n-      All the integers of nums are unique.     \r\n-      nums is sorted and rotated between 1 and n times.","basename":"find-min"},"find-the-duplicate-number":{"title":"Find the Duplicate Number","description":"Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.","tags":["medium","linked-list"],"link":"https://leetcode.com/problems/find-the-duplicate-number/","preview":"### Description\r\n\r\nGiven an array of integers nums containing `n + 1` integers where each integer is in the range `[1, n]` inclusive.\r\n\r\nThere is only **one repeated number** in nums, return this repeated number.\r\n\r\nYou must solve the problem **without** modifying the array nums and uses only constant extra space.\r\n\r\n### Example 1\r\n\r\n```bash\r\nInput: nums = [1,3,4,2,2]\r\nOutput: 2\r\n```\r\n\r\n### Example 2\r\n\r\n```bash\r\nInput: nums = [3,1,3,4,2]\r\nOutput: 3\r\n```\r\n\r\n### Constraints:\r\n\r\n- 1 <= n <= 10^5 \r\n- nums.length == n + 1 \r\n- 1 <= nums[i] <= n \r\n- All the integers in nums appear only **once** except for **precisely one** **integer** which appears **two or more** times.","basename":"find-the-duplicate-number"},"generate-parenthesis":{"title":"Generate Parentheses","description":"Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.","tags":["medium","stack","backtracking"],"link":null,"preview":"### Description\r\n\r\nGiven n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\r\n\r\n### Example 1\r\n\r\n```bash\r\nInput: n = 3\r\nOutput: [\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\r\n```\r\n\r\n### Example 2\r\n\r\n```bash\r\nInput: n = 1\r\nOutput: [\"()\"]\r\n```\r\n\r\n### Constraints:\r\n\r\n- 1 <= n <= 8","basename":"generate-parenthesis"},"hello-world":{"title":"Hello World","description":"A simple hello world example","tags":["sample"],"preview":"This is  a simple hello world example.\r\n\r\n```bash\r\n$ dsa run hello-world.js\r\n```","basename":"hello-world"},"implement-trie-prefix-tree":{"title":"Trie","description":"A trie (pronounced as \"try\") or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.","tags":["medium","trie"],"link":"https://leetcode.com/problems/implement-trie-prefix-tree/","images":[],"preview":"### Description\r\n\r\nA trie (pronounced as \"try\") or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.\r\n\r\nImplement the Trie class:\r\n\r\n- Trie() Initializes the trie object.\r\n- void insert(String word) Inserts the string word into the trie.\r\n- boolean search(String word) Returns true if the string word is in the trie (i.e., was inserted before), and false otherwise.\r\n- boolean startsWith(String prefix) Returns true if there is a previously nserted string word that has the prefix prefix, and false otherwise.\r\n\r\n### Example 1\r\n\r\n```bash\r\nInput\r\n[\"Trie\", \"insert\", \"search\", \"search\", \"startsWith\", \"insert\", \"search\"]\r\n[[], [\"apple\"], [\"apple\"], [\"app\"], [\"app\"], [\"app\"], [\"app\"]]\r\nOutput\r\n[null, null, true, false, true, null, true]\r\n\r\nExplanation\r\nTrie trie = new Trie();\r\ntrie.insert(\"apple\");\r\ntrie.search(\"apple\");   // return True\r\ntrie.search(\"app\");     // return False\r\ntrie.startsWith(\"app\"); // return True\r\ntrie.insert(\"app\");\r\ntrie.search(\"app\");     // return True\r\n```\r\n\r\n### Constraints:\r\n\r\n- 1 <= word.length, prefix.length <= 2000 \r\n- word and prefix consist only of lowercase English letters. \r\n- At most 3 * 104 calls in total will be made to insert, search, and startsWith.","basename":"implement-trie-prefix-tree"},"index":{"preview":"const { getFilesInDirectory, getDirAbsoluteUri } = require('../functions');\r\nconst md2json = require('markdown-to-json');\r\nconst fs = require('fs');\r\n\r\nconst DEBUG = false;\r\nconst PROMPT_FILE = 'prompt.json';\r\n\r\nconst options = {\r\n    minify: false,\r\n    width: DEBUG ? 0 : 9000000,\r\n    outfile: null,\r\n};\r\n\r\n\r\n/**\r\n * Creates a compiled json file from all the markdown files in the prompt directory\r\n */\r\nconst createCompiledJson = () => {\r\n    let parsed_prompt_dict = {};\r\n\r\n    getFilesInDirectory('./prompt/')\r\n        .then((files) => {\r\n            const absolutePathForFiles = files.map((file) => {\r\n                return getDirAbsoluteUri(file, './prompt/');\r\n            });\r\n            if (DEBUG) console.log(\"absolutePathForFiles: \", absolutePathForFiles);\r\n            const promptsData = md2json.parse(absolutePathForFiles, options);\r\n            if (DEBUG) console.log(promptsData);\r\n            parsed_prompt_dict = JSON.parse(promptsData);\r\n            // Object.values(parsed_prompt_dict).map((prompt) => {\r\n\r\n            //     prompt.preview\r\n            // });\r\n            // console.log(\"promptsData: \", parsed_prompt_dict);\r\n\r\n\r\n\r\n            // Save as a json\r\n            const json = JSON.stringify(parsed_prompt_dict);\r\n            const prompt_file_path = getDirAbsoluteUri(PROMPT_FILE, './prompt/');\r\n            fs.writeFile(prompt_file_path, json, (err) => {\r\n                if (err) throw err;\r\n                console.log('The file has been saved!');\r\n            });\r\n        })\r\n        .catch((error) => {\r\n            console.error(error);\r\n        });\r\n};\r\n\r\n\r\nconst getLatestModified = async () => {\r\n    const files = await getFilesInDirectory('./prompt/');\r\n    let latestModified = null;\r\n    let latestFile = null;\r\n\r\n    const absolutePathForFiles = files.map((file) => {\r\n        return getDirAbsoluteUri(file, './prompt/');\r\n    });\r\n    for (const file of absolutePathForFiles) {\r\n        const stats = await fs.promises.stat(file);\r\n        if (!latestModified || stats.mtime > latestModified) {\r\n            latestModified = stats.mtime;\r\n            latestFile = file;\r\n        }\r\n    }\r\n\r\n    return latestFile;\r\n};\r\n\r\n/**\r\n * Checks if prompt.json exists, if not, creates it, then returns the parsed json\r\n * @param {String} prompt_slug - The slug of the prompt to return, if empty, returns all prompts\r\n * @returns {Object} parsed_prompt_dict\r\n */\r\nconst getPromptDict = async (prompt_slug = \"\") => {\r\n    // check if prompt.json exists\r\n    const prompt_file_path = getDirAbsoluteUri(PROMPT_FILE, './prompt/');\r\n    if (!fs.existsSync(prompt_file_path)) {\r\n        createCompiledJson();\r\n    }\r\n\r\n    // If exists, check if it's the latest modified file, if not, update the prompt.json\r\n    const latestModified = await getLatestModified();\r\n\r\n    let parsed_prompt_dict;\r\n    if (latestModified !== prompt_file_path) {\r\n        console.log(\"latestModified: \", latestModified);\r\n        createCompiledJson();\r\n    }\r\n    try {\r\n        parsed_prompt_dict = require(prompt_file_path);\r\n    }\r\n    catch (e) {\r\n        // Delete the prompt.json file and try again\r\n        fs.unlinkSync(prompt_file_path);\r\n        // If it fails this time exit and print\r\n        try{\r\n            parsed_prompt_dict = require(prompt_file_path);\r\n        \r\n        }\r\n        catch (e) {\r\n            console.error(\"Error: \", e);\r\n            process.exit(1);\r\n        }\r\n    }\r\n\r\n\r\n    if (prompt_slug === \"\") {\r\n        return parsed_prompt_dict;\r\n    }\r\n    return parsed_prompt_dict[prompt_slug];\r\n};\r\n\r\n\r\n\r\n\r\n(async () => {\r\n    const sample = await getPromptDict();\r\n    if (DEBUG) console.log(\"sample: \", sample);\r\n}\r\n)();\r\n\r\nmodule.exports = { getPromptDict, createCompiledJson };\r\n\r\n\r\n// const parsed_prompt_dict = require(PROMPT_FILE);\r\n// module.exports = parsed_prompt_dict;","basename":"index"},"invert-binary-tree":{"title":"Invert Binary Tree","description":"Given the `root` of a binary tree, invert the tree, and return its root.","tags":["easy","binary-tree"],"link":"https://leetcode.com/problems/invert-binary-tree/","images":["https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg","https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg"],"preview":"### Description\r\n\r\nGiven the root of a binary tree, invert the tree, and return its root.\r\n\r\n### Example 1\r\n\r\n![](https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg)\r\n\r\n```bash\r\nInput: root = [4,2,7,1,3,6,9]\r\nOutput: [4,7,2,9,6,3,1]\r\n```\r\n\r\n### Example 2\r\n\r\n![](https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg)\r\n\r\n```bash\r\nInput: root = [2,1,3]\r\nOutput: [2,3,1]\r\n```\r\n\r\n### Example 3\r\n\r\n```bash\r\nInput: root = []\r\nOutput: []\r\n```\r\n\r\n### Constraints:\r\n\r\n- The number of nodes in the tree is in the range [0, 100]. \r\n- -100 <= Node.val <= 100","basename":"invert-binary-tree"},"k-closest":{"title":"k closest points to origin","description":"Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane and an integer k, return the k closest points to the origin (0, 0).","tags":["medium","heap"],"link":"https://leetcode.com/problems/k-closest-points-to-origin/","images":["https://assets.leetcode.com/uploads/2021/03/03/closestplane1.jpg"],"preview":"### Description\r\n\r\nGiven an array of points where `points[i] = [xi, yi]` represents a point on the **X-Y** plane and an integer k, return the k closest points to the origin (0, 0).\r\n\r\nThe distance between two points on the X-Y plane is the Euclidean distance (i.e., âˆš(x1 - x2)2 + (y1 - y2)2).\r\n\r\nYou may return the answer in **any order**. The answer is **guaranteed** to be **unique** (except for the order that it is in).\r\n\r\n### Example 1\r\n\r\n![](https://assets.leetcode.com/uploads/2021/03/03/closestplane1.jpg)\r\n\r\n```bash\r\nInput: points = [[1,3],[-2,2]], k = 1\r\nOutput: [[-2,2]]\r\nExplanation:\r\nThe distance between (1, 3) and the origin is sqrt(10).\r\nThe distance between (-2, 2) and the origin is sqrt(8).\r\nSince sqrt(8) < sqrt(10), (-2, 2) is closer to the origin.\r\nWe only want the closest k = 1 points from the origin, so the answer is just [[-2,2]].\r\n```\r\n\r\n### Example 2\r\n\r\n```bash\r\nInput: points = [[3,3],[5,-1],[-2,4]], k = 2\r\nOutput: [[3,3],[-2,4]]\r\nExplanation: The answer [[-2,4],[3,3]] would also be accepted.\r\n```\r\n\r\n### Constraints:\r\n\r\n- 1 <= k <= points.length <= 104\r\n- -104 < xi, yi < 104","basename":"k-closest"},"key-based-value-store":{"title":"Time Based Key-value Store","description":"Design a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the key's value at a certain timestamp.","tags":["medium","binary-search"],"link":"https://leetcode.com/problems/time-based-key-value-store/","preview":"### Description\r\n\r\nDesign a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the key's value at a certain timestamp.\r\n\r\nImplement the TimeMap class:\r\n\r\n- `TimeMap()` Initializes the object of the data structure\r\n- `void set(String key, String value, int timestamp)` Stores the key `key` with the value `value` at the given time timestamp.\r\n- `String get(String key, int timestamp)` Returns a value such that set was called previously, with `timestamp_prev <= timestamp`. If there are multiple such values, it returns the value associated with the largest `timestamp_prev`. If there are no values, it returns `\"\"`.\r\n\r\n\r\n### Example 1\r\n\r\n```bash\r\nInput\r\n[\"TimeMap\", \"set\", \"get\", \"get\", \"set\", \"get\", \"get\"]\r\n[[], [\"foo\", \"bar\", 1], [\"foo\", 1], [\"foo\", 3], [\"foo\", \"bar2\", 4], [\"foo\", 4], [\"foo\", 5]]\r\nOutput\r\n[null, null, \"bar\", \"bar\", null, \"bar2\", \"bar2\"]\r\n\r\nExplanation\r\nTimeMap timeMap = new TimeMap();\r\ntimeMap.set(\"foo\", \"bar\", 1);  // store the key \"foo\" and value \"bar\" along with timestamp = 1.\r\ntimeMap.get(\"foo\", 1);         // return \"bar\"\r\ntimeMap.get(\"foo\", 3);         // return \"bar\", since there is no value corresponding to foo at timestamp 3 and timestamp 2, then the only value is at timestamp 1 is \"bar\".\r\ntimeMap.set(\"foo\", \"bar2\", 4); // store the key \"foo\" and value \"bar2\" along with timestamp = 4.\r\ntimeMap.get(\"foo\", 4);         // return \"bar2\"\r\ntimeMap.get(\"foo\", 5);         // return \"bar2\"\r\n```\r\n\r\n\r\n### Constraints:\r\n\r\n-      1 <= key.length, value.length <= 100     \r\n-      key and value consist of lowercase English letters and digits.     \r\n-      1 <= timestamp <= 107     \r\n-      All the timestamps timestamp of set are strictly increasing.     \r\n-      At most 2 * 105 calls will be made to set and get.","basename":"key-based-value-store"},"koko-eating-bananas":{"title":"koko-eating-bananas","description":"Return the minimum integer k such that she can eat all the bananas within h hours.","tags":["medium","binary-search"],"link":"https://leetcode.com/problems/koko-eating-bananas/","preview":"### Description\r\n\r\nKoko loves to eat bananas. There are `n` piles of bananas, the ith pile has `piles[i]` bananas. The guards have gone and will come back in `h` hours.\r\n\r\nKoko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.\r\n\r\nKoko likes to eat slowly but still wants to finish eating all the bananas before the guards return.\r\n\r\nReturn the minimum integer `k` such that she can eat all the bananas within `h` hours.\r\n\r\n### Example 1\r\n\r\n```bash\r\nInput: piles = [3,6,7,11], h = 8\r\nOutput: 4\r\n```\r\n\r\n### Example 2\r\n\r\n```bash\r\nInput: piles = [30,11,23,4,20], h = 5\r\nOutput: 30\r\n```\r\n\r\n### Example 3\r\n\r\n```bash\r\nInput: piles = [30,11,23,4,20], h = 6\r\nOutput: 23\r\n```\r\n\r\n### Constraints:\r\n\r\n-      1 <= piles.length <= 104     \r\n-      piles.length <= h <= 109     \r\n-      1 <= piles[i] <= 109","basename":"koko-eating-bananas"},"kth-largest-element-in-an-array":{"title":"kth largest elements in a stream","description":"Given an integer array nums and an integer k, return the kth largest element in the array.","tags":["medium","heap"],"link":"https://leetcode.com/problems/kth-largest-element-in-an-array/","images":[],"preview":"### Description\r\n\r\nGiven an integer array nums and an integer `k`, return the `kth` largest element in the array.\r\n\r\nNote that it is the `kth` largest element in the sorted order, not the `kth` distinct element.\r\n\r\nYou must solve it in `O(n)` time complexity.\r\n\r\n### Example 1\r\n\r\n```bash\r\nInput: nums = [3,2,1,5,6,4], k = 2\r\nOutput: 5\r\n```\r\n\r\n### Example 2\r\n\r\n```bash\r\nInput: nums = [3,2,3,1,2,4,5,5,6], k = 4\r\nOutput: 4\r\n```\r\n\r\n### Constraints:\r\n\r\n- 1 <= k <= nums.length <= 10^5 \r\n- -10^4 <= nums[i] <= 10^4","basename":"kth-largest-element-in-an-array"},"kth-smallest-element-in-a-bst":{"title":"Kth Smallest Element in a BST","description":"Given the root of a binary search tree, and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree.","tags":["medium","binary-tree"],"link":"https://leetcode.com/problems/kth-smallest-element-in-a-bst/","images":["https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg","https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg"],"preview":"### Description\r\n\r\nGiven the `root` of a binary search tree, and an integer k, return the kth smallest value (**1-indexed**) of all the values of the nodes in the tree.\r\n\r\n### Example 1\r\n\r\n![](https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg)\r\n\r\n```bash\r\nInput: root = [3,1,4,null,2], k = 1\r\nOutput: 1\r\n```\r\n\r\n### Example 2\r\n\r\n![](https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg)\r\n\r\n```bash\r\nInput: root = [5,3,6,2,4,null,null,1], k = 3\r\nOutput: 3\r\n```\r\n\r\n### Constraints:\r\n\r\n- The number of nodes in the tree is n.\r\n- 1 <= k <= n <= 104\r\n- 0 <= Node.val <= 104","basename":"kth-smallest-element-in-a-bst"},"largest-rectangle-area":{"title":"Largest Rectangle in Histogram","description":"Given an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.","tags":["medium","stack"],"link":"https://leetcode.com/problems/largest-rectangle-in-histogram/","preview":"### Description\r\n\r\nGiven an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.\r\n\r\n### Example 1\r\n\r\n![image](https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg)\r\n\r\n```bash\r\nInput: heights = [2,1,5,6,2,3]\r\nOutput: 10\r\nExplanation: The above is a histogram where width of each bar is 1.\r\nThe largest rectangle is shown in the red area, which has an area = 10 units.\r\n```\r\n\r\n### Example 2\r\n\r\n![image](https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg)\r\n\r\n```bash\r\nInput: heights = [2,4]\r\nOutput: 4\r\n```\r\n\r\n### Constraints:\r\n\r\n-      1 <= heights.length <= 105     \r\n-      0 <= heights[i] <= 104","basename":"largest-rectangle-area"},"last-stone-weight":{"title":"Last Stone Weight","description":"You are given an array of integers stones where stones[i] is the weight of the ith stone.","tags":["easy","heap"],"link":"https://leetcode.com/problems/last-stone-weight/","images":[],"preview":"### Description\r\n\r\nYou are given an array of integers stones where `stones[i]` is the weight of the ith stone.\r\n\r\nWe are playing a game with the stones. On each turn, we choose the **heaviest two stones** and smash them together. Suppose the heaviest two stones have weights x and y with x <= y. The result of this smash is:\r\n\r\n- If x == y, both stones are destroyed, and\r\n- If x != y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x.\r\nAt the end of the game, there is **at most one** stone left.\r\n\r\nReturn the weight of the last remaining stone. If there are no stones left, return 0.\r\n\r\n### Example 1\r\n\r\n```bash\r\nInput: stones = [2,7,4,1,8,1]\r\nOutput: 1\r\nExplanation: \r\nWe combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then,\r\nwe combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then,\r\nwe combine 2 and 1 to get 1 so the array converts to [1,1,1] then,\r\nwe combine 1 and 1 to get 0 so the array converts to [1] then that's the value of the last stone.\r\n```\r\n\r\n### Example 2\r\n\r\n```bash\r\nInput: stones = [1]\r\nOutput: 1\r\n```\r\n\r\n### Constraints:\r\n\r\n- 1 <= stones.length <= 30 \r\n- 1 <= stones[i] <= 1000","basename":"last-stone-weight"},"length-of-longest-substring":{"title":"Length of Longest Substring","description":"Given a string s, find the length of the longest substring without repeating characters.","tags":["medium","sliding-window"],"preview":"### Description\r\n\r\nGiven a string s, find the length of the longest substring without repeating characters.\r\n\r\n### Example 1\r\n\r\n\r\n```bash\r\nInput: s = \"abcabcbb\"\r\nOutput: 3\r\nExplanation: The answer is \"abc\", with the length of 3.\r\n```\r\n\r\n### Example 2\r\n```bash\r\nInput: s = \"bbbbb\"\r\nOutput: 1\r\nExplanation: The answer is \"b\", with the length of 1.\r\n```\r\n\r\n### Example 3\r\n```bash\r\nInput: s = \"pwwkew\"\r\nOutput: 3\r\nExplanation: The answer is \"wke\", with the length of 3.\r\nNotice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\r\n```\r\n\r\n\r\n### Constraints:\r\n\r\n- 0 <= s.length <= 5 * 104\r\n- s consists of English letters, digits, symbols and spaces.","basename":"length-of-longest-substring"},"letter-combinations-of-a-phone-number":{"title":"Letter Combinations of a Phone Number","description":"Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.","tags":["hard","backtracking"],"link":"https://leetcode.com/problems/letter-combinations-of-a-phone-number/","images":[],"preview":"### Description\r\n\r\nGiven a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in **any order**.\r\nA mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\r\n\r\n### Example 1\r\n\r\n![Example 1](https://assets.leetcode.com/uploads/2022/03/15/1200px-telephone-keypad2svg.png)\r\n\r\n\r\n```bash\r\nInput: digits = \"23\"\r\nOutput: [\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]\r\n```\r\n\r\n### Example 2\r\n\r\n```bash\r\nInput: digits = \"\"\r\nOutput: []\r\n```\r\n\r\n### Example 3\r\n\r\n```bash\r\nInput: digits = \"2\"\r\nOutput: [\"a\",\"b\",\"c\"]\r\n```\r\n\r\n\r\n### Constraints:\r\n\r\n- 0 <= digits.length <= 4\r\n- digits[i] is a digit in the range ['2', '9']","basename":"letter-combinations-of-a-phone-number"},"linked-list-cycle":{"title":"Linked List Cycle","description":"Given head, the head of a linked list, determine if the linked list has a cycle in it.","tags":["medium","linked-list"],"link":"https://leetcode.com/problems/linked-list-cycle/","preview":"### Description\r\n\r\nGiven `head`, the head of a linked list, determine if the linked list has a cycle in it.\r\n\r\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. **Note that** pos **is not passed as a parameter**.\r\n\r\nReturn `true` if there is a cycle in the linked list. Otherwise, return `false`.\r\n\r\n### Example 1\r\n\r\n```bash\r\nInput: head = [3,2,0,-4], pos = 1\r\nOutput: true\r\nExplanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).\r\n```\r\n\r\n### Example 2\r\n\r\n```bash\r\nInput: head = [1,2], pos = 0\r\nOutput: true\r\nExplanation: There is a cycle in the linked list, where the tail connects to the 0th node.\r\n```\r\n\r\n### Constraints:\r\n\r\n- The number of the nodes in the list is in the range [0, 104]. \r\n- -10^5 <= Node.val <= 10^5 \r\n- pos is -1 or a valid index in the linked-list.","basename":"linked-list-cycle"},"lru-cache":{"title":"LRU Cache","description":"Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.","tags":["medium","linked-list"],"link":"https://leetcode.com/problems/lru-cache/","preview":"### Description\r\n\r\nDesign a data structure that follows the constraints of a Least Recently Used (LRU) cache.\r\n\r\nImplement the `LRUCache` class:\r\n\r\n- LRUCache(int capacity) Initialize the LRU cache with **positive** size capacity.\r\n- `int get(int key)` Return the value of the key if the key exists, otherwise return -1.\r\n- void `put(int key, int value)` Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, **evict** the least recently used key.\r\n\r\nThe functions get and put must each run in O(1) average time complexity.\r\n\r\n### Example 1\r\n\r\n```bash\r\nInput\r\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\r\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\r\nOutput\r\n[null, null, null, 1, null, -1, null, -1, 3, 4]\r\n\r\nExplanation\r\nLRUCache lRUCache = new LRUCache(2);\r\nlRUCache.put(1, 1); // cache is {1=1}\r\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\r\nlRUCache.get(1);    // return 1\r\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\r\nlRUCache.get(2);    // returns -1 (not found)\r\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\r\nlRUCache.get(1);    // return -1 (not found)\r\nlRUCache.get(3);    // return 3\r\nlRUCache.get(4);    // return 4\r\n```\r\n\r\n\r\n### Constraints:\r\n\r\n- 1 <= capacity <= 3000\r\n- 0 <= key <= 104\r\n- 0 <= value <= 105\r\n- At most 2 * 105 calls will be made to get and put.","basename":"lru-cache"},"max-area-of-island":{"title":"Max Area of Island","description":"You are given an m x n binary matrix grid. An island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.","tags":["medium","graphs"],"link":"https://leetcode.com/problems/max-area-of-island/","images":[],"preview":"### Description\r\n\r\nYou are given an m x n binary matrix grid. An island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.\r\n\r\nThe area of an island is the number of cells with a value 1 in the island.\r\n\r\nReturn the maximum area of an island in grid. If there is no island, return 0.\r\n\r\n### Example 1\r\n\r\n![](https://assets.leetcode.com/uploads/2021/05/01/maxarea1-grid.jpg)\r\n\r\n```bash\r\nInput: grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]\r\nOutput: 6\r\nExplanation: The answer is not 11, because the island must be connected 4-directionally.\r\n```\r\n\r\n### Example 2\r\n\r\n```bash\r\nInput: grid = [[0,0,0,0,0,0,0,0]]\r\nOutput: 0\r\n```\r\n\r\n### Constraints:\r\n\r\n- m == grid.length \r\n- n == grid[i].length \r\n- 1 <= m, n <= 50 \r\n- grid[i][j] is either 0 or 1.","basename":"max-area-of-island"},"max-profit":{"title":"Max Profit","description":"Best time to Buy and Sell Stock","tags":["easy","sliding-window"],"preview":"### Description\r\n\r\nYou are given an array prices where prices[i] is the price of a given stock on the ith day.\r\n\r\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\r\n\r\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.\r\n\r\n### Example 1\r\n\r\n```bash\r\nInput: prices = [7,1,5,3,6,4]\r\nOutput: 5\r\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\r\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\r\n```\r\n\r\n### Example 2\r\n\r\n```bash\r\nInput: prices = [7,6,4,3,1]\r\nOutput: 0\r\nExplanation: In this case, no transactions are done and the max profit = 0.\r\n```\r\n\r\n### Constraints:\r\n\r\n-  1 <= prices.length <= 105\r\n-  0 <= prices[i] <= 104","basename":"max-profit"},"max-sliding-window":{"title":"Max Sliding Window","description":"Sliding Window Maximum","tags":["hard","sliding-window"],"link":"https://leetcode.com/problems/sliding-window-maximum/","preview":"### Description\r\n\r\nYou are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.  Return the max sliding window.\r\n\r\n### Example 1\r\n\r\n```bash\r\nInput: nums = [1,3,-1,-3,5,3,6,7], k = 3\r\nOutput: [3,3,5,5,6,7]\r\nExplanation: \r\nWindow position                Max\r\n---------------               -----\r\n[1  3  -1] -3  5  3  6  7       3\r\n 1 [3  -1  -3] 5  3  6  7       3\r\n 1  3 [-1  -3  5] 3  6  7       5\r\n 1  3  -1 [-3  5  3] 6  7       5\r\n 1  3  -1  -3 [5  3  6] 7       6\r\n 1  3  -1  -3  5 [3  6  7]      7\r\n```\r\n\r\n### Example 2\r\n```bash\r\nInput: nums = [1], k = 1\r\nOutput: [1]\r\n```\r\n\r\n### Constraints:\r\n\r\n-      1 <= nums.length <= 10^5     \r\n-      -10^4 <= nums[i] <= 10^4     \r\n-      1 <= k <= nums.length","basename":"max-sliding-window"},"maximum-depth-of-binary-tree":{"title":"Maximum Depth of Binary Tree","description":"A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.","tags":["easy","binary-tree"],"link":"https://leetcode.com/problems/maximum-depth-of-binary-tree/","images":["https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg"],"preview":"### Description\r\n\r\nGiven the root of a binary tree, return its maximum depth.\r\n\r\nA binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\r\n\r\n### Example 1\r\n\r\n![](https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg)\r\n\r\n```bash\r\nInput: root = [3,9,20,null,null,15,7]\r\nOutput: 3\r\n```\r\n\r\n### Example 2\r\n\r\n```bash\r\nInput: root = [1,null,2]\r\nOutput: 2\r\n```\r\n\r\n### Constraints:\r\n\r\n- The number of nodes in the tree is in the range [0, 104]. \r\n- -100 <= Node.val <= 100","basename":"maximum-depth-of-binary-tree"},"median-sorted-arrays":{"title":"Median of Two Sorted Arrays","description":"Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.","tags":["hard","binary-search","array"],"link":"https://leetcode.com/problems/median-of-two-sorted-arrays/","preview":"### Description\r\n\r\nGiven two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively, return **the median** of the two sorted arrays.\r\n\r\nThe overall run time complexity should be `O(log (m+n))`.\r\n\r\n### Example 1\r\n\r\n```bash\r\nInput: nums1 = [1,3], nums2 = [2]\r\nOutput: 2.00000\r\nExplanation: merged array = [1,2,3] and median is 2.\r\n```\r\n\r\n### Example 2\r\n\r\n```bash\r\nInput: nums1 = [1,2], nums2 = [3,4]\r\nOutput: 2.50000\r\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\r\n```\r\n\r\n### Constraints:\r\n\r\n-      nums1.length == m     \r\n-      nums2.length == n     \r\n-      0 <= m <= 1000     \r\n-      0 <= n <= 1000     \r\n-      1 <= m + n <= 2000     \r\n-      -106 <= nums1[i], nums2[i] <= 106","basename":"median-sorted-arrays"},"merge-k-sorted-list":{"title":"Merge k Sorted Lists","description":"You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.","tags":["hard","linked-list"],"link":"https://leetcode.com/problems/merge-k-sorted-lists/","preview":"### Description\r\n\r\nYou are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\r\n\r\nMerge all the linked-lists into one sorted linked-list and return it.\r\n\r\n \r\n\r\n### Example 1\r\n\r\n```bash\r\nInput: lists = [[1,4,5],[1,3,4],[2,6]]\r\nOutput: [1,1,2,3,4,4,5,6]\r\nExplanation: The linked-lists are:\r\n[\r\n  1->4->5,\r\n  1->3->4,\r\n  2->6\r\n]\r\nmerging them into one sorted list:\r\n1->1->2->3->4->4->5->6\r\n```\r\n\r\n### Example 2\r\n\r\n```bash\r\n\r\n```\r\n\r\n### Example 3\r\n\r\n```bash\r\nInput: lists = [[]]\r\nOutput: []\r\n```\r\n\r\n### Constraints:\r\n\r\n- k == lists.length \r\n- 0 <= k <= 10^4 \r\n- 0 <= lists[i].length <= 500 \r\n- -10^4 <= lists[i][j] <= 10^4 \r\n- lists[i] is sorted in **ascending order**. \r\n- The sum of lists[i].length will not exceed 10^4.","basename":"merge-k-sorted-list"},"merge-two-sorted-list":{"title":"Merge Two Sorted Lists","description":"You are given the heads of two sorted linked lists list1 and list2. Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.","tags":["easy","linked-list"],"link":"https://leetcode.com/problems/merge-two-sorted-lists/","images":["https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg"],"preview":"### Description\r\n\r\nYou are given the heads of two sorted linked lists list1 and list2.\r\n\r\nMerge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.\r\n\r\nReturn the head of the merged linked list.\r\n\r\n### Example 1\r\n\r\n![](https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg)\r\n\r\n```bash\r\nInput: list1 = [1,2,4], list2 = [1,3,4]\r\nOutput: [1,1,2,3,4,4]\r\n```\r\n\r\n### Example 2\r\n\r\n```bash\r\nInput: list1 = [], list2 = []\r\nOutput: []\r\n```\r\n\r\n### Example 3\r\n\r\n```bash\r\nInput: list1 = [], list2 = [0]\r\nOutput: [0]\r\n```\r\n\r\n### Constraints:\r\n\r\n- The number of nodes in both lists is in the range [0, 50]. \r\n- -100 <= Node.val <= 100 \r\n- Both list1 and list2 are sorted in non-decreasing order.","basename":"merge-two-sorted-list"},"min-stack":{"title":"Min Stack","description":"Min Stack","tags":["medium","stack"],"link":"https://leetcode.com/problems/min-stack/","preview":"### Description\r\n\r\nDesign a stack that supports push, pop, top, and retrieving the minimum element in constant time.\r\n\r\nImplement the MinStack class:\r\n\r\n    MinStack() initializes the stack object.\r\n    void push(int val) pushes the element val onto the stack.\r\n    void pop() removes the element on the top of the stack.\r\n    int top() gets the top element of the stack.\r\n    int getMin() retrieves the minimum element in the stack.\r\n\r\nYou must implement a solution with O(1) time complexity for each function.\r\n\r\n### Example 1\r\n```bash\r\nInput\r\n[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"]\r\n[[],[-2],[0],[-3],[],[],[],[]]\r\n\r\nOutput\r\n[null,null,null,null,-3,null,0,-2]\r\n\r\nExplanation\r\nMinStack minStack = new MinStack();\r\nminStack.push(-2);\r\nminStack.push(0);\r\nminStack.push(-3);\r\nminStack.getMin(); // return -3\r\nminStack.pop();\r\nminStack.top();    // return 0\r\nminStack.getMin(); // return -2\r\n```\r\n\r\n### Constraints:\r\n\r\n- -2^31 <= val <= 2^31 - 1     \r\n- Methods pop, top and getMin operations will always be called on non-empty stacks.     \r\n- At most 3 * 104 calls will be made to push, pop, top, and getMin.","basename":"min-stack"},"min-window":{"title":"Min Window Substring","description":"Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \"\".","tags":["hard","sliding-window"],"preview":"### Description\r\n\r\nGiven two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \"\".\r\n\r\n### Example 1\r\n```bash\r\nInput: s = \"ADOBECODEBANC\", t = \"ABC\"\r\nOutput: \"BANC\"\r\nExplanation: The minimum window substring \"BANC\" includes 'A', 'B', and 'C' from string t.\r\n```\r\n\r\n### Example 2\r\n```bash\r\nInput: s = \"a\", t = \"a\"\r\nOutput: \"a\"\r\nExplanation: The entire string s is the minimum window.\r\n```\r\n\r\n### Example 3\r\n```bash\r\nInput: s = \"a\", t = \"aa\"\r\nOutput: \"\"\r\nExplanation: Both 'a's from t must be included in the window.\r\nSince the largest window of s only has one 'a', return empty string.\r\n```\r\n\r\n### Constraints:\r\n\r\n-      m == s.length     \r\n-      n == t.length     \r\n-      1 <= m, n <= 105     \r\n-      s and t consist of uppercase and lowercase English letters.","basename":"min-window"},"n-queens":{"title":"N-Queens","description":"The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.","tags":["hard","backtracking"],"link":"https://leetcode.com/problems/n-queens/","images":[],"preview":"### Description\r\n\r\nThe **n-queens** puzzle is the problem of placing n queens on an `n x n` chessboard such that no two queens attack each other.\r\n\r\nGiven an integer n, return all distinct solutions to the **n-queens puzzle**. You may return the answer in **any order**.\r\n\r\nEach solution contains a distinct board configuration of the n-queens' placement, where `'Q'` and `'.'` both indicate a queen and an empty space, respectively.\r\n\r\n### Example 1\r\n\r\n![](https://assets.leetcode.com/uploads/2020/11/13/queens.jpg)\r\n\r\n\r\n```bash\r\nInput: n = 4\r\nOutput: [[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]\r\nExplanation: There exist two distinct solutions to the 4-queens puzzle as shown above\r\n```\r\n\r\n### Example 2\r\n\r\n```bash\r\nInput: n = 1\r\nOutput: [[\"Q\"]]\r\n```\r\n\r\n### Constraints:\r\n\r\n- `1 <= n <= 9`","basename":"n-queens"},"number-of-connected-components-in-an-undirected-graph":{"title":"Redundant Connection","description":"find the number of connected components in an undirected graph.","tags":["medium","graphs"],"link":"https://cheonhyangzhang.gitbooks.io/leetcode-solutions/content/323-number-of-connected-components-in-an-undirected-graph.html","images":[],"preview":"### Description\r\n\r\nGiven n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to find the number of connected components in an undirected graph.\r\n\r\n### Example 1\r\n\r\n```bash\r\n\r\nExample 1:\r\n\r\n     0          3\r\n     |          |\r\n     1 --- 2    4\r\n\r\nGiven n = 5 and edges = [[0, 1], [1, 2], [3, 4]], return 2.\r\n```\r\n\r\n### Example 2\r\n\r\n```bash\r\n\r\nExample 2:\r\n\r\n     0           4\r\n     |           |\r\n     1 --- 2 --- 3\r\n\r\nGiven n = 5 and edges = [[0, 1], [1, 2], [2, 3], [3, 4]], return 1.\r\n```\r\n\r\n### Constraints:\r\n\r\nNote:\r\nYou can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges.","basename":"number-of-connected-components-in-an-undirected-graph"},"number-of-islands":{"title":"Number of Islands","description":"Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.","tags":["medium","graphs"],"link":null,"images":[],"preview":"### Description\r\n\r\nGiven an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\r\n\r\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\r\n\r\n\r\n### Example 1\r\n\r\n```bash\r\nInput: grid = [\r\n  [\"1\",\"1\",\"1\",\"1\",\"0\"],\r\n  [\"1\",\"1\",\"0\",\"1\",\"0\"],\r\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\r\n  [\"0\",\"0\",\"0\",\"0\",\"0\"]\r\n]\r\nOutput: 1\r\n```\r\n\r\n### Example 2\r\n\r\n```bash\r\n\r\n```\r\n\r\n### Constraints:\r\n\r\n-","basename":"number-of-islands"},"pacific-atlantic-water-flow":{"title":"Pacific Atlantic Water Flow","description":"There is an m x n rectangular island that borders both the Pacific Ocean and Atlantic Ocean. The Pacific Ocean touches the island's left and top edges, and the Atlantic Ocean touches the island's right and bottom edges.","tags":["medium","graphs"],"link":"https://leetcode.com/problems/pacific-atlantic-water-flow/","images":[],"preview":"### Description\r\n\r\nThere is an m x n rectangular island that borders both the** Pacific Ocean** and Atlantic Ocean. The Pacific Ocean touches the island's left and top edges, and the Atlantic Ocean touches the island's right and bottom edges.\r\n\r\nThe island is partitioned into a grid of square cells. You are given an m x n integer matrix heights where heights[r][c] represents the **height above sea level** of the cell at coordinate (r, c).\r\n\r\nThe island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell's height is **less than or equal to** the current cell's height. Water can flow from any cell adjacent to an ocean into the ocean.\r\n\r\nReturn a **2D list** of grid coordinates result where result[i] = [ri, ci] denotes that rain water can flow from cell (ri, ci) to **both** the Pacific and Atlantic oceans.\r\n\r\n### Example 1\r\n\r\n![](https://assets.leetcode.com/uploads/2021/06/08/waterflow-grid.jpg)\r\n\r\n```bash\r\nInput: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]\r\nOutput: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]\r\nExplanation: The following cells can flow to the Pacific and Atlantic oceans, as shown below:\r\n[0,4]: [0,4] -> Pacific Ocean \r\n       [0,4] -> Atlantic Ocean\r\n[1,3]: [1,3] -> [0,3] -> Pacific Ocean \r\n       [1,3] -> [1,4] -> Atlantic Ocean\r\n[1,4]: [1,4] -> [1,3] -> [0,3] -> Pacific Ocean \r\n       [1,4] -> Atlantic Ocean\r\n[2,2]: [2,2] -> [1,2] -> [0,2] -> Pacific Ocean \r\n       [2,2] -> [2,3] -> [2,4] -> Atlantic Ocean\r\n[3,0]: [3,0] -> Pacific Ocean \r\n       [3,0] -> [4,0] -> Atlantic Ocean\r\n[3,1]: [3,1] -> [3,0] -> Pacific Ocean \r\n       [3,1] -> [4,1] -> Atlantic Ocean\r\n[4,0]: [4,0] -> Pacific Ocean \r\n       [4,0] -> Atlantic Ocean\r\nNote that there are other possible paths for these cells to flow to the Pacific and Atlantic oceans.\r\n```\r\n\r\n### Example 2\r\n\r\n```bash\r\nInput: heights = [[1]]\r\nOutput: [[0,0]]\r\nExplanation: The water can flow from the only cell to the Pacific and Atlantic oceans.\r\n```\r\n\r\n### Constraints:\r\n\r\n- m == heights.length\r\n- n == heights[r].length\r\n- 1 <= m, n <= 200\r\n- 0 <= heights[r][c] <= 10^5","basename":"pacific-atlantic-water-flow"},"palindrome-partitioning":{"title":"Palindrome Partitioning","description":"Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s.","tags":[],"link":"https://leetcode.com/problems/palindrome-partitioning/","images":[],"preview":"### Description\r\n\r\nGiven a string `s`, partition `s` such that every substring of the partition is a **palindrome**. Return all possible palindrome partitioning of `s`.\r\n\r\n### Example 1\r\n\r\n```bash\r\nInput: s = \"aab\"\r\nOutput: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\r\n```\r\n\r\n### Example 2\r\n\r\n```bash\r\nInput: s = \"a\"\r\nOutput: [[\"a\"]]\r\n```\r\n\r\n### Constraints:\r\n\r\n- 1 <= s.length <= 16 \r\n- `s` contains only lowercase English letters.","basename":"palindrome-partitioning"},"permutations":{"title":"Permutations","description":"Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.","tags":["medium","backtracking"],"link":"https://leetcode.com/problems/permutations/","images":[],"preview":"### Description\r\n\r\nGiven an array `nums` of distinct integers, return all the possible permutations. You can return the answer **in any order**.\r\n\r\n### Example 1\r\n\r\n```bash\r\nInput: nums = [1,2,3]\r\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\r\n```\r\n\r\n### Example 2\r\n\r\n```bash\r\nInput: nums = [0,1]\r\nOutput: [[0,1],[1,0]]\r\n```\r\n\r\n### Example 3\r\n\r\n```bash\r\nInput: nums = [1]\r\nOutput: [[1]]\r\n```\r\n\r\n### Constraints:\r\n\r\n- 1 <= nums.length <= 6 \r\n- -10 <= nums[i] <= 10 \r\n- All the integers of nums are unique.","basename":"permutations"},"prompt":{"preview":"{\"add-two-numbers\":{\"title\":\"Add Two Numbers\",\"description\":\"You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\",\"tags\":[\"medium\",\"linked-list\"],\"link\":\"https://leetcode.com/problems/add-two-numbers/\",\"images\":[\"https://assets.leetcode.com/uploads/2020/10/02/addtwonumber1.jpg\"],\"preview\":\"### Description\\r\\n\\r\\nYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\\r\\n\\r\\n\\r\\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\\r\\n\\r\\n### Example 1\\r\\n\\r\\n![](https://assets.leetcode.com/uploads/2020/10/02/addtwonumber1.jpg)\\r\\n\\r\\n```bash\\r\\nInput: l1 = [2,4,3], l2 = [5,6,4]\\r\\nOutput: [7,0,8]\\r\\nExplanation: 342 + 465 = 807.\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n\\r\\n```bash\\r\\nInput: l1 = [0], l2 = [0]\\r\\nOutput: [0]\\r\\n```\\r\\n\\r\\n### Example 3\\r\\n\\r\\n```bash\\r\\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\\r\\nOutput: [8,9,9,9,0,0,0,1]\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n- The number of nodes in each linked list is in the range [1, 100]. \\r\\n- 0 <= Node.val <= 9 \\r\\n- It is guaranteed that the list represents a number that does not have leading zeros.\",\"basename\":\"add-two-numbers\"},\"balanced-binary-tree\":{\"title\":\"Balanced Binary Tree\",\"description\":\"Given a binary tree, determine if it is height-balanced.\",\"tags\":[\"easy\",\"binary-tree\"],\"link\":\"https://leetcode.com/problems/balanced-binary-tree/\",\"images\":[\"https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg\"],\"preview\":\"### Description\\r\\n\\r\\nGiven a binary tree, determine if it is height-balanced.\\r\\n\\r\\n### Example 1\\r\\n\\r\\n\\r\\n![](https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg)\\r\\n\\r\\n```bash\\r\\nInput: root = [3,9,20,null,null,15,7]\\r\\nOutput: true\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n\\r\\n![](https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg)\\r\\n\\r\\n```bash\\r\\nInput: root = [1,2,2,3,3,null,null,4,4]\\r\\nOutput: false\\r\\n```\\r\\n\\r\\n### Example 3\\r\\n\\r\\n```bash\\r\\nInput: root = []\\r\\nOutput: true\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n- The number of nodes in the tree is in the range [0, 5000]. \\r\\n- -10^4 <= Node.val <= 10^4\",\"basename\":\"balanced-binary-tree\"},\"binary-search\":{\"title\":\"Binary Search\",\"description\":\"Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.\",\"tags\":[\"medium\",\"binary-search\"],\"link\":\"https://leetcode.com/problems/binary-search/\",\"images\":[],\"preview\":\"### Description\\r\\n\\r\\nGiven an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.\\r\\n\\r\\nYou must write an algorithm with O(log n) runtime complexity.\\r\\n\\r\\n### Example 1\\r\\n\\r\\n```bash\\r\\nInput: nums = [-1,0,3,5,9,12], target = 9\\r\\nOutput: 4\\r\\nExplanation: 9 exists in nums and its index is 4\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n\\r\\n```bash\\r\\nInput: nums = [-1,0,3,5,9,12], target = 2\\r\\nOutput: -1\\r\\nExplanation: 2 does not exist in nums so return -1\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n-     1 <= nums.length <= 104\\r\\n-     -104 < nums[i], target < 104\\r\\n-     All the integers in nums are unique.\\r\\n-     uunums is sorted in ascending order.\",\"basename\":\"binary-search\"},\"binary-tree-level-order-traversal\":{\"title\":\"Binary Tree Level Order Traversal\",\"description\":\"Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).\",\"tags\":[\"medium\",\"binary-tree\"],\"link\":\"https://leetcode.com/problems/binary-tree-level-order-traversal/\",\"images\":[\"https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg\"],\"preview\":\"### Description\\r\\n\\r\\nGiven the `root` of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).\\r\\n\\r\\n### Example 1\\r\\n\\r\\n![](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)\\r\\n\\r\\n```bash\\r\\nInput: root = [3,9,20,null,null,15,7]\\r\\nOutput: [[3],[9,20],[15,7]]\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n\\r\\n```bash\\r\\nInput: root = [1]\\r\\nOutput: [[1]]\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n- The number of nodes in the tree is in the range [0, 2000]. \\r\\n- -1000 <= Node.val <= 1000\",\"basename\":\"binary-tree-level-order-traversal\"},\"binary-tree-maximum-path-sum\":{\"title\":\"Binary Tree Maximum Path Sum\",\"description\":\"Given the root of a binary tree, return the maximum path sum of any non-empty path.\",\"tags\":[\"hard\",\"binary-tree\"],\"link\":\"https://leetcode.com/problems/binary-tree-maximum-path-sum/\",\"images\":[\"https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg\",\"https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg\"],\"preview\":\"### Description\\r\\n\\r\\nA path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.\\r\\n\\r\\nThe path sum of a path is the sum of the node's values in the path.\\r\\n\\r\\nGiven the root of a binary tree, return the maximum path sum of any non-empty path.\\r\\n\\r\\n### Example 1\\r\\n\\r\\n![](https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg)\\r\\n\\r\\n```bash\\r\\nInput: root = [1,2,3]\\r\\nOutput: 6\\r\\nExplanation: The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6.\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n\\r\\n![](https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg)\\r\\n\\r\\n```bash\\r\\nInput: root = [-10,9,20,null,null,15,7]\\r\\nOutput: 42\\r\\nExplanation: The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42.\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n- The number of nodes in the tree is in the range [1, 3 * 10^4]. \\r\\n- -1000 <= Node.val <= 1000\",\"basename\":\"binary-tree-maximum-path-sum\"},\"binary-tree-right-side-view\":{\"title\":\"Binary Tree Right Side View\",\"description\":\"Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.\",\"tags\":[\"medium\",\"binary-tree\"],\"link\":\"https://leetcode.com/problems/binary-tree-right-side-view/\",\"images\":[\"https://assets.leetcode.com/uploads/2021/02/14/tree.jpg\"],\"preview\":\"### Description\\r\\n\\r\\nGiven the `root` of a binary tree, imagine yourself standing on the **right side** of it, return the values of the nodes you can see ordered from top to bottom.\\r\\n\\r\\n### Example 1\\r\\n\\r\\n![](https://assets.leetcode.com/uploads/2021/02/14/tree.jpg)\\r\\n\\r\\n\\r\\n```bash\\r\\nInput: root = [1,2,3,null,5,null,4]\\r\\nOutput: [1,3,4]\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n\\r\\n```bash\\r\\nInput: root = [1,null,3]\\r\\nOutput: [1,3]\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n- The number of nodes in the tree is in the range [0, 100]. \\r\\n- -100 <= Node.val <= 100\",\"basename\":\"binary-tree-right-side-view\"},\"car-fleet\":{\"title\":\"Car Fleet\",\"description\":\"There are n cars going to the same destination along a one-lane road. The destination is target miles away.\",\"tags\":[\"medium\",\"stack\"],\"link\":\"https://leetcode.com/problems/car-fleet/\",\"images\":[],\"preview\":\"### Description\\r\\n\\r\\nThere are `n` cars going to the same destination along a one-lane road. The destination is `target` miles away.\\r\\n\\r\\nYou are given two integer array position and speed, both of length n, where position[i] is the position of the ith car and speed[i] is the speed of the ith car (in miles per hour).\\r\\n\\r\\nA car can never pass another car ahead of it, but it can catch up to it and drive bumper to bumper at the same speed. The faster car will slow down to match the slower car's speed. The distance between these two cars is ignored (i.e., they are assumed to have the same position).\\r\\n\\r\\nA car fleet is some non-empty set of cars driving at the same position and same speed. Note that a single car is also a car fleet.\\r\\n\\r\\nIf a car catches up to a car fleet right at the destination point, it will still be considered as one car fleet.\\r\\n\\r\\nReturn the number of car fleets that will arrive at the destination.\\r\\n\\r\\n### Example 1\\r\\n\\r\\n```bash\\r\\nInput: target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]\\r\\nOutput: 3\\r\\nExplanation:\\r\\nThe cars starting at 10 (speed 2) and 8 (speed 4) become a fleet, meeting each other at 12.\\r\\nThe car starting at 0 does not catch up to any other car, so it is a fleet by itself.\\r\\nThe cars starting at 5 (speed 1) and 3 (speed 3) become a fleet, meeting each other at 6. The fleet moves at speed 1 until it reaches target.\\r\\nNote that no other cars meet these fleets before the destination, so the answer is 3.\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n\\r\\n```bash\\r\\nInput: target = 10, position = [3], speed = [3]\\r\\nOutput: 1\\r\\nExplanation: There is only one car, hence there is only one fleet.\\r\\n```\\r\\n\\r\\n### Example 3\\r\\n\\r\\n```bash\\r\\nInput: target = 100, position = [0,2,4], speed = [4,2,1]\\r\\nOutput: 1\\r\\nExplanation:\\r\\nThe cars starting at 0 (speed 4) and 2 (speed 2) become a fleet, meeting each other at 4. The fleet moves at speed 2.\\r\\nThen, the fleet (speed 2) and the car starting at 4 (speed 1) become one fleet, meeting each other at 6. The fleet moves at speed 1 until it reaches target.\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n-      n == position.length == speed.length     \\r\\n-      1 <= n <= 105\\r\\n-      0 < target <= 106\\r\\n-      0 <= position[i] < target\\r\\n-      All the values of position are unique.\\r\\n-      0 < speed[i] <= 106\",\"basename\":\"car-fleet\"},\"character-replacement\":{\"title\":\"Character Replacement\",\"description\":\"Longest Repeating Character Replacement\",\"tags\":[\"medium\",\"sliding-window\"],\"preview\":\"### Description\\r\\n\\r\\nYou are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times.\\r\\n\\r\\nReturn the length of the longest substring containing the same letter you can get after performing the above operations.\\r\\n\\r\\n### Example 1\\r\\n```bash\\r\\nInput: s = \\\"ABAB\\\", k = 2\\r\\nOutput: 4\\r\\nExplanation: Replace the two 'A's with two 'B's or vice versa.\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n```bash\\r\\nInput: s = \\\"AABABBA\\\", k = 1\\r\\nOutput: 4\\r\\nExplanation: Replace the one 'A' in the middle with 'B' and form \\\"AABBBBA\\\".\\r\\nThe substring \\\"BBBB\\\" has the longest repeating letters, which is 4.\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n- 1 <= s.length <= 105\\r\\n- s consists of only uppercase English letters.\\r\\n- 0 <= k <= s.length\",\"basename\":\"character-replacement\"},\"clone-graph\":{\"title\":\"Clone Graph\",\"description\":\"Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\",\"tags\":[\"medium\",\"graphs\"],\"link\":null,\"images\":[],\"preview\":\"### Description\\r\\n\\r\\nGiven an `m x n` 2D binary grid `grid` which represents a map of `'1's` (land) and `'0's` (water), return the number of islands.\\r\\n\\r\\nAn **island** is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\\r\\n\\r\\n### Example 1\\r\\n\\r\\n```bash\\r\\nInput: grid = [\\r\\n  [\\\"1\\\",\\\"1\\\",\\\"1\\\",\\\"1\\\",\\\"0\\\"],\\r\\n  [\\\"1\\\",\\\"1\\\",\\\"0\\\",\\\"1\\\",\\\"0\\\"],\\r\\n  [\\\"1\\\",\\\"1\\\",\\\"0\\\",\\\"0\\\",\\\"0\\\"],\\r\\n  [\\\"0\\\",\\\"0\\\",\\\"0\\\",\\\"0\\\",\\\"0\\\"]\\r\\n]\\r\\nOutput: 1\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n\\r\\n```bash\\r\\n\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n-\",\"basename\":\"clone-graph\"},\"combination-sum-ii\":{\"title\":\"Combination Sum II\",\"description\":\"Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.\",\"tags\":[\"medium\",\"backtracking\"],\"link\":null,\"images\":[],\"preview\":\"### Description\\r\\n\\r\\nGiven a collection of candidate numbers (`candidates`) and a target number (`target`), find all unique combinations in `candidates` where the candidate numbers sum to target.\\r\\n\\r\\nEach number in candidates may only be used **once** in the combination.\\r\\n\\r\\n**Note**: The solution set must not contain duplicate combinations.\\r\\n\\r\\n### Example 1\\r\\n\\r\\n```bash\\r\\nInput: candidates = [10,1,2,7,6,1,5], target = 8\\r\\nOutput: \\r\\n[\\r\\n[1,1,6],\\r\\n[1,2,5],\\r\\n[1,7],\\r\\n[2,6]\\r\\n]\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n\\r\\n```bash\\r\\nInput: candidates = [2,5,2,1,2], target = 5\\r\\nOutput: \\r\\n[\\r\\n[1,2,2],\\r\\n[5]\\r\\n]\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n- 1 <= candidates.length <= 100 \\r\\n- 1 <= candidates[i] <= 50 \\r\\n- 1 <= target <= 30\",\"basename\":\"combination-sum-ii\"},\"combination-sum\":{\"title\":\"Combination Sum\",\"description\":\"The test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input.\",\"tags\":[\"medium\",\"backtracking\"],\"link\":\"https://leetcode.com/problems/combination-sum/\",\"images\":[],\"preview\":\"### Description\\r\\n\\r\\nGiven an array of **distinct** integers candidates and a target integer target, return a list of all **unique combinations** of candidates where the chosen numbers sum to target. You may return the combinations in **any order**.\\r\\n\\r\\nThe **same** number may be chosen from candidates an **unlimited number of times**. Two combinations are unique if the frequency of at least one of the chosen numbers is different.\\r\\n\\r\\nThe test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input.\\r\\n\\r\\n \\r\\n\\r\\n### Example 1\\r\\n\\r\\n```bash\\r\\nInput: candidates = [2,3,6,7], target = 7\\r\\nOutput: [[2,2,3],[7]]\\r\\nExplanation:\\r\\n2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\\r\\n7 is a candidate, and 7 = 7.\\r\\nThese are the only two combinations.\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n\\r\\n```bash\\r\\nInput: candidates = [2,3,5], target = 8\\r\\nOutput: [[2,2,2,2],[2,3,3],[3,5]]\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n- 1 <= candidates.length <= 30\\r\\n- 2 <= candidates[i] <= 40\\r\\n- All elements of candidates are distinct.\\r\\n- 1 <= target <= 40\",\"basename\":\"combination-sum\"},\"construct-binary-tree-from-preorder-and-inorder-traversal\":{\"title\":\"Construct Binary Tree from Preorder and Inorder Traversal\",\"description\":\"Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.\",\"tags\":[\"medium\",\"binary-tree\"],\"link\":\"https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/\",\"images\":[\"https://assets.leetcode.com/uploads/2021/02/19/tree.jpg\"],\"preview\":\"### Description\\r\\n\\r\\nGiven two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.\\r\\n\\r\\n### Example 1\\r\\n\\r\\n![](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg)\\r\\n\\r\\n```bash\\r\\nInput: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]\\r\\nOutput: [3,9,20,null,null,15,7]\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n\\r\\n```bash\\r\\nInput: preorder = [-1], inorder = [-1]\\r\\nOutput: [-1]\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n- 1 <= preorder.length <= 3000 \\r\\n- inorder.length == preorder.length\\r\\n- -3000 <= preorder[i], inorder[i] <= 3000 \\r\\n- preorder and inorder consist of unique values. \\r\\n- Each value of inorder also appears in preorder. \\r\\n- preorder is guaranteed to be the preorder traversal of the tree. \\r\\n- inorder is guaranteed to be the inorder traversal of the tree.\",\"basename\":\"construct-binary-tree-from-preorder-and-inorder-traversal\"},\"container-with-most-water\":{\"title\":\"Container With Most Water\",\"description\":\"A container with most water example\",\"tags\":[\"two-pointers\",\"medium\"],\"images\":[\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg\"],\"preview\":\"## Container With Most Water\\r\\n\\r\\nYou are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\\r\\n\\r\\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\\r\\n\\r\\nReturn the maximum amount of water a container can store.\\r\\n\\r\\nNotice that you may not slant the container.\\r\\n\\r\\n![](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg)\\r\\n\\r\\n\\r\\n```\\r\\nInput: height = [1,8,6,2,5,4,8,3,7]\\r\\nOutput: 49\\r\\nExplanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\\r\\n```\\r\\n\\r\\n\\r\\n### Example 2\\r\\n\\r\\n```\\r\\nInput: height = [1,1]\\r\\nOutput: 1\\r\\n```\",\"basename\":\"container-with-most-water\"},\"copy-list-with-random-pointer\":{\"title\":\"Copy List with Random Pointer\",\"description\":\"A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null.\",\"tags\":[\"medium\",\"linked-list\"],\"link\":\"https://leetcode.com/problems/copy-list-with-random-pointer/\",\"images\":[\"https://assets.leetcode.com/uploads/2019/12/18/e1.png\",\"https://assets.leetcode.com/uploads/2019/12/18/e2.png\",\"https://assets.leetcode.com/uploads/2019/12/18/e3.png\"],\"preview\":\"### Description\\r\\n\\r\\nA linked list of length `n` is given such that each node contains an additional random pointer, which could point to any node in the list, or `null`.\\r\\n\\r\\nConstruct a deep copy of the list. The deep copy should consist of exactly n **brand new **nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. **None of the pointers in the new list should point to nodes in the original list.**\\r\\n\\r\\nFor example, if there are two nodes X and Y in the original list, where X.random --> Y, then for the corresponding two nodes x and y in the copied list, x.random --> y.\\r\\n\\r\\nReturn the head of the copied linked list.\\r\\n\\r\\nThe linked list is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where:\\r\\n\\r\\n- `val`: an integer representing `Node.val`\\r\\n- `random_index`: the index of the node (range from `0` to `n-1`) that the `random pointer` points to, or null if it does not point to any node.\\r\\n\\r\\nYour code will **only** be given the head of the original linked list.\\r\\n\\r\\n### Example 1\\r\\n\\r\\n![](https://assets.leetcode.com/uploads/2019/12/18/e1.png)\\r\\n\\r\\n```bash\\r\\nInput: head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\\r\\nOutput: [[7,null],[13,0],[11,4],[10,2],[1,0]]\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n\\r\\n![](https://assets.leetcode.com/uploads/2019/12/18/e2.png)\\r\\n\\r\\n\\r\\n```bash\\r\\nInput: head = [[1,1],[2,1]]\\r\\nOutput: [[1,1],[2,1]]\\r\\n```\\r\\n\\r\\n### Example 3\\r\\n\\r\\n![](https://assets.leetcode.com/uploads/2019/12/18/e3.png)\\r\\n\\r\\n```bash\\r\\nInput: head = [[3,null],[3,0],[3,null]]\\r\\nOutput: [[3,null],[3,0],[3,null]]\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n- 0 <= n <= 1000\\r\\n- -104 <= Node.val <= 104\\r\\n- Node.random is null or is pointing to some node in the linked list.\",\"basename\":\"copy-list-with-random-pointer\"},\"count-good-nodes-in-binary-tree\":{\"title\":\"Count Good Nodes in Binary Tree\",\"description\":\"Given a binary tree root, a node X in the tree is named good if in the path from root to X there are no nodes with a value greater than X.\",\"tags\":[\"medium\",\"binary-tree\"],\"link\":\"https://leetcode.com/problems/count-good-nodes-in-binary-tree/\",\"images\":[\"https://assets.leetcode.com/uploads/2020/04/02/test_sample_1.png\",\"https://assets.leetcode.com/uploads/2020/04/02/test_sample_2.png\"],\"preview\":\"### Description\\r\\n\\r\\nGiven a binary tree root, a node X in the tree is named good if in the path from root to X there are no nodes with a value greater than X.\\r\\n\\r\\nReturn the number of **good** nodes in the binary tree.\\r\\n\\r\\n \\r\\n\\r\\n### Example 1\\r\\n\\r\\n![](https://assets.leetcode.com/uploads/2020/04/02/test_sample_1.png)\\r\\n\\r\\n```bash\\r\\nInput: root = [3,1,4,3,null,1,5]\\r\\nOutput: 4\\r\\n\\r\\n\\r\\nExplanation: Nodes in blue are good.\\r\\nRoot Node (3) is always a good node.\\r\\nNode 4 -> (3,4) is the maximum value in the path starting from the root.\\r\\nNode 5 -> (3,4,5) is the maximum value in the path\\r\\nNode 3 -> (3,1,3) is the maximum value in the path.\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n\\r\\n![](https://assets.leetcode.com/uploads/2020/04/02/test_sample_2.png)\\r\\n\\r\\n```bash\\r\\n\\r\\n```bash\\r\\nInput: root = [3,3,null,4,2]\\r\\nOutput: 3\\r\\nExplanation: Node 2 -> (3, 3, 2) is not good, because \\\"3\\\" is higher than it.\\r\\n```\\r\\n\\r\\n### Example 3\\r\\n\\r\\n```bash\\r\\nInput: root = [1]\\r\\nOutput: 1\\r\\nExplanation: Root is considered as good.\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n- The number of nodes in the binary tree is in the range [1, 10^5]. \\r\\n- Each node's value is between [-10^4, 10^4].\",\"basename\":\"count-good-nodes-in-binary-tree\"},\"course-schedule-ii\":{\"title\":\"Course Schedule II\",\"description\":\"Return the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.\",\"tags\":[\"medium\",\"graph\",\"topological-sort\"],\"link\":\"https://leetcode.com/problems/course-schedule-ii/\",\"images\":[],\"preview\":\"### Description\\r\\n\\r\\nThere are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where `prerequisites[i] = [ai, bi]` indicates that you must take course bi first if you want to take course ai.\\r\\n\\r\\nFor example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\\r\\nReturn the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return **an empty array**.\\r\\n\\r\\n### Example 1\\r\\n\\r\\n```bash\\r\\nInput: numCourses = 2, prerequisites = [[1,0]]\\r\\nOutput: [0,1]\\r\\nExplanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n\\r\\n```bash\\r\\nInput: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]\\r\\nOutput: [0,2,1,3]\\r\\nExplanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.\\r\\nSo one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].\\r\\n```\\r\\n\\r\\n### Example 3\\r\\n\\r\\n```bash\\r\\nInput: numCourses = 1, prerequisites = []\\r\\nOutput: [0]\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n- 1 <= numCourses <= 2000 \\r\\n- 0 <= prerequisites.length <= numCourses * (numCourses - 1)\\r\\n- prerequisites[i].length == 2 \\r\\n- 0 <= ai, bi < numCourses \\r\\n- ai != bi \\r\\n- All the pairs [ai, bi] are distinct.\",\"basename\":\"course-schedule-ii\"},\"course-schedule\":{\"title\":\"Course Schedule\",\"description\":\"Return true if you can finish all courses. Otherwise, return false.\",\"tags\":[\"medium\",\"graph\",\"topological-sort\"],\"link\":\"https://leetcode.com/problems/course-schedule/\",\"images\":[],\"preview\":\"### Description\\r\\n\\r\\nThere are a total of `numCourses` courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where `prerequisites[i] = [ai, bi]` indicates that you **must** take course bi first if you want to take course ai.\\r\\n\\r\\nFor example, the pair `[0, 1]`, indicates that to take course 0 you have to first take course 1.\\r\\nReturn true if you can finish all courses. Otherwise, return `false`.\\r\\n\\r\\n### Example 1\\r\\n\\r\\n```bash\\r\\nInput: numCourses = 2, prerequisites = [[1,0]]\\r\\nOutput: true\\r\\nExplanation: There are a total of 2 courses to take. \\r\\nTo take course 1 you should have finished course 0. So it is possible.\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n\\r\\n```bash\\r\\nInput: numCourses = 2, prerequisites = [[1,0],[0,1]]\\r\\nOutput: false\\r\\nExplanation: There are a total of 2 courses to take. \\r\\nTo take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n- 1 <= numCourses <= 2000 \\r\\n- 0 <= prerequisites.length <= 5000 \\r\\n- prerequisites[i].length == 2 \\r\\n- 0 <= ai, bi < numCourses \\r\\n- All the pairs prerequisites[i] are unique.\",\"basename\":\"course-schedule\"},\"daily-temperatures\":{\"title\":\"Daily Temperatures\",\"description\":\"Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.\",\"tags\":[\"medium\",\"stack\",\"sliding-window\"],\"link\":\"https://leetcode.com/problems/daily-temperatures/\",\"images\":[],\"preview\":\"### Description\\r\\n\\r\\nGiven an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.\\r\\n\\r\\n### Example 1\\r\\n\\r\\n```bash\\r\\nInput: temperatures = [73,74,75,71,69,72,76,73]\\r\\nOutput: [1,1,4,2,1,1,0,0]\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n\\r\\n```bash\\r\\nInput: temperatures = [30,40,50,60]\\r\\nOutput: [1,1,1,0]\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n-     1 <= temperatures.length <= 105\\r\\n-     30 <= temperatures[i] <= 100\",\"basename\":\"daily-temperatures\"},\"design-add-and-search-words-data-structure\":{\"title\":\"Design Add and Search Words Data Structure\",\"description\":\"Design a data structure that supports adding new words and finding if a string matches any previously added string.\",\"tags\":[\"medium\",\"trie\"],\"link\":\"https://leetcode.com/problems/design-add-and-search-words-data-structure/\",\"images\":[],\"preview\":\"### Description\\r\\n\\r\\nDesign a data structure that supports adding new words and finding if a string matches any previously added string.\\r\\n\\r\\nImplement the `WordDictionary` class:\\r\\n\\r\\n- WordDictionary() Initializes the object.\\r\\n- void addWord(word) Adds word to the data structure, it can be matched later.\\r\\n- bool search(word) Returns true if there is any string in the data structure that matches word or false otherwise. word may contain dots '.' where dots can be matched with any letter.\\r\\n\\r\\n### Example 1\\r\\n\\r\\n```bash\\r\\nInput\\r\\n[\\\"WordDictionary\\\",\\\"addWord\\\",\\\"addWord\\\",\\\"addWord\\\",\\\"search\\\",\\\"search\\\",\\\"search\\\",\\\"search\\\"]\\r\\n[[],[\\\"bad\\\"],[\\\"dad\\\"],[\\\"mad\\\"],[\\\"pad\\\"],[\\\"bad\\\"],[\\\".ad\\\"],[\\\"b..\\\"]]\\r\\nOutput\\r\\n[null,null,null,null,false,true,true,true]\\r\\n\\r\\nExplanation\\r\\nWordDictionary wordDictionary = new WordDictionary();\\r\\nwordDictionary.addWord(\\\"bad\\\");\\r\\nwordDictionary.addWord(\\\"dad\\\");\\r\\nwordDictionary.addWord(\\\"mad\\\");\\r\\nwordDictionary.search(\\\"pad\\\"); // return False\\r\\nwordDictionary.search(\\\"bad\\\"); // return True\\r\\nwordDictionary.search(\\\".ad\\\"); // return True\\r\\nwordDictionary.search(\\\"b..\\\"); // return True\\r\\n```\\r\\n\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n- 1 <= word.length <= 25\\r\\n- word in addWord consists of lowercase English letters.\\r\\n- word in search consist of '.' or lowercase English letters.\\r\\n- There will be at most 3 dots in word for search queries.\\r\\n- At most 104 calls will be made to addWord and search.\",\"basename\":\"design-add-and-search-words-data-structure\"},\"design-twitter\":{\"title\":\"Design Twitter\",\"description\":\"https://leetcode.com/problems/design-twitter/\",\"tags\":[\"medium\",\"heap\"],\"link\":\"https://leetcode.com/problems/design-twitter/\",\"images\":[],\"preview\":\"### Description\\r\\n\\r\\nDesign a simplified version of Twitter where users can post tweets, follow/unfollow another user, and is able to see the 10 most recent tweets in the user's news feed.\\r\\n\\r\\nImplement the `Twitter` class:\\r\\n\\r\\n- Twitter() Initializes your twitter object.\\r\\n- void postTweet(int userId, int tweetId) Composes a new tweet with ID tweetId by the user userId. Each call to this function will be made with a unique tweetId.\\r\\n- List<Integer> getNewsFeed(int userId) Retrieves the 10 most recent tweet IDs in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user themself. Tweets must be ordered from most recent to least recent.\\r\\n- void follow(int followerId, int followeeId) The user with ID followerId started following the user with ID followeeId.\\r\\n- void unfollow(int followerId, int followeeId) The user with ID followerId started unfollowing the user with ID followeeId.\\r\\n\\r\\n### Example 1\\r\\n\\r\\n```bash\\r\\nInput\\r\\n[\\\"Twitter\\\", \\\"postTweet\\\", \\\"getNewsFeed\\\", \\\"follow\\\", \\\"postTweet\\\", \\\"getNewsFeed\\\", \\\"unfollow\\\", \\\"getNewsFeed\\\"]\\r\\n[[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]\\r\\nOutput\\r\\n[null, null, [5], null, null, [6, 5], null, [5]]\\r\\n\\r\\nExplanation\\r\\nTwitter twitter = new Twitter();\\r\\ntwitter.postTweet(1, 5); // User 1 posts a new tweet (id = 5).\\r\\ntwitter.getNewsFeed(1);  // User 1's news feed should return a list with 1 tweet id -> [5]. return [5]\\r\\ntwitter.follow(1, 2);    // User 1 follows user 2.\\r\\ntwitter.postTweet(2, 6); // User 2 posts a new tweet (id = 6).\\r\\ntwitter.getNewsFeed(1);  // User 1's news feed should return a list with 2 tweet ids -> [6, 5]. Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.\\r\\ntwitter.unfollow(1, 2);  // User 1 unfollows user 2.\\r\\ntwitter.getNewsFeed(1);  // User 1's news feed should return a list with 1 tweet id -> [5], since user 1 is no longer following user 2.\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n\\r\\n```bash\\r\\n\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n- 1 <= userId, followerId, followeeId <= 500\\r\\n- 0 <= tweetId <= 10^4\\r\\n- All the tweets have unique IDs.\\r\\n- At most 3 * 10^4 calls will be made to postTweet, getNewsFeed, follow, and unfollow.\",\"basename\":\"design-twitter\"},\"diameter-of-binary-tree\":{\"title\":\"Diameter of Binary Tree\",\"description\":\"Given the root of a binary tree, return the length of the diameter of the tree.\",\"tags\":[\"easy\",\"binary-tree\"],\"link\":\"https://leetcode.com/problems/diameter-of-binary-tree/\",\"images\":[\"https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg\"],\"preview\":\"### Description\\r\\n\\r\\nGiven the `root` of a binary tree, return the **length** of the diameter of the tree.\\r\\n\\r\\nThe **diameter** of a binary tree is the **length** of the longest path between any two nodes in a tree. This path may or may not pass through the root.\\r\\n\\r\\nThe **length** of a path between two nodes is represented by the number of edges between them.\\r\\n\\r\\n### Example 1\\r\\n\\r\\n![](https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg)\\r\\n\\r\\n```bash\\r\\nInput: root = [1,2,3,4,5]\\r\\nOutput: 3\\r\\nExplanation: 3 is the length of the path [4,2,1,3] or [5,2,1,3].\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n\\r\\n```bash\\r\\nInput: root = [1,2]\\r\\nOutput: 1\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n- The number of nodes in the tree is in the range [1, 104]. \\r\\n- -100 <= Node.val <= 100\",\"basename\":\"diameter-of-binary-tree\"},\"evaluate-polish-reverse-notation\":{\"title\":\"Evaluate Reverse Polish Notation\",\"description\":\"You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation.  Evaluate the expression. Return an integer that represents the value of the expression.\",\"tags\":[\"medium\",\"stack\"],\"link\":\"https://leetcode.com/problems/evaluate-reverse-polish-notation/\",\"preview\":\"### Description\\r\\n\\r\\nYou are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation.\\r\\n\\r\\nEvaluate the expression. Return an integer that represents the value of the expression.\\r\\n\\r\\nNote that:\\r\\n\\r\\n    The valid operators are '+', '-', '*', and '/'.\\r\\n    Each operand may be an integer or another expression.\\r\\n    The division between two integers always truncates toward zero.\\r\\n    There will not be any division by zero.\\r\\n    The input represents a valid arithmetic expression in a reverse polish notation.\\r\\n    The answer and all the intermediate calculations can be represented in a 32-bit integer.\\r\\n\\r\\n\\r\\n### Example 1\\r\\n\\r\\n```bash\\r\\nInput: tokens = [\\\"2\\\",\\\"1\\\",\\\"+\\\",\\\"3\\\",\\\"*\\\"]\\r\\nOutput: 9\\r\\nExplanation: ((2 + 1) * 3) = 9\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n\\r\\n```bash\\r\\nInput: tokens = [\\\"4\\\",\\\"13\\\",\\\"5\\\",\\\"/\\\",\\\"+\\\"]\\r\\nOutput: 6\\r\\nExplanation: (4 + (13 / 5)) = 6\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n- 1 <= tokens.length <= 104\\r\\n- tokens[i] is either an operator: \\\"+\\\", \\\"-\\\", \\\"*\\\", or \\\"/\\\", or an integer in the range [-200, 200].\",\"basename\":\"evaluate-polish-reverse-notation\"},\"find-median-from-data-stream\":{\"title\":\"Find Median from Data Stream\",\"description\":\"The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.\",\"tags\":[\"hard\",\"heap\"],\"link\":\"https://leetcode.com/problems/find-median-from-data-stream/\",\"images\":[],\"preview\":\"### Description\\r\\n\\r\\nThe **median** is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.\\r\\n\\r\\n- For example, for arr = [2,3,4], the median is 3.\\r\\n- For example, for arr = [2,3], the median is (2 + 3) / 2 = 2.5.\\r\\n\\r\\nImplement the MedianFinder class:\\r\\n\\r\\n- MedianFinder() initializes the MedianFinder object.\\r\\n- void addNum(int num) adds the integer num from the data stream to the data structure.\\r\\n- double findMedian() returns the median of all elements so far. Answers within 10-5 of the actual answer will be accepted.\\r\\n\\r\\n### Example 1\\r\\n\\r\\n```bash\\r\\nInput\\r\\n[\\\"MedianFinder\\\", \\\"addNum\\\", \\\"addNum\\\", \\\"findMedian\\\", \\\"addNum\\\", \\\"findMedian\\\"]\\r\\n[[], [1], [2], [], [3], []]\\r\\nOutput\\r\\n[null, null, null, 1.5, null, 2.0]\\r\\n\\r\\nExplanation\\r\\nMedianFinder medianFinder = new MedianFinder();\\r\\nmedianFinder.addNum(1);    // arr = [1]\\r\\nmedianFinder.addNum(2);    // arr = [1, 2]\\r\\nmedianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2)\\r\\nmedianFinder.addNum(3);    // arr[1, 2, 3]\\r\\nmedianFinder.findMedian(); // return 2.0\\r\\n```\\r\\n\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n- -10^5 <= num <= 10^5 \\r\\n- There will be at least one element in the data structure before calling findMedian. \\r\\n- At most 5 * 10^4 calls will be made to addNum and findMedian.\\r\\n\\r\\n\\r\\n### Follow up:\\r\\n\\r\\n- If all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?\\r\\n- If 99% of all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?\",\"basename\":\"find-median-from-data-stream\"},\"find-min\":{\"title\":\"Find Minimum in Rotated Sorted Array\",\"description\":\"Given the sorted rotated array nums of unique elements, return the minimum element of this array.\",\"tags\":[\"medium\",\"binary-search\"],\"link\":\"https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/\",\"preview\":\"### Description\\r\\n\\r\\nSuppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:\\r\\n\\r\\n    `[4,5,6,7,0,1,2]` if it was rotated 4 times.\\r\\n    `[0,1,2,4,5,6,7]` if it was rotated 7 times.\\r\\n\\r\\nNotice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].\\r\\n\\r\\nGiven the sorted rotated array nums of unique elements, return the minimum element of this array.\\r\\n\\r\\nYou must write an algorithm that runs in O(log n) time.\\r\\n\\r\\n### Example 1\\r\\n\\r\\n```bash\\r\\nInput: nums = [3,4,5,1,2]\\r\\nOutput: 1\\r\\nExplanation: The original array was [1,2,3,4,5] rotated 3 times.\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n\\r\\n```bash\\r\\nInput: nums = [4,5,6,7,0,1,2]\\r\\nOutput: 0\\r\\nExplanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n-      n == nums.length     \\r\\n-      1 <= n <= 5000     \\r\\n-      -5000 <= nums[i] <= 5000     \\r\\n-      All the integers of nums are unique.     \\r\\n-      nums is sorted and rotated between 1 and n times.\",\"basename\":\"find-min\"},\"find-the-duplicate-number\":{\"title\":\"Find the Duplicate Number\",\"description\":\"Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.\",\"tags\":[\"medium\",\"linked-list\"],\"link\":\"https://leetcode.com/problems/find-the-duplicate-number/\",\"preview\":\"### Description\\r\\n\\r\\nGiven an array of integers nums containing `n + 1` integers where each integer is in the range `[1, n]` inclusive.\\r\\n\\r\\nThere is only **one repeated number** in nums, return this repeated number.\\r\\n\\r\\nYou must solve the problem **without** modifying the array nums and uses only constant extra space.\\r\\n\\r\\n### Example 1\\r\\n\\r\\n```bash\\r\\nInput: nums = [1,3,4,2,2]\\r\\nOutput: 2\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n\\r\\n```bash\\r\\nInput: nums = [3,1,3,4,2]\\r\\nOutput: 3\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n- 1 <= n <= 10^5 \\r\\n- nums.length == n + 1 \\r\\n- 1 <= nums[i] <= n \\r\\n- All the integers in nums appear only **once** except for **precisely one** **integer** which appears **two or more** times.\",\"basename\":\"find-the-duplicate-number\"},\"generate-parenthesis\":{\"title\":\"Generate Parentheses\",\"description\":\"Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\",\"tags\":[\"medium\",\"stack\",\"backtracking\"],\"link\":null,\"preview\":\"### Description\\r\\n\\r\\nGiven n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\\r\\n\\r\\n### Example 1\\r\\n\\r\\n```bash\\r\\nInput: n = 3\\r\\nOutput: [\\\"((()))\\\",\\\"(()())\\\",\\\"(())()\\\",\\\"()(())\\\",\\\"()()()\\\"]\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n\\r\\n```bash\\r\\nInput: n = 1\\r\\nOutput: [\\\"()\\\"]\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n- 1 <= n <= 8\",\"basename\":\"generate-parenthesis\"},\"hello-world\":{\"title\":\"Hello World\",\"description\":\"A simple hello world example\",\"tags\":[\"sample\"],\"preview\":\"This is  a simple hello world example.\\r\\n\\r\\n```bash\\r\\n$ dsa run hello-world.js\\r\\n```\",\"basename\":\"hello-world\"},\"implement-trie-prefix-tree\":{\"title\":\"Trie\",\"description\":\"A trie (pronounced as \\\"try\\\") or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.\",\"tags\":[\"medium\",\"trie\"],\"link\":\"https://leetcode.com/problems/implement-trie-prefix-tree/\",\"images\":[],\"preview\":\"### Description\\r\\n\\r\\nA trie (pronounced as \\\"try\\\") or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.\\r\\n\\r\\nImplement the Trie class:\\r\\n\\r\\n- Trie() Initializes the trie object.\\r\\n- void insert(String word) Inserts the string word into the trie.\\r\\n- boolean search(String word) Returns true if the string word is in the trie (i.e., was inserted before), and false otherwise.\\r\\n- boolean startsWith(String prefix) Returns true if there is a previously nserted string word that has the prefix prefix, and false otherwise.\\r\\n\\r\\n### Example 1\\r\\n\\r\\n```bash\\r\\nInput\\r\\n[\\\"Trie\\\", \\\"insert\\\", \\\"search\\\", \\\"search\\\", \\\"startsWith\\\", \\\"insert\\\", \\\"search\\\"]\\r\\n[[], [\\\"apple\\\"], [\\\"apple\\\"], [\\\"app\\\"], [\\\"app\\\"], [\\\"app\\\"], [\\\"app\\\"]]\\r\\nOutput\\r\\n[null, null, true, false, true, null, true]\\r\\n\\r\\nExplanation\\r\\nTrie trie = new Trie();\\r\\ntrie.insert(\\\"apple\\\");\\r\\ntrie.search(\\\"apple\\\");   // return True\\r\\ntrie.search(\\\"app\\\");     // return False\\r\\ntrie.startsWith(\\\"app\\\"); // return True\\r\\ntrie.insert(\\\"app\\\");\\r\\ntrie.search(\\\"app\\\");     // return True\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n- 1 <= word.length, prefix.length <= 2000 \\r\\n- word and prefix consist only of lowercase English letters. \\r\\n- At most 3 * 104 calls in total will be made to insert, search, and startsWith.\",\"basename\":\"implement-trie-prefix-tree\"},\"index\":{\"preview\":\"const { getFilesInDirectory, getDirAbsoluteUri } = require('../functions');\\r\\nconst md2json = require('markdown-to-json');\\r\\nconst fs = require('fs');\\r\\n\\r\\nconst DEBUG = false;\\r\\nconst PROMPT_FILE = 'prompt.json';\\r\\n\\r\\nconst options = {\\r\\n    minify: false,\\r\\n    width: DEBUG ? 0 : 9000000,\\r\\n    outfile: null,\\r\\n};\\r\\n\\r\\n\\r\\n/**\\r\\n * Creates a compiled json file from all the markdown files in the prompt directory\\r\\n */\\r\\nconst createCompiledJson = () => {\\r\\n    let parsed_prompt_dict = {};\\r\\n\\r\\n    getFilesInDirectory('./prompt/')\\r\\n        .then((files) => {\\r\\n            const absolutePathForFiles = files.map((file) => {\\r\\n                return getDirAbsoluteUri(file, './prompt/');\\r\\n            });\\r\\n            if (DEBUG) console.log(\\\"absolutePathForFiles: \\\", absolutePathForFiles);\\r\\n            const promptsData = md2json.parse(absolutePathForFiles, options);\\r\\n            if (DEBUG) console.log(promptsData);\\r\\n            parsed_prompt_dict = JSON.parse(promptsData);\\r\\n            // Object.values(parsed_prompt_dict).map((prompt) => {\\r\\n\\r\\n            //     prompt.preview\\r\\n            // });\\r\\n            // console.log(\\\"promptsData: \\\", parsed_prompt_dict);\\r\\n\\r\\n\\r\\n\\r\\n            // Save as a json\\r\\n            const json = JSON.stringify(parsed_prompt_dict);\\r\\n            const prompt_file_path = getDirAbsoluteUri(PROMPT_FILE, './prompt/');\\r\\n            fs.writeFile(prompt_file_path, json, (err) => {\\r\\n                if (err) throw err;\\r\\n                console.log('The file has been saved!');\\r\\n            });\\r\\n        })\\r\\n        .catch((error) => {\\r\\n            console.error(error);\\r\\n        });\\r\\n};\\r\\n\\r\\n\\r\\nconst getLatestModified = async () => {\\r\\n    const files = await getFilesInDirectory('./prompt/');\\r\\n    let latestModified = null;\\r\\n    let latestFile = null;\\r\\n\\r\\n    const absolutePathForFiles = files.map((file) => {\\r\\n        return getDirAbsoluteUri(file, './prompt/');\\r\\n    });\\r\\n    for (const file of absolutePathForFiles) {\\r\\n        const stats = await fs.promises.stat(file);\\r\\n        if (!latestModified || stats.mtime > latestModified) {\\r\\n            latestModified = stats.mtime;\\r\\n            latestFile = file;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    return latestFile;\\r\\n};\\r\\n\\r\\n/**\\r\\n * Checks if prompt.json exists, if not, creates it, then returns the parsed json\\r\\n * @param {String} prompt_slug - The slug of the prompt to return, if empty, returns all prompts\\r\\n * @returns {Object} parsed_prompt_dict\\r\\n */\\r\\nconst getPromptDict = async (prompt_slug = \\\"\\\") => {\\r\\n    // check if prompt.json exists\\r\\n    const prompt_file_path = getDirAbsoluteUri(PROMPT_FILE, './prompt/');\\r\\n    if (!fs.existsSync(prompt_file_path)) {\\r\\n        createCompiledJson();\\r\\n    }\\r\\n\\r\\n    // If exists, check if it's the latest modified file, if not, update the prompt.json\\r\\n    const latestModified = await getLatestModified();\\r\\n\\r\\n    let parsed_prompt_dict;\\r\\n    if (latestModified !== prompt_file_path) {\\r\\n        console.log(\\\"latestModified: \\\", latestModified);\\r\\n        createCompiledJson();\\r\\n    }\\r\\n    try {\\r\\n        parsed_prompt_dict = require(prompt_file_path);\\r\\n    }\\r\\n    catch (e) {\\r\\n        // Delete the prompt.json file and try again\\r\\n        fs.unlinkSync(prompt_file_path);\\r\\n        // If it fails this time exit and print\\r\\n        try{\\r\\n            parsed_prompt_dict = require(prompt_file_path);\\r\\n        \\r\\n        }\\r\\n        catch (e) {\\r\\n            console.error(\\\"Error: \\\", e);\\r\\n            process.exit(1);\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n    if (prompt_slug === \\\"\\\") {\\r\\n        return parsed_prompt_dict;\\r\\n    }\\r\\n    return parsed_prompt_dict[prompt_slug];\\r\\n};\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n(async () => {\\r\\n    const sample = await getPromptDict();\\r\\n    if (DEBUG) console.log(\\\"sample: \\\", sample);\\r\\n}\\r\\n)();\\r\\n\\r\\nmodule.exports = { getPromptDict, createCompiledJson };\\r\\n\\r\\n\\r\\n// const parsed_prompt_dict = require(PROMPT_FILE);\\r\\n// module.exports = parsed_prompt_dict;\",\"basename\":\"index\"},\"invert-binary-tree\":{\"title\":\"Invert Binary Tree\",\"description\":\"Given the `root` of a binary tree, invert the tree, and return its root.\",\"tags\":[\"easy\",\"binary-tree\"],\"link\":\"https://leetcode.com/problems/invert-binary-tree/\",\"images\":[\"https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg\",\"https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg\"],\"preview\":\"### Description\\r\\n\\r\\nGiven the root of a binary tree, invert the tree, and return its root.\\r\\n\\r\\n### Example 1\\r\\n\\r\\n![](https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg)\\r\\n\\r\\n```bash\\r\\nInput: root = [4,2,7,1,3,6,9]\\r\\nOutput: [4,7,2,9,6,3,1]\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n\\r\\n![](https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg)\\r\\n\\r\\n```bash\\r\\nInput: root = [2,1,3]\\r\\nOutput: [2,3,1]\\r\\n```\\r\\n\\r\\n### Example 3\\r\\n\\r\\n```bash\\r\\nInput: root = []\\r\\nOutput: []\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n- The number of nodes in the tree is in the range [0, 100]. \\r\\n- -100 <= Node.val <= 100\",\"basename\":\"invert-binary-tree\"},\"k-closest\":{\"title\":\"k closest points to origin\",\"description\":\"Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane and an integer k, return the k closest points to the origin (0, 0).\",\"tags\":[\"medium\",\"heap\"],\"link\":\"https://leetcode.com/problems/k-closest-points-to-origin/\",\"images\":[\"https://assets.leetcode.com/uploads/2021/03/03/closestplane1.jpg\"],\"preview\":\"### Description\\r\\n\\r\\nGiven an array of points where `points[i] = [xi, yi]` represents a point on the **X-Y** plane and an integer k, return the k closest points to the origin (0, 0).\\r\\n\\r\\nThe distance between two points on the X-Y plane is the Euclidean distance (i.e., âˆš(x1 - x2)2 + (y1 - y2)2).\\r\\n\\r\\nYou may return the answer in **any order**. The answer is **guaranteed** to be **unique** (except for the order that it is in).\\r\\n\\r\\n### Example 1\\r\\n\\r\\n![](https://assets.leetcode.com/uploads/2021/03/03/closestplane1.jpg)\\r\\n\\r\\n```bash\\r\\nInput: points = [[1,3],[-2,2]], k = 1\\r\\nOutput: [[-2,2]]\\r\\nExplanation:\\r\\nThe distance between (1, 3) and the origin is sqrt(10).\\r\\nThe distance between (-2, 2) and the origin is sqrt(8).\\r\\nSince sqrt(8) < sqrt(10), (-2, 2) is closer to the origin.\\r\\nWe only want the closest k = 1 points from the origin, so the answer is just [[-2,2]].\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n\\r\\n```bash\\r\\nInput: points = [[3,3],[5,-1],[-2,4]], k = 2\\r\\nOutput: [[3,3],[-2,4]]\\r\\nExplanation: The answer [[-2,4],[3,3]] would also be accepted.\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n- 1 <= k <= points.length <= 104\\r\\n- -104 < xi, yi < 104\",\"basename\":\"k-closest\"},\"key-based-value-store\":{\"title\":\"Time Based Key-value Store\",\"description\":\"Design a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the key's value at a certain timestamp.\",\"tags\":[\"medium\",\"binary-search\"],\"link\":\"https://leetcode.com/problems/time-based-key-value-store/\",\"preview\":\"### Description\\r\\n\\r\\nDesign a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the key's value at a certain timestamp.\\r\\n\\r\\nImplement the TimeMap class:\\r\\n\\r\\n- `TimeMap()` Initializes the object of the data structure\\r\\n- `void set(String key, String value, int timestamp)` Stores the key `key` with the value `value` at the given time timestamp.\\r\\n- `String get(String key, int timestamp)` Returns a value such that set was called previously, with `timestamp_prev <= timestamp`. If there are multiple such values, it returns the value associated with the largest `timestamp_prev`. If there are no values, it returns `\\\"\\\"`.\\r\\n\\r\\n\\r\\n### Example 1\\r\\n\\r\\n```bash\\r\\nInput\\r\\n[\\\"TimeMap\\\", \\\"set\\\", \\\"get\\\", \\\"get\\\", \\\"set\\\", \\\"get\\\", \\\"get\\\"]\\r\\n[[], [\\\"foo\\\", \\\"bar\\\", 1], [\\\"foo\\\", 1], [\\\"foo\\\", 3], [\\\"foo\\\", \\\"bar2\\\", 4], [\\\"foo\\\", 4], [\\\"foo\\\", 5]]\\r\\nOutput\\r\\n[null, null, \\\"bar\\\", \\\"bar\\\", null, \\\"bar2\\\", \\\"bar2\\\"]\\r\\n\\r\\nExplanation\\r\\nTimeMap timeMap = new TimeMap();\\r\\ntimeMap.set(\\\"foo\\\", \\\"bar\\\", 1);  // store the key \\\"foo\\\" and value \\\"bar\\\" along with timestamp = 1.\\r\\ntimeMap.get(\\\"foo\\\", 1);         // return \\\"bar\\\"\\r\\ntimeMap.get(\\\"foo\\\", 3);         // return \\\"bar\\\", since there is no value corresponding to foo at timestamp 3 and timestamp 2, then the only value is at timestamp 1 is \\\"bar\\\".\\r\\ntimeMap.set(\\\"foo\\\", \\\"bar2\\\", 4); // store the key \\\"foo\\\" and value \\\"bar2\\\" along with timestamp = 4.\\r\\ntimeMap.get(\\\"foo\\\", 4);         // return \\\"bar2\\\"\\r\\ntimeMap.get(\\\"foo\\\", 5);         // return \\\"bar2\\\"\\r\\n```\\r\\n\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n-      1 <= key.length, value.length <= 100     \\r\\n-      key and value consist of lowercase English letters and digits.     \\r\\n-      1 <= timestamp <= 107     \\r\\n-      All the timestamps timestamp of set are strictly increasing.     \\r\\n-      At most 2 * 105 calls will be made to set and get.\",\"basename\":\"key-based-value-store\"},\"koko-eating-bananas\":{\"title\":\"koko-eating-bananas\",\"description\":\"Return the minimum integer k such that she can eat all the bananas within h hours.\",\"tags\":[\"medium\",\"binary-search\"],\"link\":\"https://leetcode.com/problems/koko-eating-bananas/\",\"preview\":\"### Description\\r\\n\\r\\nKoko loves to eat bananas. There are `n` piles of bananas, the ith pile has `piles[i]` bananas. The guards have gone and will come back in `h` hours.\\r\\n\\r\\nKoko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.\\r\\n\\r\\nKoko likes to eat slowly but still wants to finish eating all the bananas before the guards return.\\r\\n\\r\\nReturn the minimum integer `k` such that she can eat all the bananas within `h` hours.\\r\\n\\r\\n### Example 1\\r\\n\\r\\n```bash\\r\\nInput: piles = [3,6,7,11], h = 8\\r\\nOutput: 4\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n\\r\\n```bash\\r\\nInput: piles = [30,11,23,4,20], h = 5\\r\\nOutput: 30\\r\\n```\\r\\n\\r\\n### Example 3\\r\\n\\r\\n```bash\\r\\nInput: piles = [30,11,23,4,20], h = 6\\r\\nOutput: 23\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n-      1 <= piles.length <= 104     \\r\\n-      piles.length <= h <= 109     \\r\\n-      1 <= piles[i] <= 109\",\"basename\":\"koko-eating-bananas\"},\"kth-largest-element-in-an-array\":{\"title\":\"kth largest elements in a stream\",\"description\":\"Given an integer array nums and an integer k, return the kth largest element in the array.\",\"tags\":[\"medium\",\"heap\"],\"link\":\"https://leetcode.com/problems/kth-largest-element-in-an-array/\",\"images\":[],\"preview\":\"### Description\\r\\n\\r\\nGiven an integer array nums and an integer `k`, return the `kth` largest element in the array.\\r\\n\\r\\nNote that it is the `kth` largest element in the sorted order, not the `kth` distinct element.\\r\\n\\r\\nYou must solve it in `O(n)` time complexity.\\r\\n\\r\\n### Example 1\\r\\n\\r\\n```bash\\r\\nInput: nums = [3,2,1,5,6,4], k = 2\\r\\nOutput: 5\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n\\r\\n```bash\\r\\nInput: nums = [3,2,3,1,2,4,5,5,6], k = 4\\r\\nOutput: 4\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n- 1 <= k <= nums.length <= 10^5 \\r\\n- -10^4 <= nums[i] <= 10^4\",\"basename\":\"kth-largest-element-in-an-array\"},\"kth-smallest-element-in-a-bst\":{\"title\":\"Kth Smallest Element in a BST\",\"description\":\"Given the root of a binary search tree, and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree.\",\"tags\":[\"medium\",\"binary-tree\"],\"link\":\"https://leetcode.com/problems/kth-smallest-element-in-a-bst/\",\"images\":[\"https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg\",\"https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg\"],\"preview\":\"### Description\\r\\n\\r\\nGiven the `root` of a binary search tree, and an integer k, return the kth smallest value (**1-indexed**) of all the values of the nodes in the tree.\\r\\n\\r\\n### Example 1\\r\\n\\r\\n![](https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg)\\r\\n\\r\\n```bash\\r\\nInput: root = [3,1,4,null,2], k = 1\\r\\nOutput: 1\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n\\r\\n![](https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg)\\r\\n\\r\\n```bash\\r\\nInput: root = [5,3,6,2,4,null,null,1], k = 3\\r\\nOutput: 3\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n- The number of nodes in the tree is n.\\r\\n- 1 <= k <= n <= 104\\r\\n- 0 <= Node.val <= 104\",\"basename\":\"kth-smallest-element-in-a-bst\"},\"largest-rectangle-area\":{\"title\":\"Largest Rectangle in Histogram\",\"description\":\"Given an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.\",\"tags\":[\"medium\",\"stack\"],\"link\":\"https://leetcode.com/problems/largest-rectangle-in-histogram/\",\"preview\":\"### Description\\r\\n\\r\\nGiven an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.\\r\\n\\r\\n### Example 1\\r\\n\\r\\n![image](https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg)\\r\\n\\r\\n```bash\\r\\nInput: heights = [2,1,5,6,2,3]\\r\\nOutput: 10\\r\\nExplanation: The above is a histogram where width of each bar is 1.\\r\\nThe largest rectangle is shown in the red area, which has an area = 10 units.\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n\\r\\n![image](https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg)\\r\\n\\r\\n```bash\\r\\nInput: heights = [2,4]\\r\\nOutput: 4\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n-      1 <= heights.length <= 105     \\r\\n-      0 <= heights[i] <= 104\",\"basename\":\"largest-rectangle-area\"},\"last-stone-weight\":{\"title\":\"Last Stone Weight\",\"description\":\"You are given an array of integers stones where stones[i] is the weight of the ith stone.\",\"tags\":[\"easy\",\"heap\"],\"link\":\"https://leetcode.com/problems/last-stone-weight/\",\"images\":[],\"preview\":\"### Description\\r\\n\\r\\nYou are given an array of integers stones where `stones[i]` is the weight of the ith stone.\\r\\n\\r\\nWe are playing a game with the stones. On each turn, we choose the **heaviest two stones** and smash them together. Suppose the heaviest two stones have weights x and y with x <= y. The result of this smash is:\\r\\n\\r\\n- If x == y, both stones are destroyed, and\\r\\n- If x != y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x.\\r\\nAt the end of the game, there is **at most one** stone left.\\r\\n\\r\\nReturn the weight of the last remaining stone. If there are no stones left, return 0.\\r\\n\\r\\n### Example 1\\r\\n\\r\\n```bash\\r\\nInput: stones = [2,7,4,1,8,1]\\r\\nOutput: 1\\r\\nExplanation: \\r\\nWe combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then,\\r\\nwe combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then,\\r\\nwe combine 2 and 1 to get 1 so the array converts to [1,1,1] then,\\r\\nwe combine 1 and 1 to get 0 so the array converts to [1] then that's the value of the last stone.\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n\\r\\n```bash\\r\\nInput: stones = [1]\\r\\nOutput: 1\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n- 1 <= stones.length <= 30 \\r\\n- 1 <= stones[i] <= 1000\",\"basename\":\"last-stone-weight\"},\"length-of-longest-substring\":{\"title\":\"Length of Longest Substring\",\"description\":\"Given a string s, find the length of the longest substring without repeating characters.\",\"tags\":[\"medium\",\"sliding-window\"],\"preview\":\"### Description\\r\\n\\r\\nGiven a string s, find the length of the longest substring without repeating characters.\\r\\n\\r\\n### Example 1\\r\\n\\r\\n\\r\\n```bash\\r\\nInput: s = \\\"abcabcbb\\\"\\r\\nOutput: 3\\r\\nExplanation: The answer is \\\"abc\\\", with the length of 3.\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n```bash\\r\\nInput: s = \\\"bbbbb\\\"\\r\\nOutput: 1\\r\\nExplanation: The answer is \\\"b\\\", with the length of 1.\\r\\n```\\r\\n\\r\\n### Example 3\\r\\n```bash\\r\\nInput: s = \\\"pwwkew\\\"\\r\\nOutput: 3\\r\\nExplanation: The answer is \\\"wke\\\", with the length of 3.\\r\\nNotice that the answer must be a substring, \\\"pwke\\\" is a subsequence and not a substring.\\r\\n```\\r\\n\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n- 0 <= s.length <= 5 * 104\\r\\n- s consists of English letters, digits, symbols and spaces.\",\"basename\":\"length-of-longest-substring\"},\"letter-combinations-of-a-phone-number\":{\"title\":\"Letter Combinations of a Phone Number\",\"description\":\"Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.\",\"tags\":[\"hard\",\"backtracking\"],\"link\":\"https://leetcode.com/problems/letter-combinations-of-a-phone-number/\",\"images\":[],\"preview\":\"### Description\\r\\n\\r\\nGiven a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in **any order**.\\r\\nA mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\\r\\n\\r\\n### Example 1\\r\\n\\r\\n![Example 1](https://assets.leetcode.com/uploads/2022/03/15/1200px-telephone-keypad2svg.png)\\r\\n\\r\\n\\r\\n```bash\\r\\nInput: digits = \\\"23\\\"\\r\\nOutput: [\\\"ad\\\",\\\"ae\\\",\\\"af\\\",\\\"bd\\\",\\\"be\\\",\\\"bf\\\",\\\"cd\\\",\\\"ce\\\",\\\"cf\\\"]\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n\\r\\n```bash\\r\\nInput: digits = \\\"\\\"\\r\\nOutput: []\\r\\n```\\r\\n\\r\\n### Example 3\\r\\n\\r\\n```bash\\r\\nInput: digits = \\\"2\\\"\\r\\nOutput: [\\\"a\\\",\\\"b\\\",\\\"c\\\"]\\r\\n```\\r\\n\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n- 0 <= digits.length <= 4\\r\\n- digits[i] is a digit in the range ['2', '9']\",\"basename\":\"letter-combinations-of-a-phone-number\"},\"linked-list-cycle\":{\"title\":\"Linked List Cycle\",\"description\":\"Given head, the head of a linked list, determine if the linked list has a cycle in it.\",\"tags\":[\"medium\",\"linked-list\"],\"link\":\"https://leetcode.com/problems/linked-list-cycle/\",\"preview\":\"### Description\\r\\n\\r\\nGiven `head`, the head of a linked list, determine if the linked list has a cycle in it.\\r\\n\\r\\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. **Note that** pos **is not passed as a parameter**.\\r\\n\\r\\nReturn `true` if there is a cycle in the linked list. Otherwise, return `false`.\\r\\n\\r\\n### Example 1\\r\\n\\r\\n```bash\\r\\nInput: head = [3,2,0,-4], pos = 1\\r\\nOutput: true\\r\\nExplanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n\\r\\n```bash\\r\\nInput: head = [1,2], pos = 0\\r\\nOutput: true\\r\\nExplanation: There is a cycle in the linked list, where the tail connects to the 0th node.\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n- The number of the nodes in the list is in the range [0, 104]. \\r\\n- -10^5 <= Node.val <= 10^5 \\r\\n- pos is -1 or a valid index in the linked-list.\",\"basename\":\"linked-list-cycle\"},\"lru-cache\":{\"title\":\"LRU Cache\",\"description\":\"Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\",\"tags\":[\"medium\",\"linked-list\"],\"link\":\"https://leetcode.com/problems/lru-cache/\",\"preview\":\"### Description\\r\\n\\r\\nDesign a data structure that follows the constraints of a Least Recently Used (LRU) cache.\\r\\n\\r\\nImplement the `LRUCache` class:\\r\\n\\r\\n- LRUCache(int capacity) Initialize the LRU cache with **positive** size capacity.\\r\\n- `int get(int key)` Return the value of the key if the key exists, otherwise return -1.\\r\\n- void `put(int key, int value)` Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, **evict** the least recently used key.\\r\\n\\r\\nThe functions get and put must each run in O(1) average time complexity.\\r\\n\\r\\n### Example 1\\r\\n\\r\\n```bash\\r\\nInput\\r\\n[\\\"LRUCache\\\", \\\"put\\\", \\\"put\\\", \\\"get\\\", \\\"put\\\", \\\"get\\\", \\\"put\\\", \\\"get\\\", \\\"get\\\", \\\"get\\\"]\\r\\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\\r\\nOutput\\r\\n[null, null, null, 1, null, -1, null, -1, 3, 4]\\r\\n\\r\\nExplanation\\r\\nLRUCache lRUCache = new LRUCache(2);\\r\\nlRUCache.put(1, 1); // cache is {1=1}\\r\\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\\r\\nlRUCache.get(1);    // return 1\\r\\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\\r\\nlRUCache.get(2);    // returns -1 (not found)\\r\\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\\r\\nlRUCache.get(1);    // return -1 (not found)\\r\\nlRUCache.get(3);    // return 3\\r\\nlRUCache.get(4);    // return 4\\r\\n```\\r\\n\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n- 1 <= capacity <= 3000\\r\\n- 0 <= key <= 104\\r\\n- 0 <= value <= 105\\r\\n- At most 2 * 105 calls will be made to get and put.\",\"basename\":\"lru-cache\"},\"max-area-of-island\":{\"title\":\"Max Area of Island\",\"description\":\"You are given an m x n binary matrix grid. An island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.\",\"tags\":[\"medium\",\"graphs\"],\"link\":\"https://leetcode.com/problems/max-area-of-island/\",\"images\":[],\"preview\":\"### Description\\r\\n\\r\\nYou are given an m x n binary matrix grid. An island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.\\r\\n\\r\\nThe area of an island is the number of cells with a value 1 in the island.\\r\\n\\r\\nReturn the maximum area of an island in grid. If there is no island, return 0.\\r\\n\\r\\n### Example 1\\r\\n\\r\\n![](https://assets.leetcode.com/uploads/2021/05/01/maxarea1-grid.jpg)\\r\\n\\r\\n```bash\\r\\nInput: grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]\\r\\nOutput: 6\\r\\nExplanation: The answer is not 11, because the island must be connected 4-directionally.\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n\\r\\n```bash\\r\\nInput: grid = [[0,0,0,0,0,0,0,0]]\\r\\nOutput: 0\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n- m == grid.length \\r\\n- n == grid[i].length \\r\\n- 1 <= m, n <= 50 \\r\\n- grid[i][j] is either 0 or 1.\",\"basename\":\"max-area-of-island\"},\"max-profit\":{\"title\":\"Max Profit\",\"description\":\"Best time to Buy and Sell Stock\",\"tags\":[\"easy\",\"sliding-window\"],\"preview\":\"### Description\\r\\n\\r\\nYou are given an array prices where prices[i] is the price of a given stock on the ith day.\\r\\n\\r\\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\\r\\n\\r\\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.\\r\\n\\r\\n### Example 1\\r\\n\\r\\n```bash\\r\\nInput: prices = [7,1,5,3,6,4]\\r\\nOutput: 5\\r\\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\\r\\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n\\r\\n```bash\\r\\nInput: prices = [7,6,4,3,1]\\r\\nOutput: 0\\r\\nExplanation: In this case, no transactions are done and the max profit = 0.\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n-  1 <= prices.length <= 105\\r\\n-  0 <= prices[i] <= 104\",\"basename\":\"max-profit\"},\"max-sliding-window\":{\"title\":\"Max Sliding Window\",\"description\":\"Sliding Window Maximum\",\"tags\":[\"hard\",\"sliding-window\"],\"link\":\"https://leetcode.com/problems/sliding-window-maximum/\",\"preview\":\"### Description\\r\\n\\r\\nYou are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.  Return the max sliding window.\\r\\n\\r\\n### Example 1\\r\\n\\r\\n```bash\\r\\nInput: nums = [1,3,-1,-3,5,3,6,7], k = 3\\r\\nOutput: [3,3,5,5,6,7]\\r\\nExplanation: \\r\\nWindow position                Max\\r\\n---------------               -----\\r\\n[1  3  -1] -3  5  3  6  7       3\\r\\n 1 [3  -1  -3] 5  3  6  7       3\\r\\n 1  3 [-1  -3  5] 3  6  7       5\\r\\n 1  3  -1 [-3  5  3] 6  7       5\\r\\n 1  3  -1  -3 [5  3  6] 7       6\\r\\n 1  3  -1  -3  5 [3  6  7]      7\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n```bash\\r\\nInput: nums = [1], k = 1\\r\\nOutput: [1]\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n-      1 <= nums.length <= 10^5     \\r\\n-      -10^4 <= nums[i] <= 10^4     \\r\\n-      1 <= k <= nums.length\",\"basename\":\"max-sliding-window\"},\"maximum-depth-of-binary-tree\":{\"title\":\"Maximum Depth of Binary Tree\",\"description\":\"A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\",\"tags\":[\"easy\",\"binary-tree\"],\"link\":\"https://leetcode.com/problems/maximum-depth-of-binary-tree/\",\"images\":[\"https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg\"],\"preview\":\"### Description\\r\\n\\r\\nGiven the root of a binary tree, return its maximum depth.\\r\\n\\r\\nA binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\\r\\n\\r\\n### Example 1\\r\\n\\r\\n![](https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg)\\r\\n\\r\\n```bash\\r\\nInput: root = [3,9,20,null,null,15,7]\\r\\nOutput: 3\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n\\r\\n```bash\\r\\nInput: root = [1,null,2]\\r\\nOutput: 2\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n- The number of nodes in the tree is in the range [0, 104]. \\r\\n- -100 <= Node.val <= 100\",\"basename\":\"maximum-depth-of-binary-tree\"},\"median-sorted-arrays\":{\"title\":\"Median of Two Sorted Arrays\",\"description\":\"Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\",\"tags\":[\"hard\",\"binary-search\",\"array\"],\"link\":\"https://leetcode.com/problems/median-of-two-sorted-arrays/\",\"preview\":\"### Description\\r\\n\\r\\nGiven two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively, return **the median** of the two sorted arrays.\\r\\n\\r\\nThe overall run time complexity should be `O(log (m+n))`.\\r\\n\\r\\n### Example 1\\r\\n\\r\\n```bash\\r\\nInput: nums1 = [1,3], nums2 = [2]\\r\\nOutput: 2.00000\\r\\nExplanation: merged array = [1,2,3] and median is 2.\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n\\r\\n```bash\\r\\nInput: nums1 = [1,2], nums2 = [3,4]\\r\\nOutput: 2.50000\\r\\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n-      nums1.length == m     \\r\\n-      nums2.length == n     \\r\\n-      0 <= m <= 1000     \\r\\n-      0 <= n <= 1000     \\r\\n-      1 <= m + n <= 2000     \\r\\n-      -106 <= nums1[i], nums2[i] <= 106\",\"basename\":\"median-sorted-arrays\"},\"merge-k-sorted-list\":{\"title\":\"Merge k Sorted Lists\",\"description\":\"You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\",\"tags\":[\"hard\",\"linked-list\"],\"link\":\"https://leetcode.com/problems/merge-k-sorted-lists/\",\"preview\":\"### Description\\r\\n\\r\\nYou are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\\r\\n\\r\\nMerge all the linked-lists into one sorted linked-list and return it.\\r\\n\\r\\n \\r\\n\\r\\n### Example 1\\r\\n\\r\\n```bash\\r\\nInput: lists = [[1,4,5],[1,3,4],[2,6]]\\r\\nOutput: [1,1,2,3,4,4,5,6]\\r\\nExplanation: The linked-lists are:\\r\\n[\\r\\n  1->4->5,\\r\\n  1->3->4,\\r\\n  2->6\\r\\n]\\r\\nmerging them into one sorted list:\\r\\n1->1->2->3->4->4->5->6\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n\\r\\n```bash\\r\\n\\r\\n```\\r\\n\\r\\n### Example 3\\r\\n\\r\\n```bash\\r\\nInput: lists = [[]]\\r\\nOutput: []\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n- k == lists.length \\r\\n- 0 <= k <= 10^4 \\r\\n- 0 <= lists[i].length <= 500 \\r\\n- -10^4 <= lists[i][j] <= 10^4 \\r\\n- lists[i] is sorted in **ascending order**. \\r\\n- The sum of lists[i].length will not exceed 10^4.\",\"basename\":\"merge-k-sorted-list\"},\"merge-two-sorted-list\":{\"title\":\"Merge Two Sorted Lists\",\"description\":\"You are given the heads of two sorted linked lists list1 and list2. Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.\",\"tags\":[\"easy\",\"linked-list\"],\"link\":\"https://leetcode.com/problems/merge-two-sorted-lists/\",\"images\":[\"https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg\"],\"preview\":\"### Description\\r\\n\\r\\nYou are given the heads of two sorted linked lists list1 and list2.\\r\\n\\r\\nMerge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.\\r\\n\\r\\nReturn the head of the merged linked list.\\r\\n\\r\\n### Example 1\\r\\n\\r\\n![](https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg)\\r\\n\\r\\n```bash\\r\\nInput: list1 = [1,2,4], list2 = [1,3,4]\\r\\nOutput: [1,1,2,3,4,4]\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n\\r\\n```bash\\r\\nInput: list1 = [], list2 = []\\r\\nOutput: []\\r\\n```\\r\\n\\r\\n### Example 3\\r\\n\\r\\n```bash\\r\\nInput: list1 = [], list2 = [0]\\r\\nOutput: [0]\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n- The number of nodes in both lists is in the range [0, 50]. \\r\\n- -100 <= Node.val <= 100 \\r\\n- Both list1 and list2 are sorted in non-decreasing order.\",\"basename\":\"merge-two-sorted-list\"},\"min-stack\":{\"title\":\"Min Stack\",\"description\":\"Min Stack\",\"tags\":[\"medium\",\"stack\"],\"link\":\"https://leetcode.com/problems/min-stack/\",\"preview\":\"### Description\\r\\n\\r\\nDesign a stack that supports push, pop, top, and retrieving the minimum element in constant time.\\r\\n\\r\\nImplement the MinStack class:\\r\\n\\r\\n    MinStack() initializes the stack object.\\r\\n    void push(int val) pushes the element val onto the stack.\\r\\n    void pop() removes the element on the top of the stack.\\r\\n    int top() gets the top element of the stack.\\r\\n    int getMin() retrieves the minimum element in the stack.\\r\\n\\r\\nYou must implement a solution with O(1) time complexity for each function.\\r\\n\\r\\n### Example 1\\r\\n```bash\\r\\nInput\\r\\n[\\\"MinStack\\\",\\\"push\\\",\\\"push\\\",\\\"push\\\",\\\"getMin\\\",\\\"pop\\\",\\\"top\\\",\\\"getMin\\\"]\\r\\n[[],[-2],[0],[-3],[],[],[],[]]\\r\\n\\r\\nOutput\\r\\n[null,null,null,null,-3,null,0,-2]\\r\\n\\r\\nExplanation\\r\\nMinStack minStack = new MinStack();\\r\\nminStack.push(-2);\\r\\nminStack.push(0);\\r\\nminStack.push(-3);\\r\\nminStack.getMin(); // return -3\\r\\nminStack.pop();\\r\\nminStack.top();    // return 0\\r\\nminStack.getMin(); // return -2\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n- -2^31 <= val <= 2^31 - 1     \\r\\n- Methods pop, top and getMin operations will always be called on non-empty stacks.     \\r\\n- At most 3 * 104 calls will be made to push, pop, top, and getMin.\",\"basename\":\"min-stack\"},\"min-window\":{\"title\":\"Min Window Substring\",\"description\":\"Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \\\"\\\".\",\"tags\":[\"hard\",\"sliding-window\"],\"preview\":\"### Description\\r\\n\\r\\nGiven two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \\\"\\\".\\r\\n\\r\\n### Example 1\\r\\n```bash\\r\\nInput: s = \\\"ADOBECODEBANC\\\", t = \\\"ABC\\\"\\r\\nOutput: \\\"BANC\\\"\\r\\nExplanation: The minimum window substring \\\"BANC\\\" includes 'A', 'B', and 'C' from string t.\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n```bash\\r\\nInput: s = \\\"a\\\", t = \\\"a\\\"\\r\\nOutput: \\\"a\\\"\\r\\nExplanation: The entire string s is the minimum window.\\r\\n```\\r\\n\\r\\n### Example 3\\r\\n```bash\\r\\nInput: s = \\\"a\\\", t = \\\"aa\\\"\\r\\nOutput: \\\"\\\"\\r\\nExplanation: Both 'a's from t must be included in the window.\\r\\nSince the largest window of s only has one 'a', return empty string.\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n-      m == s.length     \\r\\n-      n == t.length     \\r\\n-      1 <= m, n <= 105     \\r\\n-      s and t consist of uppercase and lowercase English letters.\",\"basename\":\"min-window\"},\"n-queens\":{\"title\":\"N-Queens\",\"description\":\"The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\",\"tags\":[\"hard\",\"backtracking\"],\"link\":\"https://leetcode.com/problems/n-queens/\",\"images\":[],\"preview\":\"### Description\\r\\n\\r\\nThe **n-queens** puzzle is the problem of placing n queens on an `n x n` chessboard such that no two queens attack each other.\\r\\n\\r\\nGiven an integer n, return all distinct solutions to the **n-queens puzzle**. You may return the answer in **any order**.\\r\\n\\r\\nEach solution contains a distinct board configuration of the n-queens' placement, where `'Q'` and `'.'` both indicate a queen and an empty space, respectively.\\r\\n\\r\\n### Example 1\\r\\n\\r\\n![](https://assets.leetcode.com/uploads/2020/11/13/queens.jpg)\\r\\n\\r\\n\\r\\n```bash\\r\\nInput: n = 4\\r\\nOutput: [[\\\".Q..\\\",\\\"...Q\\\",\\\"Q...\\\",\\\"..Q.\\\"],[\\\"..Q.\\\",\\\"Q...\\\",\\\"...Q\\\",\\\".Q..\\\"]]\\r\\nExplanation: There exist two distinct solutions to the 4-queens puzzle as shown above\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n\\r\\n```bash\\r\\nInput: n = 1\\r\\nOutput: [[\\\"Q\\\"]]\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n- `1 <= n <= 9`\",\"basename\":\"n-queens\"},\"number-of-connected-components-in-an-undirected-graph\":{\"title\":\"Redundant Connection\",\"description\":\"find the number of connected components in an undirected graph.\",\"tags\":[\"medium\",\"graphs\"],\"link\":\"https://cheonhyangzhang.gitbooks.io/leetcode-solutions/content/323-number-of-connected-components-in-an-undirected-graph.html\",\"images\":[],\"preview\":\"### Description\\r\\n\\r\\nGiven n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to find the number of connected components in an undirected graph.\\r\\n\\r\\n### Example 1\\r\\n\\r\\n```bash\\r\\n\\r\\nExample 1:\\r\\n\\r\\n     0          3\\r\\n     |          |\\r\\n     1 --- 2    4\\r\\n\\r\\nGiven n = 5 and edges = [[0, 1], [1, 2], [3, 4]], return 2.\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n\\r\\n```bash\\r\\n\\r\\nExample 2:\\r\\n\\r\\n     0           4\\r\\n     |           |\\r\\n     1 --- 2 --- 3\\r\\n\\r\\nGiven n = 5 and edges = [[0, 1], [1, 2], [2, 3], [3, 4]], return 1.\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\nNote:\\r\\nYou can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges.\",\"basename\":\"number-of-connected-components-in-an-undirected-graph\"},\"number-of-islands\":{\"title\":\"Number of Islands\",\"description\":\"Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\",\"tags\":[\"medium\",\"graphs\"],\"link\":null,\"images\":[],\"preview\":\"### Description\\r\\n\\r\\nGiven an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\\r\\n\\r\\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\\r\\n\\r\\n\\r\\n### Example 1\\r\\n\\r\\n```bash\\r\\nInput: grid = [\\r\\n  [\\\"1\\\",\\\"1\\\",\\\"1\\\",\\\"1\\\",\\\"0\\\"],\\r\\n  [\\\"1\\\",\\\"1\\\",\\\"0\\\",\\\"1\\\",\\\"0\\\"],\\r\\n  [\\\"1\\\",\\\"1\\\",\\\"0\\\",\\\"0\\\",\\\"0\\\"],\\r\\n  [\\\"0\\\",\\\"0\\\",\\\"0\\\",\\\"0\\\",\\\"0\\\"]\\r\\n]\\r\\nOutput: 1\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n\\r\\n```bash\\r\\n\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n-\",\"basename\":\"number-of-islands\"},\"pacific-atlantic-water-flow\":{\"title\":\"Pacific Atlantic Water Flow\",\"description\":\"There is an m x n rectangular island that borders both the Pacific Ocean and Atlantic Ocean. The Pacific Ocean touches the island's left and top edges, and the Atlantic Ocean touches the island's right and bottom edges.\",\"tags\":[\"medium\",\"graphs\"],\"link\":\"https://leetcode.com/problems/pacific-atlantic-water-flow/\",\"images\":[],\"preview\":\"### Description\\r\\n\\r\\nThere is an m x n rectangular island that borders both the** Pacific Ocean** and Atlantic Ocean. The Pacific Ocean touches the island's left and top edges, and the Atlantic Ocean touches the island's right and bottom edges.\\r\\n\\r\\nThe island is partitioned into a grid of square cells. You are given an m x n integer matrix heights where heights[r][c] represents the **height above sea level** of the cell at coordinate (r, c).\\r\\n\\r\\nThe island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell's height is **less than or equal to** the current cell's height. Water can flow from any cell adjacent to an ocean into the ocean.\\r\\n\\r\\nReturn a **2D list** of grid coordinates result where result[i] = [ri, ci] denotes that rain water can flow from cell (ri, ci) to **both** the Pacific and Atlantic oceans.\\r\\n\\r\\n### Example 1\\r\\n\\r\\n![](https://assets.leetcode.com/uploads/2021/06/08/waterflow-grid.jpg)\\r\\n\\r\\n```bash\\r\\nInput: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]\\r\\nOutput: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]\\r\\nExplanation: The following cells can flow to the Pacific and Atlantic oceans, as shown below:\\r\\n[0,4]: [0,4] -> Pacific Ocean \\r\\n       [0,4] -> Atlantic Ocean\\r\\n[1,3]: [1,3] -> [0,3] -> Pacific Ocean \\r\\n       [1,3] -> [1,4] -> Atlantic Ocean\\r\\n[1,4]: [1,4] -> [1,3] -> [0,3] -> Pacific Ocean \\r\\n       [1,4] -> Atlantic Ocean\\r\\n[2,2]: [2,2] -> [1,2] -> [0,2] -> Pacific Ocean \\r\\n       [2,2] -> [2,3] -> [2,4] -> Atlantic Ocean\\r\\n[3,0]: [3,0] -> Pacific Ocean \\r\\n       [3,0] -> [4,0] -> Atlantic Ocean\\r\\n[3,1]: [3,1] -> [3,0] -> Pacific Ocean \\r\\n       [3,1] -> [4,1] -> Atlantic Ocean\\r\\n[4,0]: [4,0] -> Pacific Ocean \\r\\n       [4,0] -> Atlantic Ocean\\r\\nNote that there are other possible paths for these cells to flow to the Pacific and Atlantic oceans.\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n\\r\\n```bash\\r\\nInput: heights = [[1]]\\r\\nOutput: [[0,0]]\\r\\nExplanation: The water can flow from the only cell to the Pacific and Atlantic oceans.\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n- m == heights.length\\r\\n- n == heights[r].length\\r\\n- 1 <= m, n <= 200\\r\\n- 0 <= heights[r][c] <= 10^5\",\"basename\":\"pacific-atlantic-water-flow\"},\"palindrome-partitioning\":{\"title\":\"Palindrome Partitioning\",\"description\":\"Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s.\",\"tags\":[],\"link\":\"https://leetcode.com/problems/palindrome-partitioning/\",\"images\":[],\"preview\":\"### Description\\r\\n\\r\\nGiven a string `s`, partition `s` such that every substring of the partition is a **palindrome**. Return all possible palindrome partitioning of `s`.\\r\\n\\r\\n### Example 1\\r\\n\\r\\n```bash\\r\\nInput: s = \\\"aab\\\"\\r\\nOutput: [[\\\"a\\\",\\\"a\\\",\\\"b\\\"],[\\\"aa\\\",\\\"b\\\"]]\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n\\r\\n```bash\\r\\nInput: s = \\\"a\\\"\\r\\nOutput: [[\\\"a\\\"]]\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n- 1 <= s.length <= 16 \\r\\n- `s` contains only lowercase English letters.\",\"basename\":\"palindrome-partitioning\"},\"permutations\":{\"title\":\"Permutations\",\"description\":\"Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.\",\"tags\":[\"medium\",\"backtracking\"],\"link\":\"https://leetcode.com/problems/permutations/\",\"images\":[],\"preview\":\"### Description\\r\\n\\r\\nGiven an array `nums` of distinct integers, return all the possible permutations. You can return the answer **in any order**.\\r\\n\\r\\n### Example 1\\r\\n\\r\\n```bash\\r\\nInput: nums = [1,2,3]\\r\\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n\\r\\n```bash\\r\\nInput: nums = [0,1]\\r\\nOutput: [[0,1],[1,0]]\\r\\n```\\r\\n\\r\\n### Example 3\\r\\n\\r\\n```bash\\r\\nInput: nums = [1]\\r\\nOutput: [[1]]\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n- 1 <= nums.length <= 6 \\r\\n- -10 <= nums[i] <= 10 \\r\\n- All the integers of nums are unique.\",\"basename\":\"permutations\"},\"prompt\":{\"preview\":\"{\\\"add-two-numbers\\\":{\\\"title\\\":\\\"Add Two Numbers\\\",\\\"description\\\":\\\"You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\\\",\\\"tags\\\":[\\\"medium\\\",\\\"linked-list\\\"],\\\"link\\\":\\\"https://leetcode.com/problems/add-two-numbers/\\\",\\\"images\\\":[\\\"https://assets.leetcode.com/uploads/2020/10/02/addtwonumber1.jpg\\\"],\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\\\\r\\\\n\\\\r\\\\n\\\\r\\\\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n![](https://assets.leetcode.com/uploads/2020/10/02/addtwonumber1.jpg)\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: l1 = [2,4,3], l2 = [5,6,4]\\\\r\\\\nOutput: [7,0,8]\\\\r\\\\nExplanation: 342 + 465 = 807.\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: l1 = [0], l2 = [0]\\\\r\\\\nOutput: [0]\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 3\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\\\\r\\\\nOutput: [8,9,9,9,0,0,0,1]\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n- The number of nodes in each linked list is in the range [1, 100]. \\\\r\\\\n- 0 <= Node.val <= 9 \\\\r\\\\n- It is guaranteed that the list represents a number that does not have leading zeros.\\\",\\\"basename\\\":\\\"add-two-numbers\\\"},\\\"balanced-binary-tree\\\":{\\\"title\\\":\\\"Balanced Binary Tree\\\",\\\"description\\\":\\\"Given a binary tree, determine if it is height-balanced.\\\",\\\"tags\\\":[\\\"easy\\\",\\\"binary-tree\\\"],\\\"link\\\":\\\"https://leetcode.com/problems/balanced-binary-tree/\\\",\\\"images\\\":[\\\"https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg\\\"],\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nGiven a binary tree, determine if it is height-balanced.\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n\\\\r\\\\n![](https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg)\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: root = [3,9,20,null,null,15,7]\\\\r\\\\nOutput: true\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n\\\\r\\\\n![](https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg)\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: root = [1,2,2,3,3,null,null,4,4]\\\\r\\\\nOutput: false\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 3\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: root = []\\\\r\\\\nOutput: true\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n- The number of nodes in the tree is in the range [0, 5000]. \\\\r\\\\n- -10^4 <= Node.val <= 10^4\\\",\\\"basename\\\":\\\"balanced-binary-tree\\\"},\\\"binary-search\\\":{\\\"title\\\":\\\"Binary Search\\\",\\\"description\\\":\\\"Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.\\\",\\\"tags\\\":[\\\"medium\\\",\\\"binary-search\\\"],\\\"link\\\":\\\"https://leetcode.com/problems/binary-search/\\\",\\\"images\\\":[],\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nGiven an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.\\\\r\\\\n\\\\r\\\\nYou must write an algorithm with O(log n) runtime complexity.\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: nums = [-1,0,3,5,9,12], target = 9\\\\r\\\\nOutput: 4\\\\r\\\\nExplanation: 9 exists in nums and its index is 4\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: nums = [-1,0,3,5,9,12], target = 2\\\\r\\\\nOutput: -1\\\\r\\\\nExplanation: 2 does not exist in nums so return -1\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n-     1 <= nums.length <= 104\\\\r\\\\n-     -104 < nums[i], target < 104\\\\r\\\\n-     All the integers in nums are unique.\\\\r\\\\n-     uunums is sorted in ascending order.\\\",\\\"basename\\\":\\\"binary-search\\\"},\\\"binary-tree-level-order-traversal\\\":{\\\"title\\\":\\\"Binary Tree Level Order Traversal\\\",\\\"description\\\":\\\"Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).\\\",\\\"tags\\\":[\\\"medium\\\",\\\"binary-tree\\\"],\\\"link\\\":\\\"https://leetcode.com/problems/binary-tree-level-order-traversal/\\\",\\\"images\\\":[\\\"https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg\\\"],\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nGiven the `root` of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n![](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: root = [3,9,20,null,null,15,7]\\\\r\\\\nOutput: [[3],[9,20],[15,7]]\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: root = [1]\\\\r\\\\nOutput: [[1]]\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n- The number of nodes in the tree is in the range [0, 2000]. \\\\r\\\\n- -1000 <= Node.val <= 1000\\\",\\\"basename\\\":\\\"binary-tree-level-order-traversal\\\"},\\\"binary-tree-maximum-path-sum\\\":{\\\"title\\\":\\\"Binary Tree Maximum Path Sum\\\",\\\"description\\\":\\\"Given the root of a binary tree, return the maximum path sum of any non-empty path.\\\",\\\"tags\\\":[\\\"hard\\\",\\\"binary-tree\\\"],\\\"link\\\":\\\"https://leetcode.com/problems/binary-tree-maximum-path-sum/\\\",\\\"images\\\":[\\\"https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg\\\",\\\"https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg\\\"],\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nA path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.\\\\r\\\\n\\\\r\\\\nThe path sum of a path is the sum of the node's values in the path.\\\\r\\\\n\\\\r\\\\nGiven the root of a binary tree, return the maximum path sum of any non-empty path.\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n![](https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg)\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: root = [1,2,3]\\\\r\\\\nOutput: 6\\\\r\\\\nExplanation: The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6.\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n\\\\r\\\\n![](https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg)\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: root = [-10,9,20,null,null,15,7]\\\\r\\\\nOutput: 42\\\\r\\\\nExplanation: The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42.\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n- The number of nodes in the tree is in the range [1, 3 * 10^4]. \\\\r\\\\n- -1000 <= Node.val <= 1000\\\",\\\"basename\\\":\\\"binary-tree-maximum-path-sum\\\"},\\\"binary-tree-right-side-view\\\":{\\\"title\\\":\\\"Binary Tree Right Side View\\\",\\\"description\\\":\\\"Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.\\\",\\\"tags\\\":[\\\"medium\\\",\\\"binary-tree\\\"],\\\"link\\\":\\\"https://leetcode.com/problems/binary-tree-right-side-view/\\\",\\\"images\\\":[\\\"https://assets.leetcode.com/uploads/2021/02/14/tree.jpg\\\"],\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nGiven the `root` of a binary tree, imagine yourself standing on the **right side** of it, return the values of the nodes you can see ordered from top to bottom.\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n![](https://assets.leetcode.com/uploads/2021/02/14/tree.jpg)\\\\r\\\\n\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: root = [1,2,3,null,5,null,4]\\\\r\\\\nOutput: [1,3,4]\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: root = [1,null,3]\\\\r\\\\nOutput: [1,3]\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n- The number of nodes in the tree is in the range [0, 100]. \\\\r\\\\n- -100 <= Node.val <= 100\\\",\\\"basename\\\":\\\"binary-tree-right-side-view\\\"},\\\"car-fleet\\\":{\\\"title\\\":\\\"Car Fleet\\\",\\\"description\\\":\\\"There are n cars going to the same destination along a one-lane road. The destination is target miles away.\\\",\\\"tags\\\":[\\\"medium\\\",\\\"stack\\\"],\\\"link\\\":\\\"https://leetcode.com/problems/car-fleet/\\\",\\\"images\\\":[],\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nThere are `n` cars going to the same destination along a one-lane road. The destination is `target` miles away.\\\\r\\\\n\\\\r\\\\nYou are given two integer array position and speed, both of length n, where position[i] is the position of the ith car and speed[i] is the speed of the ith car (in miles per hour).\\\\r\\\\n\\\\r\\\\nA car can never pass another car ahead of it, but it can catch up to it and drive bumper to bumper at the same speed. The faster car will slow down to match the slower car's speed. The distance between these two cars is ignored (i.e., they are assumed to have the same position).\\\\r\\\\n\\\\r\\\\nA car fleet is some non-empty set of cars driving at the same position and same speed. Note that a single car is also a car fleet.\\\\r\\\\n\\\\r\\\\nIf a car catches up to a car fleet right at the destination point, it will still be considered as one car fleet.\\\\r\\\\n\\\\r\\\\nReturn the number of car fleets that will arrive at the destination.\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]\\\\r\\\\nOutput: 3\\\\r\\\\nExplanation:\\\\r\\\\nThe cars starting at 10 (speed 2) and 8 (speed 4) become a fleet, meeting each other at 12.\\\\r\\\\nThe car starting at 0 does not catch up to any other car, so it is a fleet by itself.\\\\r\\\\nThe cars starting at 5 (speed 1) and 3 (speed 3) become a fleet, meeting each other at 6. The fleet moves at speed 1 until it reaches target.\\\\r\\\\nNote that no other cars meet these fleets before the destination, so the answer is 3.\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: target = 10, position = [3], speed = [3]\\\\r\\\\nOutput: 1\\\\r\\\\nExplanation: There is only one car, hence there is only one fleet.\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 3\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: target = 100, position = [0,2,4], speed = [4,2,1]\\\\r\\\\nOutput: 1\\\\r\\\\nExplanation:\\\\r\\\\nThe cars starting at 0 (speed 4) and 2 (speed 2) become a fleet, meeting each other at 4. The fleet moves at speed 2.\\\\r\\\\nThen, the fleet (speed 2) and the car starting at 4 (speed 1) become one fleet, meeting each other at 6. The fleet moves at speed 1 until it reaches target.\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n-      n == position.length == speed.length     \\\\r\\\\n-      1 <= n <= 105\\\\r\\\\n-      0 < target <= 106\\\\r\\\\n-      0 <= position[i] < target\\\\r\\\\n-      All the values of position are unique.\\\\r\\\\n-      0 < speed[i] <= 106\\\",\\\"basename\\\":\\\"car-fleet\\\"},\\\"character-replacement\\\":{\\\"title\\\":\\\"Character Replacement\\\",\\\"description\\\":\\\"Longest Repeating Character Replacement\\\",\\\"tags\\\":[\\\"medium\\\",\\\"sliding-window\\\"],\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nYou are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times.\\\\r\\\\n\\\\r\\\\nReturn the length of the longest substring containing the same letter you can get after performing the above operations.\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n```bash\\\\r\\\\nInput: s = \\\\\\\"ABAB\\\\\\\", k = 2\\\\r\\\\nOutput: 4\\\\r\\\\nExplanation: Replace the two 'A's with two 'B's or vice versa.\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n```bash\\\\r\\\\nInput: s = \\\\\\\"AABABBA\\\\\\\", k = 1\\\\r\\\\nOutput: 4\\\\r\\\\nExplanation: Replace the one 'A' in the middle with 'B' and form \\\\\\\"AABBBBA\\\\\\\".\\\\r\\\\nThe substring \\\\\\\"BBBB\\\\\\\" has the longest repeating letters, which is 4.\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n- 1 <= s.length <= 105\\\\r\\\\n- s consists of only uppercase English letters.\\\\r\\\\n- 0 <= k <= s.length\\\",\\\"basename\\\":\\\"character-replacement\\\"},\\\"clone-graph\\\":{\\\"title\\\":\\\"Clone Graph\\\",\\\"description\\\":\\\"Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\\\",\\\"tags\\\":[\\\"medium\\\",\\\"graphs\\\"],\\\"link\\\":null,\\\"images\\\":[],\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nGiven an `m x n` 2D binary grid `grid` which represents a map of `'1's` (land) and `'0's` (water), return the number of islands.\\\\r\\\\n\\\\r\\\\nAn **island** is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: grid = [\\\\r\\\\n  [\\\\\\\"1\\\\\\\",\\\\\\\"1\\\\\\\",\\\\\\\"1\\\\\\\",\\\\\\\"1\\\\\\\",\\\\\\\"0\\\\\\\"],\\\\r\\\\n  [\\\\\\\"1\\\\\\\",\\\\\\\"1\\\\\\\",\\\\\\\"0\\\\\\\",\\\\\\\"1\\\\\\\",\\\\\\\"0\\\\\\\"],\\\\r\\\\n  [\\\\\\\"1\\\\\\\",\\\\\\\"1\\\\\\\",\\\\\\\"0\\\\\\\",\\\\\\\"0\\\\\\\",\\\\\\\"0\\\\\\\"],\\\\r\\\\n  [\\\\\\\"0\\\\\\\",\\\\\\\"0\\\\\\\",\\\\\\\"0\\\\\\\",\\\\\\\"0\\\\\\\",\\\\\\\"0\\\\\\\"]\\\\r\\\\n]\\\\r\\\\nOutput: 1\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\n\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n-\\\",\\\"basename\\\":\\\"clone-graph\\\"},\\\"combination-sum-ii\\\":{\\\"title\\\":\\\"Combination Sum II\\\",\\\"description\\\":\\\"Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.\\\",\\\"tags\\\":[\\\"medium\\\",\\\"backtracking\\\"],\\\"link\\\":null,\\\"images\\\":[],\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nGiven a collection of candidate numbers (`candidates`) and a target number (`target`), find all unique combinations in `candidates` where the candidate numbers sum to target.\\\\r\\\\n\\\\r\\\\nEach number in candidates may only be used **once** in the combination.\\\\r\\\\n\\\\r\\\\n**Note**: The solution set must not contain duplicate combinations.\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: candidates = [10,1,2,7,6,1,5], target = 8\\\\r\\\\nOutput: \\\\r\\\\n[\\\\r\\\\n[1,1,6],\\\\r\\\\n[1,2,5],\\\\r\\\\n[1,7],\\\\r\\\\n[2,6]\\\\r\\\\n]\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: candidates = [2,5,2,1,2], target = 5\\\\r\\\\nOutput: \\\\r\\\\n[\\\\r\\\\n[1,2,2],\\\\r\\\\n[5]\\\\r\\\\n]\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n- 1 <= candidates.length <= 100 \\\\r\\\\n- 1 <= candidates[i] <= 50 \\\\r\\\\n- 1 <= target <= 30\\\",\\\"basename\\\":\\\"combination-sum-ii\\\"},\\\"combination-sum\\\":{\\\"title\\\":\\\"Combination Sum\\\",\\\"description\\\":\\\"The test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input.\\\",\\\"tags\\\":[\\\"medium\\\",\\\"backtracking\\\"],\\\"link\\\":\\\"https://leetcode.com/problems/combination-sum/\\\",\\\"images\\\":[],\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nGiven an array of **distinct** integers candidates and a target integer target, return a list of all **unique combinations** of candidates where the chosen numbers sum to target. You may return the combinations in **any order**.\\\\r\\\\n\\\\r\\\\nThe **same** number may be chosen from candidates an **unlimited number of times**. Two combinations are unique if the frequency of at least one of the chosen numbers is different.\\\\r\\\\n\\\\r\\\\nThe test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input.\\\\r\\\\n\\\\r\\\\n \\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: candidates = [2,3,6,7], target = 7\\\\r\\\\nOutput: [[2,2,3],[7]]\\\\r\\\\nExplanation:\\\\r\\\\n2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\\\\r\\\\n7 is a candidate, and 7 = 7.\\\\r\\\\nThese are the only two combinations.\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: candidates = [2,3,5], target = 8\\\\r\\\\nOutput: [[2,2,2,2],[2,3,3],[3,5]]\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n- 1 <= candidates.length <= 30\\\\r\\\\n- 2 <= candidates[i] <= 40\\\\r\\\\n- All elements of candidates are distinct.\\\\r\\\\n- 1 <= target <= 40\\\",\\\"basename\\\":\\\"combination-sum\\\"},\\\"construct-binary-tree-from-preorder-and-inorder-traversal\\\":{\\\"title\\\":\\\"Construct Binary Tree from Preorder and Inorder Traversal\\\",\\\"description\\\":\\\"Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.\\\",\\\"tags\\\":[\\\"medium\\\",\\\"binary-tree\\\"],\\\"link\\\":\\\"https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/\\\",\\\"images\\\":[\\\"https://assets.leetcode.com/uploads/2021/02/19/tree.jpg\\\"],\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nGiven two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n![](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg)\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]\\\\r\\\\nOutput: [3,9,20,null,null,15,7]\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: preorder = [-1], inorder = [-1]\\\\r\\\\nOutput: [-1]\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n- 1 <= preorder.length <= 3000 \\\\r\\\\n- inorder.length == preorder.length\\\\r\\\\n- -3000 <= preorder[i], inorder[i] <= 3000 \\\\r\\\\n- preorder and inorder consist of unique values. \\\\r\\\\n- Each value of inorder also appears in preorder. \\\\r\\\\n- preorder is guaranteed to be the preorder traversal of the tree. \\\\r\\\\n- inorder is guaranteed to be the inorder traversal of the tree.\\\",\\\"basename\\\":\\\"construct-binary-tree-from-preorder-and-inorder-traversal\\\"},\\\"container-with-most-water\\\":{\\\"title\\\":\\\"Container With Most Water\\\",\\\"description\\\":\\\"A container with most water example\\\",\\\"tags\\\":[\\\"two-pointers\\\",\\\"medium\\\"],\\\"images\\\":[\\\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg\\\"],\\\"preview\\\":\\\"## Container With Most Water\\\\r\\\\n\\\\r\\\\nYou are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\\\\r\\\\n\\\\r\\\\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\\\\r\\\\n\\\\r\\\\nReturn the maximum amount of water a container can store.\\\\r\\\\n\\\\r\\\\nNotice that you may not slant the container.\\\\r\\\\n\\\\r\\\\n![](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg)\\\\r\\\\n\\\\r\\\\n\\\\r\\\\n```\\\\r\\\\nInput: height = [1,8,6,2,5,4,8,3,7]\\\\r\\\\nOutput: 49\\\\r\\\\nExplanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n\\\\r\\\\n```\\\\r\\\\nInput: height = [1,1]\\\\r\\\\nOutput: 1\\\\r\\\\n```\\\",\\\"basename\\\":\\\"container-with-most-water\\\"},\\\"copy-list-with-random-pointer\\\":{\\\"title\\\":\\\"Copy List with Random Pointer\\\",\\\"description\\\":\\\"A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null.\\\",\\\"tags\\\":[\\\"medium\\\",\\\"linked-list\\\"],\\\"link\\\":\\\"https://leetcode.com/problems/copy-list-with-random-pointer/\\\",\\\"images\\\":[\\\"https://assets.leetcode.com/uploads/2019/12/18/e1.png\\\",\\\"https://assets.leetcode.com/uploads/2019/12/18/e2.png\\\",\\\"https://assets.leetcode.com/uploads/2019/12/18/e3.png\\\"],\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nA linked list of length `n` is given such that each node contains an additional random pointer, which could point to any node in the list, or `null`.\\\\r\\\\n\\\\r\\\\nConstruct a deep copy of the list. The deep copy should consist of exactly n **brand new **nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. **None of the pointers in the new list should point to nodes in the original list.**\\\\r\\\\n\\\\r\\\\nFor example, if there are two nodes X and Y in the original list, where X.random --> Y, then for the corresponding two nodes x and y in the copied list, x.random --> y.\\\\r\\\\n\\\\r\\\\nReturn the head of the copied linked list.\\\\r\\\\n\\\\r\\\\nThe linked list is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where:\\\\r\\\\n\\\\r\\\\n- `val`: an integer representing `Node.val`\\\\r\\\\n- `random_index`: the index of the node (range from `0` to `n-1`) that the `random pointer` points to, or null if it does not point to any node.\\\\r\\\\n\\\\r\\\\nYour code will **only** be given the head of the original linked list.\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n![](https://assets.leetcode.com/uploads/2019/12/18/e1.png)\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\\\\r\\\\nOutput: [[7,null],[13,0],[11,4],[10,2],[1,0]]\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n\\\\r\\\\n![](https://assets.leetcode.com/uploads/2019/12/18/e2.png)\\\\r\\\\n\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: head = [[1,1],[2,1]]\\\\r\\\\nOutput: [[1,1],[2,1]]\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 3\\\\r\\\\n\\\\r\\\\n![](https://assets.leetcode.com/uploads/2019/12/18/e3.png)\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: head = [[3,null],[3,0],[3,null]]\\\\r\\\\nOutput: [[3,null],[3,0],[3,null]]\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n- 0 <= n <= 1000\\\\r\\\\n- -104 <= Node.val <= 104\\\\r\\\\n- Node.random is null or is pointing to some node in the linked list.\\\",\\\"basename\\\":\\\"copy-list-with-random-pointer\\\"},\\\"count-good-nodes-in-binary-tree\\\":{\\\"title\\\":\\\"Count Good Nodes in Binary Tree\\\",\\\"description\\\":\\\"Given a binary tree root, a node X in the tree is named good if in the path from root to X there are no nodes with a value greater than X.\\\",\\\"tags\\\":[\\\"medium\\\",\\\"binary-tree\\\"],\\\"link\\\":\\\"https://leetcode.com/problems/count-good-nodes-in-binary-tree/\\\",\\\"images\\\":[\\\"https://assets.leetcode.com/uploads/2020/04/02/test_sample_1.png\\\",\\\"https://assets.leetcode.com/uploads/2020/04/02/test_sample_2.png\\\"],\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nGiven a binary tree root, a node X in the tree is named good if in the path from root to X there are no nodes with a value greater than X.\\\\r\\\\n\\\\r\\\\nReturn the number of **good** nodes in the binary tree.\\\\r\\\\n\\\\r\\\\n \\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n![](https://assets.leetcode.com/uploads/2020/04/02/test_sample_1.png)\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: root = [3,1,4,3,null,1,5]\\\\r\\\\nOutput: 4\\\\r\\\\n\\\\r\\\\n\\\\r\\\\nExplanation: Nodes in blue are good.\\\\r\\\\nRoot Node (3) is always a good node.\\\\r\\\\nNode 4 -> (3,4) is the maximum value in the path starting from the root.\\\\r\\\\nNode 5 -> (3,4,5) is the maximum value in the path\\\\r\\\\nNode 3 -> (3,1,3) is the maximum value in the path.\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n\\\\r\\\\n![](https://assets.leetcode.com/uploads/2020/04/02/test_sample_2.png)\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: root = [3,3,null,4,2]\\\\r\\\\nOutput: 3\\\\r\\\\nExplanation: Node 2 -> (3, 3, 2) is not good, because \\\\\\\"3\\\\\\\" is higher than it.\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 3\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: root = [1]\\\\r\\\\nOutput: 1\\\\r\\\\nExplanation: Root is considered as good.\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n- The number of nodes in the binary tree is in the range [1, 10^5]. \\\\r\\\\n- Each node's value is between [-10^4, 10^4].\\\",\\\"basename\\\":\\\"count-good-nodes-in-binary-tree\\\"},\\\"course-schedule-ii\\\":{\\\"title\\\":\\\"Course Schedule II\\\",\\\"description\\\":\\\"Return the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.\\\",\\\"tags\\\":[\\\"medium\\\",\\\"graph\\\",\\\"topological-sort\\\"],\\\"link\\\":\\\"https://leetcode.com/problems/course-schedule-ii/\\\",\\\"images\\\":[],\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nThere are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where `prerequisites[i] = [ai, bi]` indicates that you must take course bi first if you want to take course ai.\\\\r\\\\n\\\\r\\\\nFor example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\\\\r\\\\nReturn the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return **an empty array**.\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: numCourses = 2, prerequisites = [[1,0]]\\\\r\\\\nOutput: [0,1]\\\\r\\\\nExplanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]\\\\r\\\\nOutput: [0,2,1,3]\\\\r\\\\nExplanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.\\\\r\\\\nSo one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 3\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: numCourses = 1, prerequisites = []\\\\r\\\\nOutput: [0]\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n- 1 <= numCourses <= 2000 \\\\r\\\\n- 0 <= prerequisites.length <= numCourses * (numCourses - 1)\\\\r\\\\n- prerequisites[i].length == 2 \\\\r\\\\n- 0 <= ai, bi < numCourses \\\\r\\\\n- ai != bi \\\\r\\\\n- All the pairs [ai, bi] are distinct.\\\",\\\"basename\\\":\\\"course-schedule-ii\\\"},\\\"course-schedule\\\":{\\\"title\\\":\\\"Course Schedule\\\",\\\"description\\\":\\\"Return true if you can finish all courses. Otherwise, return false.\\\",\\\"tags\\\":[\\\"medium\\\",\\\"graph\\\",\\\"topological-sort\\\"],\\\"link\\\":\\\"https://leetcode.com/problems/course-schedule/\\\",\\\"images\\\":[],\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nThere are a total of `numCourses` courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where `prerequisites[i] = [ai, bi]` indicates that you **must** take course bi first if you want to take course ai.\\\\r\\\\n\\\\r\\\\nFor example, the pair `[0, 1]`, indicates that to take course 0 you have to first take course 1.\\\\r\\\\nReturn true if you can finish all courses. Otherwise, return `false`.\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: numCourses = 2, prerequisites = [[1,0]]\\\\r\\\\nOutput: true\\\\r\\\\nExplanation: There are a total of 2 courses to take. \\\\r\\\\nTo take course 1 you should have finished course 0. So it is possible.\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: numCourses = 2, prerequisites = [[1,0],[0,1]]\\\\r\\\\nOutput: false\\\\r\\\\nExplanation: There are a total of 2 courses to take. \\\\r\\\\nTo take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n- 1 <= numCourses <= 2000 \\\\r\\\\n- 0 <= prerequisites.length <= 5000 \\\\r\\\\n- prerequisites[i].length == 2 \\\\r\\\\n- 0 <= ai, bi < numCourses \\\\r\\\\n- All the pairs prerequisites[i] are unique.\\\",\\\"basename\\\":\\\"course-schedule\\\"},\\\"daily-temperatures\\\":{\\\"title\\\":\\\"Daily Temperatures\\\",\\\"description\\\":\\\"Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.\\\",\\\"tags\\\":[\\\"medium\\\",\\\"stack\\\",\\\"sliding-window\\\"],\\\"link\\\":\\\"https://leetcode.com/problems/daily-temperatures/\\\",\\\"images\\\":[],\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nGiven an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: temperatures = [73,74,75,71,69,72,76,73]\\\\r\\\\nOutput: [1,1,4,2,1,1,0,0]\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: temperatures = [30,40,50,60]\\\\r\\\\nOutput: [1,1,1,0]\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n-     1 <= temperatures.length <= 105\\\\r\\\\n-     30 <= temperatures[i] <= 100\\\",\\\"basename\\\":\\\"daily-temperatures\\\"},\\\"design-add-and-search-words-data-structure\\\":{\\\"title\\\":\\\"Design Add and Search Words Data Structure\\\",\\\"description\\\":\\\"Design a data structure that supports adding new words and finding if a string matches any previously added string.\\\",\\\"tags\\\":[\\\"medium\\\",\\\"trie\\\"],\\\"link\\\":\\\"https://leetcode.com/problems/design-add-and-search-words-data-structure/\\\",\\\"images\\\":[],\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nDesign a data structure that supports adding new words and finding if a string matches any previously added string.\\\\r\\\\n\\\\r\\\\nImplement the `WordDictionary` class:\\\\r\\\\n\\\\r\\\\n- WordDictionary() Initializes the object.\\\\r\\\\n- void addWord(word) Adds word to the data structure, it can be matched later.\\\\r\\\\n- bool search(word) Returns true if there is any string in the data structure that matches word or false otherwise. word may contain dots '.' where dots can be matched with any letter.\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput\\\\r\\\\n[\\\\\\\"WordDictionary\\\\\\\",\\\\\\\"addWord\\\\\\\",\\\\\\\"addWord\\\\\\\",\\\\\\\"addWord\\\\\\\",\\\\\\\"search\\\\\\\",\\\\\\\"search\\\\\\\",\\\\\\\"search\\\\\\\",\\\\\\\"search\\\\\\\"]\\\\r\\\\n[[],[\\\\\\\"bad\\\\\\\"],[\\\\\\\"dad\\\\\\\"],[\\\\\\\"mad\\\\\\\"],[\\\\\\\"pad\\\\\\\"],[\\\\\\\"bad\\\\\\\"],[\\\\\\\".ad\\\\\\\"],[\\\\\\\"b..\\\\\\\"]]\\\\r\\\\nOutput\\\\r\\\\n[null,null,null,null,false,true,true,true]\\\\r\\\\n\\\\r\\\\nExplanation\\\\r\\\\nWordDictionary wordDictionary = new WordDictionary();\\\\r\\\\nwordDictionary.addWord(\\\\\\\"bad\\\\\\\");\\\\r\\\\nwordDictionary.addWord(\\\\\\\"dad\\\\\\\");\\\\r\\\\nwordDictionary.addWord(\\\\\\\"mad\\\\\\\");\\\\r\\\\nwordDictionary.search(\\\\\\\"pad\\\\\\\"); // return False\\\\r\\\\nwordDictionary.search(\\\\\\\"bad\\\\\\\"); // return True\\\\r\\\\nwordDictionary.search(\\\\\\\".ad\\\\\\\"); // return True\\\\r\\\\nwordDictionary.search(\\\\\\\"b..\\\\\\\"); // return True\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n- 1 <= word.length <= 25\\\\r\\\\n- word in addWord consists of lowercase English letters.\\\\r\\\\n- word in search consist of '.' or lowercase English letters.\\\\r\\\\n- There will be at most 3 dots in word for search queries.\\\\r\\\\n- At most 104 calls will be made to addWord and search.\\\",\\\"basename\\\":\\\"design-add-and-search-words-data-structure\\\"},\\\"design-twitter\\\":{\\\"title\\\":\\\"Design Twitter\\\",\\\"description\\\":\\\"https://leetcode.com/problems/design-twitter/\\\",\\\"tags\\\":[\\\"medium\\\",\\\"heap\\\"],\\\"link\\\":\\\"https://leetcode.com/problems/design-twitter/\\\",\\\"images\\\":[],\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nDesign a simplified version of Twitter where users can post tweets, follow/unfollow another user, and is able to see the 10 most recent tweets in the user's news feed.\\\\r\\\\n\\\\r\\\\nImplement the `Twitter` class:\\\\r\\\\n\\\\r\\\\n- Twitter() Initializes your twitter object.\\\\r\\\\n- void postTweet(int userId, int tweetId) Composes a new tweet with ID tweetId by the user userId. Each call to this function will be made with a unique tweetId.\\\\r\\\\n- List<Integer> getNewsFeed(int userId) Retrieves the 10 most recent tweet IDs in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user themself. Tweets must be ordered from most recent to least recent.\\\\r\\\\n- void follow(int followerId, int followeeId) The user with ID followerId started following the user with ID followeeId.\\\\r\\\\n- void unfollow(int followerId, int followeeId) The user with ID followerId started unfollowing the user with ID followeeId.\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput\\\\r\\\\n[\\\\\\\"Twitter\\\\\\\", \\\\\\\"postTweet\\\\\\\", \\\\\\\"getNewsFeed\\\\\\\", \\\\\\\"follow\\\\\\\", \\\\\\\"postTweet\\\\\\\", \\\\\\\"getNewsFeed\\\\\\\", \\\\\\\"unfollow\\\\\\\", \\\\\\\"getNewsFeed\\\\\\\"]\\\\r\\\\n[[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]\\\\r\\\\nOutput\\\\r\\\\n[null, null, [5], null, null, [6, 5], null, [5]]\\\\r\\\\n\\\\r\\\\nExplanation\\\\r\\\\nTwitter twitter = new Twitter();\\\\r\\\\ntwitter.postTweet(1, 5); // User 1 posts a new tweet (id = 5).\\\\r\\\\ntwitter.getNewsFeed(1);  // User 1's news feed should return a list with 1 tweet id -> [5]. return [5]\\\\r\\\\ntwitter.follow(1, 2);    // User 1 follows user 2.\\\\r\\\\ntwitter.postTweet(2, 6); // User 2 posts a new tweet (id = 6).\\\\r\\\\ntwitter.getNewsFeed(1);  // User 1's news feed should return a list with 2 tweet ids -> [6, 5]. Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.\\\\r\\\\ntwitter.unfollow(1, 2);  // User 1 unfollows user 2.\\\\r\\\\ntwitter.getNewsFeed(1);  // User 1's news feed should return a list with 1 tweet id -> [5], since user 1 is no longer following user 2.\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\n\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n- 1 <= userId, followerId, followeeId <= 500\\\\r\\\\n- 0 <= tweetId <= 10^4\\\\r\\\\n- All the tweets have unique IDs.\\\\r\\\\n- At most 3 * 10^4 calls will be made to postTweet, getNewsFeed, follow, and unfollow.\\\",\\\"basename\\\":\\\"design-twitter\\\"},\\\"diameter-of-binary-tree\\\":{\\\"title\\\":\\\"Diameter of Binary Tree\\\",\\\"description\\\":\\\"Given the root of a binary tree, return the length of the diameter of the tree.\\\",\\\"tags\\\":[\\\"easy\\\",\\\"binary-tree\\\"],\\\"link\\\":\\\"https://leetcode.com/problems/diameter-of-binary-tree/\\\",\\\"images\\\":[\\\"https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg\\\"],\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nGiven the `root` of a binary tree, return the **length** of the diameter of the tree.\\\\r\\\\n\\\\r\\\\nThe **diameter** of a binary tree is the **length** of the longest path between any two nodes in a tree. This path may or may not pass through the root.\\\\r\\\\n\\\\r\\\\nThe **length** of a path between two nodes is represented by the number of edges between them.\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n![](https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg)\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: root = [1,2,3,4,5]\\\\r\\\\nOutput: 3\\\\r\\\\nExplanation: 3 is the length of the path [4,2,1,3] or [5,2,1,3].\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: root = [1,2]\\\\r\\\\nOutput: 1\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n- The number of nodes in the tree is in the range [1, 104]. \\\\r\\\\n- -100 <= Node.val <= 100\\\",\\\"basename\\\":\\\"diameter-of-binary-tree\\\"},\\\"evaluate-polish-reverse-notation\\\":{\\\"title\\\":\\\"Evaluate Reverse Polish Notation\\\",\\\"description\\\":\\\"You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation.  Evaluate the expression. Return an integer that represents the value of the expression.\\\",\\\"tags\\\":[\\\"medium\\\",\\\"stack\\\"],\\\"link\\\":\\\"https://leetcode.com/problems/evaluate-reverse-polish-notation/\\\",\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nYou are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation.\\\\r\\\\n\\\\r\\\\nEvaluate the expression. Return an integer that represents the value of the expression.\\\\r\\\\n\\\\r\\\\nNote that:\\\\r\\\\n\\\\r\\\\n    The valid operators are '+', '-', '*', and '/'.\\\\r\\\\n    Each operand may be an integer or another expression.\\\\r\\\\n    The division between two integers always truncates toward zero.\\\\r\\\\n    There will not be any division by zero.\\\\r\\\\n    The input represents a valid arithmetic expression in a reverse polish notation.\\\\r\\\\n    The answer and all the intermediate calculations can be represented in a 32-bit integer.\\\\r\\\\n\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: tokens = [\\\\\\\"2\\\\\\\",\\\\\\\"1\\\\\\\",\\\\\\\"+\\\\\\\",\\\\\\\"3\\\\\\\",\\\\\\\"*\\\\\\\"]\\\\r\\\\nOutput: 9\\\\r\\\\nExplanation: ((2 + 1) * 3) = 9\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: tokens = [\\\\\\\"4\\\\\\\",\\\\\\\"13\\\\\\\",\\\\\\\"5\\\\\\\",\\\\\\\"/\\\\\\\",\\\\\\\"+\\\\\\\"]\\\\r\\\\nOutput: 6\\\\r\\\\nExplanation: (4 + (13 / 5)) = 6\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n- 1 <= tokens.length <= 104\\\\r\\\\n- tokens[i] is either an operator: \\\\\\\"+\\\\\\\", \\\\\\\"-\\\\\\\", \\\\\\\"*\\\\\\\", or \\\\\\\"/\\\\\\\", or an integer in the range [-200, 200].\\\",\\\"basename\\\":\\\"evaluate-polish-reverse-notation\\\"},\\\"find-median-from-data-stream\\\":{\\\"title\\\":\\\"Find Median from Data Stream\\\",\\\"description\\\":\\\"The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.\\\",\\\"tags\\\":[\\\"hard\\\",\\\"heap\\\"],\\\"link\\\":\\\"https://leetcode.com/problems/find-median-from-data-stream/\\\",\\\"images\\\":[],\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nThe **median** is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.\\\\r\\\\n\\\\r\\\\n- For example, for arr = [2,3,4], the median is 3.\\\\r\\\\n- For example, for arr = [2,3], the median is (2 + 3) / 2 = 2.5.\\\\r\\\\n\\\\r\\\\nImplement the MedianFinder class:\\\\r\\\\n\\\\r\\\\n- MedianFinder() initializes the MedianFinder object.\\\\r\\\\n- void addNum(int num) adds the integer num from the data stream to the data structure.\\\\r\\\\n- double findMedian() returns the median of all elements so far. Answers within 10-5 of the actual answer will be accepted.\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput\\\\r\\\\n[\\\\\\\"MedianFinder\\\\\\\", \\\\\\\"addNum\\\\\\\", \\\\\\\"addNum\\\\\\\", \\\\\\\"findMedian\\\\\\\", \\\\\\\"addNum\\\\\\\", \\\\\\\"findMedian\\\\\\\"]\\\\r\\\\n[[], [1], [2], [], [3], []]\\\\r\\\\nOutput\\\\r\\\\n[null, null, null, 1.5, null, 2.0]\\\\r\\\\n\\\\r\\\\nExplanation\\\\r\\\\nMedianFinder medianFinder = new MedianFinder();\\\\r\\\\nmedianFinder.addNum(1);    // arr = [1]\\\\r\\\\nmedianFinder.addNum(2);    // arr = [1, 2]\\\\r\\\\nmedianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2)\\\\r\\\\nmedianFinder.addNum(3);    // arr[1, 2, 3]\\\\r\\\\nmedianFinder.findMedian(); // return 2.0\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n- -10^5 <= num <= 10^5 \\\\r\\\\n- There will be at least one element in the data structure before calling findMedian. \\\\r\\\\n- At most 5 * 10^4 calls will be made to addNum and findMedian.\\\\r\\\\n\\\\r\\\\n\\\\r\\\\n### Follow up:\\\\r\\\\n\\\\r\\\\n- If all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?\\\\r\\\\n- If 99% of all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?\\\",\\\"basename\\\":\\\"find-median-from-data-stream\\\"},\\\"find-min\\\":{\\\"title\\\":\\\"Find Minimum in Rotated Sorted Array\\\",\\\"description\\\":\\\"Given the sorted rotated array nums of unique elements, return the minimum element of this array.\\\",\\\"tags\\\":[\\\"medium\\\",\\\"binary-search\\\"],\\\"link\\\":\\\"https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/\\\",\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nSuppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:\\\\r\\\\n\\\\r\\\\n    `[4,5,6,7,0,1,2]` if it was rotated 4 times.\\\\r\\\\n    `[0,1,2,4,5,6,7]` if it was rotated 7 times.\\\\r\\\\n\\\\r\\\\nNotice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].\\\\r\\\\n\\\\r\\\\nGiven the sorted rotated array nums of unique elements, return the minimum element of this array.\\\\r\\\\n\\\\r\\\\nYou must write an algorithm that runs in O(log n) time.\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: nums = [3,4,5,1,2]\\\\r\\\\nOutput: 1\\\\r\\\\nExplanation: The original array was [1,2,3,4,5] rotated 3 times.\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: nums = [4,5,6,7,0,1,2]\\\\r\\\\nOutput: 0\\\\r\\\\nExplanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n-      n == nums.length     \\\\r\\\\n-      1 <= n <= 5000     \\\\r\\\\n-      -5000 <= nums[i] <= 5000     \\\\r\\\\n-      All the integers of nums are unique.     \\\\r\\\\n-      nums is sorted and rotated between 1 and n times.\\\",\\\"basename\\\":\\\"find-min\\\"},\\\"find-the-duplicate-number\\\":{\\\"title\\\":\\\"Find the Duplicate Number\\\",\\\"description\\\":\\\"Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.\\\",\\\"tags\\\":[\\\"medium\\\",\\\"linked-list\\\"],\\\"link\\\":\\\"https://leetcode.com/problems/find-the-duplicate-number/\\\",\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nGiven an array of integers nums containing `n + 1` integers where each integer is in the range `[1, n]` inclusive.\\\\r\\\\n\\\\r\\\\nThere is only **one repeated number** in nums, return this repeated number.\\\\r\\\\n\\\\r\\\\nYou must solve the problem **without** modifying the array nums and uses only constant extra space.\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: nums = [1,3,4,2,2]\\\\r\\\\nOutput: 2\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: nums = [3,1,3,4,2]\\\\r\\\\nOutput: 3\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n- 1 <= n <= 10^5 \\\\r\\\\n- nums.length == n + 1 \\\\r\\\\n- 1 <= nums[i] <= n \\\\r\\\\n- All the integers in nums appear only **once** except for **precisely one** **integer** which appears **two or more** times.\\\",\\\"basename\\\":\\\"find-the-duplicate-number\\\"},\\\"generate-parenthesis\\\":{\\\"title\\\":\\\"Generate Parentheses\\\",\\\"description\\\":\\\"Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\\\",\\\"tags\\\":[\\\"medium\\\",\\\"stack\\\",\\\"backtracking\\\"],\\\"link\\\":null,\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nGiven n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: n = 3\\\\r\\\\nOutput: [\\\\\\\"((()))\\\\\\\",\\\\\\\"(()())\\\\\\\",\\\\\\\"(())()\\\\\\\",\\\\\\\"()(())\\\\\\\",\\\\\\\"()()()\\\\\\\"]\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: n = 1\\\\r\\\\nOutput: [\\\\\\\"()\\\\\\\"]\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n- 1 <= n <= 8\\\",\\\"basename\\\":\\\"generate-parenthesis\\\"},\\\"hello-world\\\":{\\\"title\\\":\\\"Hello World\\\",\\\"description\\\":\\\"A simple hello world example\\\",\\\"tags\\\":[\\\"sample\\\"],\\\"preview\\\":\\\"This is  a simple hello world example.\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\n$ dsa run hello-world.js\\\\r\\\\n```\\\",\\\"basename\\\":\\\"hello-world\\\"},\\\"implement-trie-prefix-tree\\\":{\\\"title\\\":\\\"Trie\\\",\\\"description\\\":\\\"A trie (pronounced as \\\\\\\"try\\\\\\\") or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.\\\",\\\"tags\\\":[\\\"medium\\\",\\\"trie\\\"],\\\"link\\\":\\\"https://leetcode.com/problems/implement-trie-prefix-tree/\\\",\\\"images\\\":[],\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nA trie (pronounced as \\\\\\\"try\\\\\\\") or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.\\\\r\\\\n\\\\r\\\\nImplement the Trie class:\\\\r\\\\n\\\\r\\\\n- Trie() Initializes the trie object.\\\\r\\\\n- void insert(String word) Inserts the string word into the trie.\\\\r\\\\n- boolean search(String word) Returns true if the string word is in the trie (i.e., was inserted before), and false otherwise.\\\\r\\\\n- boolean startsWith(String prefix) Returns true if there is a previously nserted string word that has the prefix prefix, and false otherwise.\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput\\\\r\\\\n[\\\\\\\"Trie\\\\\\\", \\\\\\\"insert\\\\\\\", \\\\\\\"search\\\\\\\", \\\\\\\"search\\\\\\\", \\\\\\\"startsWith\\\\\\\", \\\\\\\"insert\\\\\\\", \\\\\\\"search\\\\\\\"]\\\\r\\\\n[[], [\\\\\\\"apple\\\\\\\"], [\\\\\\\"apple\\\\\\\"], [\\\\\\\"app\\\\\\\"], [\\\\\\\"app\\\\\\\"], [\\\\\\\"app\\\\\\\"], [\\\\\\\"app\\\\\\\"]]\\\\r\\\\nOutput\\\\r\\\\n[null, null, true, false, true, null, true]\\\\r\\\\n\\\\r\\\\nExplanation\\\\r\\\\nTrie trie = new Trie();\\\\r\\\\ntrie.insert(\\\\\\\"apple\\\\\\\");\\\\r\\\\ntrie.search(\\\\\\\"apple\\\\\\\");   // return True\\\\r\\\\ntrie.search(\\\\\\\"app\\\\\\\");     // return False\\\\r\\\\ntrie.startsWith(\\\\\\\"app\\\\\\\"); // return True\\\\r\\\\ntrie.insert(\\\\\\\"app\\\\\\\");\\\\r\\\\ntrie.search(\\\\\\\"app\\\\\\\");     // return True\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n- 1 <= word.length, prefix.length <= 2000 \\\\r\\\\n- word and prefix consist only of lowercase English letters. \\\\r\\\\n- At most 3 * 104 calls in total will be made to insert, search, and startsWith.\\\",\\\"basename\\\":\\\"implement-trie-prefix-tree\\\"},\\\"index\\\":{\\\"preview\\\":\\\"const { getFilesInDirectory, getDirAbsoluteUri } = require('../functions');\\\\r\\\\nconst md2json = require('markdown-to-json');\\\\r\\\\nconst fs = require('fs');\\\\r\\\\n\\\\r\\\\nconst DEBUG = false;\\\\r\\\\nconst PROMPT_FILE = 'prompt.json';\\\\r\\\\n\\\\r\\\\nconst options = {\\\\r\\\\n    minify: false,\\\\r\\\\n    width: DEBUG ? 0 : 9000000,\\\\r\\\\n    outfile: null,\\\\r\\\\n};\\\\r\\\\n\\\\r\\\\n\\\\r\\\\n/**\\\\r\\\\n * Creates a compiled json file from all the markdown files in the prompt directory\\\\r\\\\n */\\\\r\\\\nconst createCompiledJson = () => {\\\\r\\\\n    let parsed_prompt_dict = {};\\\\r\\\\n\\\\r\\\\n    getFilesInDirectory('./prompt/')\\\\r\\\\n        .then((files) => {\\\\r\\\\n            const absolutePathForFiles = files.map((file) => {\\\\r\\\\n                return getDirAbsoluteUri(file, './prompt/');\\\\r\\\\n            });\\\\r\\\\n            if (DEBUG) console.log(\\\\\\\"absolutePathForFiles: \\\\\\\", absolutePathForFiles);\\\\r\\\\n            const promptsData = md2json.parse(absolutePathForFiles, options);\\\\r\\\\n            if (DEBUG) console.log(promptsData);\\\\r\\\\n            parsed_prompt_dict = JSON.parse(promptsData);\\\\r\\\\n            // Object.values(parsed_prompt_dict).map((prompt) => {\\\\r\\\\n\\\\r\\\\n            //     prompt.preview\\\\r\\\\n            // });\\\\r\\\\n            // console.log(\\\\\\\"promptsData: \\\\\\\", parsed_prompt_dict);\\\\r\\\\n\\\\r\\\\n\\\\r\\\\n\\\\r\\\\n            // Save as a json\\\\r\\\\n            const json = JSON.stringify(parsed_prompt_dict);\\\\r\\\\n            const prompt_file_path = getDirAbsoluteUri(PROMPT_FILE, './prompt/');\\\\r\\\\n            fs.writeFile(prompt_file_path, json, (err) => {\\\\r\\\\n                if (err) throw err;\\\\r\\\\n                console.log('The file has been saved!');\\\\r\\\\n            });\\\\r\\\\n        })\\\\r\\\\n        .catch((error) => {\\\\r\\\\n            console.error(error);\\\\r\\\\n        });\\\\r\\\\n};\\\\r\\\\n\\\\r\\\\n\\\\r\\\\nconst getLatestModified = async () => {\\\\r\\\\n    const files = await getFilesInDirectory('./prompt/');\\\\r\\\\n    let latestModified = null;\\\\r\\\\n    let latestFile = null;\\\\r\\\\n\\\\r\\\\n    const absolutePathForFiles = files.map((file) => {\\\\r\\\\n        return getDirAbsoluteUri(file, './prompt/');\\\\r\\\\n    });\\\\r\\\\n    for (const file of absolutePathForFiles) {\\\\r\\\\n        const stats = await fs.promises.stat(file);\\\\r\\\\n        if (!latestModified || stats.mtime > latestModified) {\\\\r\\\\n            latestModified = stats.mtime;\\\\r\\\\n            latestFile = file;\\\\r\\\\n        }\\\\r\\\\n    }\\\\r\\\\n\\\\r\\\\n    return latestFile;\\\\r\\\\n};\\\\r\\\\n\\\\r\\\\n/**\\\\r\\\\n * Checks if prompt.json exists, if not, creates it, then returns the parsed json\\\\r\\\\n * @param {String} prompt_slug - The slug of the prompt to return, if empty, returns all prompts\\\\r\\\\n * @returns {Object} parsed_prompt_dict\\\\r\\\\n */\\\\r\\\\nconst getPromptDict = async (prompt_slug = \\\\\\\"\\\\\\\") => {\\\\r\\\\n    // check if prompt.json exists\\\\r\\\\n    const prompt_file_path = getDirAbsoluteUri(PROMPT_FILE, './prompt/');\\\\r\\\\n    if (!fs.existsSync(prompt_file_path)) {\\\\r\\\\n        createCompiledJson();\\\\r\\\\n    }\\\\r\\\\n\\\\r\\\\n    // If exists, check if it's the latest modified file, if not, update the prompt.json\\\\r\\\\n    const latestModified = await getLatestModified();\\\\r\\\\n\\\\r\\\\n    let parsed_prompt_dict;\\\\r\\\\n    if (latestModified !== prompt_file_path) {\\\\r\\\\n        console.log(\\\\\\\"latestModified: \\\\\\\", latestModified);\\\\r\\\\n        createCompiledJson();\\\\r\\\\n    }\\\\r\\\\n    try {\\\\r\\\\n        parsed_prompt_dict = require(prompt_file_path);\\\\r\\\\n    }\\\\r\\\\n    catch (e) {\\\\r\\\\n        // Delete the prompt.json file and try again\\\\r\\\\n        fs.unlinkSync(prompt_file_path);\\\\r\\\\n        // If it fails this time exit and print\\\\r\\\\n        try{\\\\r\\\\n            parsed_prompt_dict = require(prompt_file_path);\\\\r\\\\n        \\\\r\\\\n        }\\\\r\\\\n        catch (e) {\\\\r\\\\n            console.error(\\\\\\\"Error: \\\\\\\", e);\\\\r\\\\n            process.exit(1);\\\\r\\\\n        }\\\\r\\\\n    }\\\\r\\\\n\\\\r\\\\n\\\\r\\\\n    if (prompt_slug === \\\\\\\"\\\\\\\") {\\\\r\\\\n        return parsed_prompt_dict;\\\\r\\\\n    }\\\\r\\\\n    return parsed_prompt_dict[prompt_slug];\\\\r\\\\n};\\\\r\\\\n\\\\r\\\\n\\\\r\\\\n\\\\r\\\\n\\\\r\\\\n(async () => {\\\\r\\\\n    const sample = await getPromptDict();\\\\r\\\\n    if (DEBUG) console.log(\\\\\\\"sample: \\\\\\\", sample);\\\\r\\\\n}\\\\r\\\\n)();\\\\r\\\\n\\\\r\\\\nmodule.exports = { getPromptDict, createCompiledJson };\\\\r\\\\n\\\\r\\\\n\\\\r\\\\n// const parsed_prompt_dict = require(PROMPT_FILE);\\\\r\\\\n// module.exports = parsed_prompt_dict;\\\",\\\"basename\\\":\\\"index\\\"},\\\"invert-binary-tree\\\":{\\\"title\\\":\\\"Invert Binary Tree\\\",\\\"description\\\":\\\"Given the `root` of a binary tree, invert the tree, and return its root.\\\",\\\"tags\\\":[\\\"easy\\\",\\\"binary-tree\\\"],\\\"link\\\":\\\"https://leetcode.com/problems/invert-binary-tree/\\\",\\\"images\\\":[\\\"https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg\\\",\\\"https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg\\\"],\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nGiven the root of a binary tree, invert the tree, and return its root.\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n![](https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg)\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: root = [4,2,7,1,3,6,9]\\\\r\\\\nOutput: [4,7,2,9,6,3,1]\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n\\\\r\\\\n![](https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg)\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: root = [2,1,3]\\\\r\\\\nOutput: [2,3,1]\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 3\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: root = []\\\\r\\\\nOutput: []\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n- The number of nodes in the tree is in the range [0, 100]. \\\\r\\\\n- -100 <= Node.val <= 100\\\",\\\"basename\\\":\\\"invert-binary-tree\\\"},\\\"k-closest\\\":{\\\"title\\\":\\\"k closest points to origin\\\",\\\"description\\\":\\\"Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane and an integer k, return the k closest points to the origin (0, 0).\\\",\\\"tags\\\":[\\\"medium\\\",\\\"heap\\\"],\\\"link\\\":\\\"https://leetcode.com/problems/k-closest-points-to-origin/\\\",\\\"images\\\":[\\\"https://assets.leetcode.com/uploads/2021/03/03/closestplane1.jpg\\\"],\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nGiven an array of points where `points[i] = [xi, yi]` represents a point on the **X-Y** plane and an integer k, return the k closest points to the origin (0, 0).\\\\r\\\\n\\\\r\\\\nThe distance between two points on the X-Y plane is the Euclidean distance (i.e., âˆš(x1 - x2)2 + (y1 - y2)2).\\\\r\\\\n\\\\r\\\\nYou may return the answer in **any order**. The answer is **guaranteed** to be **unique** (except for the order that it is in).\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n![](https://assets.leetcode.com/uploads/2021/03/03/closestplane1.jpg)\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: points = [[1,3],[-2,2]], k = 1\\\\r\\\\nOutput: [[-2,2]]\\\\r\\\\nExplanation:\\\\r\\\\nThe distance between (1, 3) and the origin is sqrt(10).\\\\r\\\\nThe distance between (-2, 2) and the origin is sqrt(8).\\\\r\\\\nSince sqrt(8) < sqrt(10), (-2, 2) is closer to the origin.\\\\r\\\\nWe only want the closest k = 1 points from the origin, so the answer is just [[-2,2]].\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: points = [[3,3],[5,-1],[-2,4]], k = 2\\\\r\\\\nOutput: [[3,3],[-2,4]]\\\\r\\\\nExplanation: The answer [[-2,4],[3,3]] would also be accepted.\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n- 1 <= k <= points.length <= 104\\\\r\\\\n- -104 < xi, yi < 104\\\",\\\"basename\\\":\\\"k-closest\\\"},\\\"key-based-value-store\\\":{\\\"title\\\":\\\"Time Based Key-value Store\\\",\\\"description\\\":\\\"Design a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the key's value at a certain timestamp.\\\",\\\"tags\\\":[\\\"medium\\\",\\\"binary-search\\\"],\\\"link\\\":\\\"https://leetcode.com/problems/time-based-key-value-store/\\\",\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nDesign a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the key's value at a certain timestamp.\\\\r\\\\n\\\\r\\\\nImplement the TimeMap class:\\\\r\\\\n\\\\r\\\\n- `TimeMap()` Initializes the object of the data structure\\\\r\\\\n- `void set(String key, String value, int timestamp)` Stores the key `key` with the value `value` at the given time timestamp.\\\\r\\\\n- `String get(String key, int timestamp)` Returns a value such that set was called previously, with `timestamp_prev <= timestamp`. If there are multiple such values, it returns the value associated with the largest `timestamp_prev`. If there are no values, it returns `\\\\\\\"\\\\\\\"`.\\\\r\\\\n\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput\\\\r\\\\n[\\\\\\\"TimeMap\\\\\\\", \\\\\\\"set\\\\\\\", \\\\\\\"get\\\\\\\", \\\\\\\"get\\\\\\\", \\\\\\\"set\\\\\\\", \\\\\\\"get\\\\\\\", \\\\\\\"get\\\\\\\"]\\\\r\\\\n[[], [\\\\\\\"foo\\\\\\\", \\\\\\\"bar\\\\\\\", 1], [\\\\\\\"foo\\\\\\\", 1], [\\\\\\\"foo\\\\\\\", 3], [\\\\\\\"foo\\\\\\\", \\\\\\\"bar2\\\\\\\", 4], [\\\\\\\"foo\\\\\\\", 4], [\\\\\\\"foo\\\\\\\", 5]]\\\\r\\\\nOutput\\\\r\\\\n[null, null, \\\\\\\"bar\\\\\\\", \\\\\\\"bar\\\\\\\", null, \\\\\\\"bar2\\\\\\\", \\\\\\\"bar2\\\\\\\"]\\\\r\\\\n\\\\r\\\\nExplanation\\\\r\\\\nTimeMap timeMap = new TimeMap();\\\\r\\\\ntimeMap.set(\\\\\\\"foo\\\\\\\", \\\\\\\"bar\\\\\\\", 1);  // store the key \\\\\\\"foo\\\\\\\" and value \\\\\\\"bar\\\\\\\" along with timestamp = 1.\\\\r\\\\ntimeMap.get(\\\\\\\"foo\\\\\\\", 1);         // return \\\\\\\"bar\\\\\\\"\\\\r\\\\ntimeMap.get(\\\\\\\"foo\\\\\\\", 3);         // return \\\\\\\"bar\\\\\\\", since there is no value corresponding to foo at timestamp 3 and timestamp 2, then the only value is at timestamp 1 is \\\\\\\"bar\\\\\\\".\\\\r\\\\ntimeMap.set(\\\\\\\"foo\\\\\\\", \\\\\\\"bar2\\\\\\\", 4); // store the key \\\\\\\"foo\\\\\\\" and value \\\\\\\"bar2\\\\\\\" along with timestamp = 4.\\\\r\\\\ntimeMap.get(\\\\\\\"foo\\\\\\\", 4);         // return \\\\\\\"bar2\\\\\\\"\\\\r\\\\ntimeMap.get(\\\\\\\"foo\\\\\\\", 5);         // return \\\\\\\"bar2\\\\\\\"\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n-      1 <= key.length, value.length <= 100     \\\\r\\\\n-      key and value consist of lowercase English letters and digits.     \\\\r\\\\n-      1 <= timestamp <= 107     \\\\r\\\\n-      All the timestamps timestamp of set are strictly increasing.     \\\\r\\\\n-      At most 2 * 105 calls will be made to set and get.\\\",\\\"basename\\\":\\\"key-based-value-store\\\"},\\\"koko-eating-bananas\\\":{\\\"title\\\":\\\"koko-eating-bananas\\\",\\\"description\\\":\\\"Return the minimum integer k such that she can eat all the bananas within h hours.\\\",\\\"tags\\\":[\\\"medium\\\",\\\"binary-search\\\"],\\\"link\\\":\\\"https://leetcode.com/problems/koko-eating-bananas/\\\",\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nKoko loves to eat bananas. There are `n` piles of bananas, the ith pile has `piles[i]` bananas. The guards have gone and will come back in `h` hours.\\\\r\\\\n\\\\r\\\\nKoko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.\\\\r\\\\n\\\\r\\\\nKoko likes to eat slowly but still wants to finish eating all the bananas before the guards return.\\\\r\\\\n\\\\r\\\\nReturn the minimum integer `k` such that she can eat all the bananas within `h` hours.\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: piles = [3,6,7,11], h = 8\\\\r\\\\nOutput: 4\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: piles = [30,11,23,4,20], h = 5\\\\r\\\\nOutput: 30\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 3\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: piles = [30,11,23,4,20], h = 6\\\\r\\\\nOutput: 23\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n-      1 <= piles.length <= 104     \\\\r\\\\n-      piles.length <= h <= 109     \\\\r\\\\n-      1 <= piles[i] <= 109\\\",\\\"basename\\\":\\\"koko-eating-bananas\\\"},\\\"kth-largest-element-in-an-array\\\":{\\\"title\\\":\\\"kth largest elements in a stream\\\",\\\"description\\\":\\\"Given an integer array nums and an integer k, return the kth largest element in the array.\\\",\\\"tags\\\":[\\\"medium\\\",\\\"heap\\\"],\\\"link\\\":\\\"https://leetcode.com/problems/kth-largest-element-in-an-array/\\\",\\\"images\\\":[],\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nGiven an integer array nums and an integer `k`, return the `kth` largest element in the array.\\\\r\\\\n\\\\r\\\\nNote that it is the `kth` largest element in the sorted order, not the `kth` distinct element.\\\\r\\\\n\\\\r\\\\nYou must solve it in `O(n)` time complexity.\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: nums = [3,2,1,5,6,4], k = 2\\\\r\\\\nOutput: 5\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: nums = [3,2,3,1,2,4,5,5,6], k = 4\\\\r\\\\nOutput: 4\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n- 1 <= k <= nums.length <= 10^5 \\\\r\\\\n- -10^4 <= nums[i] <= 10^4\\\",\\\"basename\\\":\\\"kth-largest-element-in-an-array\\\"},\\\"kth-smallest-element-in-a-bst\\\":{\\\"title\\\":\\\"Kth Smallest Element in a BST\\\",\\\"description\\\":\\\"Given the root of a binary search tree, and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree.\\\",\\\"tags\\\":[\\\"medium\\\",\\\"binary-tree\\\"],\\\"link\\\":\\\"https://leetcode.com/problems/kth-smallest-element-in-a-bst/\\\",\\\"images\\\":[\\\"https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg\\\",\\\"https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg\\\"],\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nGiven the `root` of a binary search tree, and an integer k, return the kth smallest value (**1-indexed**) of all the values of the nodes in the tree.\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n![](https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg)\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: root = [3,1,4,null,2], k = 1\\\\r\\\\nOutput: 1\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n\\\\r\\\\n![](https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg)\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: root = [5,3,6,2,4,null,null,1], k = 3\\\\r\\\\nOutput: 3\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n- The number of nodes in the tree is n.\\\\r\\\\n- 1 <= k <= n <= 104\\\\r\\\\n- 0 <= Node.val <= 104\\\",\\\"basename\\\":\\\"kth-smallest-element-in-a-bst\\\"},\\\"largest-rectangle-area\\\":{\\\"title\\\":\\\"Largest Rectangle in Histogram\\\",\\\"description\\\":\\\"Given an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.\\\",\\\"tags\\\":[\\\"medium\\\",\\\"stack\\\"],\\\"link\\\":\\\"https://leetcode.com/problems/largest-rectangle-in-histogram/\\\",\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nGiven an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n![image](https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg)\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: heights = [2,1,5,6,2,3]\\\\r\\\\nOutput: 10\\\\r\\\\nExplanation: The above is a histogram where width of each bar is 1.\\\\r\\\\nThe largest rectangle is shown in the red area, which has an area = 10 units.\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n\\\\r\\\\n![image](https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg)\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: heights = [2,4]\\\\r\\\\nOutput: 4\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n-      1 <= heights.length <= 105     \\\\r\\\\n-      0 <= heights[i] <= 104\\\",\\\"basename\\\":\\\"largest-rectangle-area\\\"},\\\"last-stone-weight\\\":{\\\"title\\\":\\\"Last Stone Weight\\\",\\\"description\\\":\\\"You are given an array of integers stones where stones[i] is the weight of the ith stone.\\\",\\\"tags\\\":[\\\"easy\\\",\\\"heap\\\"],\\\"link\\\":\\\"https://leetcode.com/problems/last-stone-weight/\\\",\\\"images\\\":[],\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nYou are given an array of integers stones where `stones[i]` is the weight of the ith stone.\\\\r\\\\n\\\\r\\\\nWe are playing a game with the stones. On each turn, we choose the **heaviest two stones** and smash them together. Suppose the heaviest two stones have weights x and y with x <= y. The result of this smash is:\\\\r\\\\n\\\\r\\\\n- If x == y, both stones are destroyed, and\\\\r\\\\n- If x != y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x.\\\\r\\\\nAt the end of the game, there is **at most one** stone left.\\\\r\\\\n\\\\r\\\\nReturn the weight of the last remaining stone. If there are no stones left, return 0.\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: stones = [2,7,4,1,8,1]\\\\r\\\\nOutput: 1\\\\r\\\\nExplanation: \\\\r\\\\nWe combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then,\\\\r\\\\nwe combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then,\\\\r\\\\nwe combine 2 and 1 to get 1 so the array converts to [1,1,1] then,\\\\r\\\\nwe combine 1 and 1 to get 0 so the array converts to [1] then that's the value of the last stone.\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: stones = [1]\\\\r\\\\nOutput: 1\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n- 1 <= stones.length <= 30 \\\\r\\\\n- 1 <= stones[i] <= 1000\\\",\\\"basename\\\":\\\"last-stone-weight\\\"},\\\"length-of-longest-substring\\\":{\\\"title\\\":\\\"Length of Longest Substring\\\",\\\"description\\\":\\\"Given a string s, find the length of the longest substring without repeating characters.\\\",\\\"tags\\\":[\\\"medium\\\",\\\"sliding-window\\\"],\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nGiven a string s, find the length of the longest substring without repeating characters.\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: s = \\\\\\\"abcabcbb\\\\\\\"\\\\r\\\\nOutput: 3\\\\r\\\\nExplanation: The answer is \\\\\\\"abc\\\\\\\", with the length of 3.\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n```bash\\\\r\\\\nInput: s = \\\\\\\"bbbbb\\\\\\\"\\\\r\\\\nOutput: 1\\\\r\\\\nExplanation: The answer is \\\\\\\"b\\\\\\\", with the length of 1.\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 3\\\\r\\\\n```bash\\\\r\\\\nInput: s = \\\\\\\"pwwkew\\\\\\\"\\\\r\\\\nOutput: 3\\\\r\\\\nExplanation: The answer is \\\\\\\"wke\\\\\\\", with the length of 3.\\\\r\\\\nNotice that the answer must be a substring, \\\\\\\"pwke\\\\\\\" is a subsequence and not a substring.\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n- 0 <= s.length <= 5 * 104\\\\r\\\\n- s consists of English letters, digits, symbols and spaces.\\\",\\\"basename\\\":\\\"length-of-longest-substring\\\"},\\\"letter-combinations-of-a-phone-number\\\":{\\\"title\\\":\\\"Palindrome Partitioning\\\",\\\"description\\\":\\\"Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.\\\",\\\"tags\\\":[\\\"hard\\\",\\\"backtracking\\\"],\\\"link\\\":\\\"https://leetcode.com/problems/letter-combinations-of-a-phone-number/\\\",\\\"images\\\":[],\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nGiven a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in **any order**.\\\\r\\\\nA mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n![Example 1](https://assets.leetcode.com/uploads/2022/03/15/1200px-telephone-keypad2svg.png)\\\\r\\\\n\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: digits = \\\\\\\"23\\\\\\\"\\\\r\\\\nOutput: [\\\\\\\"ad\\\\\\\",\\\\\\\"ae\\\\\\\",\\\\\\\"af\\\\\\\",\\\\\\\"bd\\\\\\\",\\\\\\\"be\\\\\\\",\\\\\\\"bf\\\\\\\",\\\\\\\"cd\\\\\\\",\\\\\\\"ce\\\\\\\",\\\\\\\"cf\\\\\\\"]\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: digits = \\\\\\\"\\\\\\\"\\\\r\\\\nOutput: []\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 3\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: digits = \\\\\\\"2\\\\\\\"\\\\r\\\\nOutput: [\\\\\\\"a\\\\\\\",\\\\\\\"b\\\\\\\",\\\\\\\"c\\\\\\\"]\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n- 0 <= digits.length <= 4\\\\r\\\\n- digits[i] is a digit in the range ['2', '9']\\\",\\\"basename\\\":\\\"letter-combinations-of-a-phone-number\\\"},\\\"linked-list-cycle\\\":{\\\"title\\\":\\\"Linked List Cycle\\\",\\\"description\\\":\\\"Given head, the head of a linked list, determine if the linked list has a cycle in it.\\\",\\\"tags\\\":[\\\"medium\\\",\\\"linked-list\\\"],\\\"link\\\":\\\"https://leetcode.com/problems/linked-list-cycle/\\\",\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nGiven `head`, the head of a linked list, determine if the linked list has a cycle in it.\\\\r\\\\n\\\\r\\\\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. **Note that** pos **is not passed as a parameter**.\\\\r\\\\n\\\\r\\\\nReturn `true` if there is a cycle in the linked list. Otherwise, return `false`.\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: head = [3,2,0,-4], pos = 1\\\\r\\\\nOutput: true\\\\r\\\\nExplanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: head = [1,2], pos = 0\\\\r\\\\nOutput: true\\\\r\\\\nExplanation: There is a cycle in the linked list, where the tail connects to the 0th node.\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n- The number of the nodes in the list is in the range [0, 104]. \\\\r\\\\n- -10^5 <= Node.val <= 10^5 \\\\r\\\\n- pos is -1 or a valid index in the linked-list.\\\",\\\"basename\\\":\\\"linked-list-cycle\\\"},\\\"lru-cache\\\":{\\\"title\\\":\\\"LRU Cache\\\",\\\"description\\\":\\\"Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\\\",\\\"tags\\\":[\\\"medium\\\",\\\"linked-list\\\"],\\\"link\\\":\\\"https://leetcode.com/problems/lru-cache/\\\",\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nDesign a data structure that follows the constraints of a Least Recently Used (LRU) cache.\\\\r\\\\n\\\\r\\\\nImplement the `LRUCache` class:\\\\r\\\\n\\\\r\\\\n- LRUCache(int capacity) Initialize the LRU cache with **positive** size capacity.\\\\r\\\\n- `int get(int key)` Return the value of the key if the key exists, otherwise return -1.\\\\r\\\\n- void `put(int key, int value)` Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, **evict** the least recently used key.\\\\r\\\\n\\\\r\\\\nThe functions get and put must each run in O(1) average time complexity.\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput\\\\r\\\\n[\\\\\\\"LRUCache\\\\\\\", \\\\\\\"put\\\\\\\", \\\\\\\"put\\\\\\\", \\\\\\\"get\\\\\\\", \\\\\\\"put\\\\\\\", \\\\\\\"get\\\\\\\", \\\\\\\"put\\\\\\\", \\\\\\\"get\\\\\\\", \\\\\\\"get\\\\\\\", \\\\\\\"get\\\\\\\"]\\\\r\\\\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\\\\r\\\\nOutput\\\\r\\\\n[null, null, null, 1, null, -1, null, -1, 3, 4]\\\\r\\\\n\\\\r\\\\nExplanation\\\\r\\\\nLRUCache lRUCache = new LRUCache(2);\\\\r\\\\nlRUCache.put(1, 1); // cache is {1=1}\\\\r\\\\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\\\\r\\\\nlRUCache.get(1);    // return 1\\\\r\\\\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\\\\r\\\\nlRUCache.get(2);    // returns -1 (not found)\\\\r\\\\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\\\\r\\\\nlRUCache.get(1);    // return -1 (not found)\\\\r\\\\nlRUCache.get(3);    // return 3\\\\r\\\\nlRUCache.get(4);    // return 4\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n- 1 <= capacity <= 3000\\\\r\\\\n- 0 <= key <= 104\\\\r\\\\n- 0 <= value <= 105\\\\r\\\\n- At most 2 * 105 calls will be made to get and put.\\\",\\\"basename\\\":\\\"lru-cache\\\"},\\\"max-area-of-island\\\":{\\\"title\\\":\\\"Max Area of Island\\\",\\\"description\\\":\\\"You are given an m x n binary matrix grid. An island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.\\\",\\\"tags\\\":[\\\"medium\\\",\\\"graphs\\\"],\\\"link\\\":\\\"https://leetcode.com/problems/max-area-of-island/\\\",\\\"images\\\":[],\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nYou are given an m x n binary matrix grid. An island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.\\\\r\\\\n\\\\r\\\\nThe area of an island is the number of cells with a value 1 in the island.\\\\r\\\\n\\\\r\\\\nReturn the maximum area of an island in grid. If there is no island, return 0.\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n![](https://assets.leetcode.com/uploads/2021/05/01/maxarea1-grid.jpg)\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]\\\\r\\\\nOutput: 6\\\\r\\\\nExplanation: The answer is not 11, because the island must be connected 4-directionally.\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: grid = [[0,0,0,0,0,0,0,0]]\\\\r\\\\nOutput: 0\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n- m == grid.length \\\\r\\\\n- n == grid[i].length \\\\r\\\\n- 1 <= m, n <= 50 \\\\r\\\\n- grid[i][j] is either 0 or 1.\\\",\\\"basename\\\":\\\"max-area-of-island\\\"},\\\"max-profit\\\":{\\\"title\\\":\\\"Max Profit\\\",\\\"description\\\":\\\"Best time to Buy and Sell Stock\\\",\\\"tags\\\":[\\\"easy\\\",\\\"sliding-window\\\"],\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nYou are given an array prices where prices[i] is the price of a given stock on the ith day.\\\\r\\\\n\\\\r\\\\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\\\\r\\\\n\\\\r\\\\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: prices = [7,1,5,3,6,4]\\\\r\\\\nOutput: 5\\\\r\\\\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\\\\r\\\\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: prices = [7,6,4,3,1]\\\\r\\\\nOutput: 0\\\\r\\\\nExplanation: In this case, no transactions are done and the max profit = 0.\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n-  1 <= prices.length <= 105\\\\r\\\\n-  0 <= prices[i] <= 104\\\",\\\"basename\\\":\\\"max-profit\\\"},\\\"max-sliding-window\\\":{\\\"title\\\":\\\"Max Sliding Window\\\",\\\"description\\\":\\\"Sliding Window Maximum\\\",\\\"tags\\\":[\\\"hard\\\",\\\"sliding-window\\\"],\\\"link\\\":\\\"https://leetcode.com/problems/sliding-window-maximum/\\\",\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nYou are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.  Return the max sliding window.\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: nums = [1,3,-1,-3,5,3,6,7], k = 3\\\\r\\\\nOutput: [3,3,5,5,6,7]\\\\r\\\\nExplanation: \\\\r\\\\nWindow position                Max\\\\r\\\\n---------------               -----\\\\r\\\\n[1  3  -1] -3  5  3  6  7       3\\\\r\\\\n 1 [3  -1  -3] 5  3  6  7       3\\\\r\\\\n 1  3 [-1  -3  5] 3  6  7       5\\\\r\\\\n 1  3  -1 [-3  5  3] 6  7       5\\\\r\\\\n 1  3  -1  -3 [5  3  6] 7       6\\\\r\\\\n 1  3  -1  -3  5 [3  6  7]      7\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n```bash\\\\r\\\\nInput: nums = [1], k = 1\\\\r\\\\nOutput: [1]\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n-      1 <= nums.length <= 10^5     \\\\r\\\\n-      -10^4 <= nums[i] <= 10^4     \\\\r\\\\n-      1 <= k <= nums.length\\\",\\\"basename\\\":\\\"max-sliding-window\\\"},\\\"maximum-depth-of-binary-tree\\\":{\\\"title\\\":\\\"Maximum Depth of Binary Tree\\\",\\\"description\\\":\\\"A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\\\",\\\"tags\\\":[\\\"easy\\\",\\\"binary-tree\\\"],\\\"link\\\":\\\"https://leetcode.com/problems/maximum-depth-of-binary-tree/\\\",\\\"images\\\":[\\\"https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg\\\"],\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nGiven the root of a binary tree, return its maximum depth.\\\\r\\\\n\\\\r\\\\nA binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n![](https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg)\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: root = [3,9,20,null,null,15,7]\\\\r\\\\nOutput: 3\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: root = [1,null,2]\\\\r\\\\nOutput: 2\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n- The number of nodes in the tree is in the range [0, 104]. \\\\r\\\\n- -100 <= Node.val <= 100\\\",\\\"basename\\\":\\\"maximum-depth-of-binary-tree\\\"},\\\"median-sorted-arrays\\\":{\\\"title\\\":\\\"Median of Two Sorted Arrays\\\",\\\"description\\\":\\\"Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\\\",\\\"tags\\\":[\\\"hard\\\",\\\"binary-search\\\",\\\"array\\\"],\\\"link\\\":\\\"https://leetcode.com/problems/median-of-two-sorted-arrays/\\\",\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nGiven two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively, return **the median** of the two sorted arrays.\\\\r\\\\n\\\\r\\\\nThe overall run time complexity should be `O(log (m+n))`.\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: nums1 = [1,3], nums2 = [2]\\\\r\\\\nOutput: 2.00000\\\\r\\\\nExplanation: merged array = [1,2,3] and median is 2.\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: nums1 = [1,2], nums2 = [3,4]\\\\r\\\\nOutput: 2.50000\\\\r\\\\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n-      nums1.length == m     \\\\r\\\\n-      nums2.length == n     \\\\r\\\\n-      0 <= m <= 1000     \\\\r\\\\n-      0 <= n <= 1000     \\\\r\\\\n-      1 <= m + n <= 2000     \\\\r\\\\n-      -106 <= nums1[i], nums2[i] <= 106\\\",\\\"basename\\\":\\\"median-sorted-arrays\\\"},\\\"merge-k-sorted-list\\\":{\\\"title\\\":\\\"Merge k Sorted Lists\\\",\\\"description\\\":\\\"You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\\\",\\\"tags\\\":[\\\"hard\\\",\\\"linked-list\\\"],\\\"link\\\":\\\"https://leetcode.com/problems/merge-k-sorted-lists/\\\",\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nYou are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\\\\r\\\\n\\\\r\\\\nMerge all the linked-lists into one sorted linked-list and return it.\\\\r\\\\n\\\\r\\\\n \\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: lists = [[1,4,5],[1,3,4],[2,6]]\\\\r\\\\nOutput: [1,1,2,3,4,4,5,6]\\\\r\\\\nExplanation: The linked-lists are:\\\\r\\\\n[\\\\r\\\\n  1->4->5,\\\\r\\\\n  1->3->4,\\\\r\\\\n  2->6\\\\r\\\\n]\\\\r\\\\nmerging them into one sorted list:\\\\r\\\\n1->1->2->3->4->4->5->6\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\n\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 3\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: lists = [[]]\\\\r\\\\nOutput: []\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n- k == lists.length \\\\r\\\\n- 0 <= k <= 10^4 \\\\r\\\\n- 0 <= lists[i].length <= 500 \\\\r\\\\n- -10^4 <= lists[i][j] <= 10^4 \\\\r\\\\n- lists[i] is sorted in **ascending order**. \\\\r\\\\n- The sum of lists[i].length will not exceed 10^4.\\\",\\\"basename\\\":\\\"merge-k-sorted-list\\\"},\\\"merge-two-sorted-list\\\":{\\\"title\\\":\\\"Merge Two Sorted Lists\\\",\\\"description\\\":\\\"You are given the heads of two sorted linked lists list1 and list2. Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.\\\",\\\"tags\\\":[\\\"easy\\\",\\\"linked-list\\\"],\\\"link\\\":\\\"https://leetcode.com/problems/merge-two-sorted-lists/\\\",\\\"images\\\":[\\\"https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg\\\"],\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nYou are given the heads of two sorted linked lists list1 and list2.\\\\r\\\\n\\\\r\\\\nMerge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.\\\\r\\\\n\\\\r\\\\nReturn the head of the merged linked list.\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n![](https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg)\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: list1 = [1,2,4], list2 = [1,3,4]\\\\r\\\\nOutput: [1,1,2,3,4,4]\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: list1 = [], list2 = []\\\\r\\\\nOutput: []\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 3\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: list1 = [], list2 = [0]\\\\r\\\\nOutput: [0]\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n- The number of nodes in both lists is in the range [0, 50]. \\\\r\\\\n- -100 <= Node.val <= 100 \\\\r\\\\n- Both list1 and list2 are sorted in non-decreasing order.\\\",\\\"basename\\\":\\\"merge-two-sorted-list\\\"},\\\"min-stack\\\":{\\\"title\\\":\\\"Min Stack\\\",\\\"description\\\":\\\"Min Stack\\\",\\\"tags\\\":[\\\"medium\\\",\\\"stack\\\"],\\\"link\\\":\\\"https://leetcode.com/problems/min-stack/\\\",\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nDesign a stack that supports push, pop, top, and retrieving the minimum element in constant time.\\\\r\\\\n\\\\r\\\\nImplement the MinStack class:\\\\r\\\\n\\\\r\\\\n    MinStack() initializes the stack object.\\\\r\\\\n    void push(int val) pushes the element val onto the stack.\\\\r\\\\n    void pop() removes the element on the top of the stack.\\\\r\\\\n    int top() gets the top element of the stack.\\\\r\\\\n    int getMin() retrieves the minimum element in the stack.\\\\r\\\\n\\\\r\\\\nYou must implement a solution with O(1) time complexity for each function.\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n```bash\\\\r\\\\nInput\\\\r\\\\n[\\\\\\\"MinStack\\\\\\\",\\\\\\\"push\\\\\\\",\\\\\\\"push\\\\\\\",\\\\\\\"push\\\\\\\",\\\\\\\"getMin\\\\\\\",\\\\\\\"pop\\\\\\\",\\\\\\\"top\\\\\\\",\\\\\\\"getMin\\\\\\\"]\\\\r\\\\n[[],[-2],[0],[-3],[],[],[],[]]\\\\r\\\\n\\\\r\\\\nOutput\\\\r\\\\n[null,null,null,null,-3,null,0,-2]\\\\r\\\\n\\\\r\\\\nExplanation\\\\r\\\\nMinStack minStack = new MinStack();\\\\r\\\\nminStack.push(-2);\\\\r\\\\nminStack.push(0);\\\\r\\\\nminStack.push(-3);\\\\r\\\\nminStack.getMin(); // return -3\\\\r\\\\nminStack.pop();\\\\r\\\\nminStack.top();    // return 0\\\\r\\\\nminStack.getMin(); // return -2\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n- -2^31 <= val <= 2^31 - 1     \\\\r\\\\n- Methods pop, top and getMin operations will always be called on non-empty stacks.     \\\\r\\\\n- At most 3 * 104 calls will be made to push, pop, top, and getMin.\\\",\\\"basename\\\":\\\"min-stack\\\"},\\\"min-window\\\":{\\\"title\\\":\\\"Min Window Substring\\\",\\\"description\\\":\\\"Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \\\\\\\"\\\\\\\".\\\",\\\"tags\\\":[\\\"hard\\\",\\\"sliding-window\\\"],\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nGiven two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \\\\\\\"\\\\\\\".\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n```bash\\\\r\\\\nInput: s = \\\\\\\"ADOBECODEBANC\\\\\\\", t = \\\\\\\"ABC\\\\\\\"\\\\r\\\\nOutput: \\\\\\\"BANC\\\\\\\"\\\\r\\\\nExplanation: The minimum window substring \\\\\\\"BANC\\\\\\\" includes 'A', 'B', and 'C' from string t.\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n```bash\\\\r\\\\nInput: s = \\\\\\\"a\\\\\\\", t = \\\\\\\"a\\\\\\\"\\\\r\\\\nOutput: \\\\\\\"a\\\\\\\"\\\\r\\\\nExplanation: The entire string s is the minimum window.\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 3\\\\r\\\\n```bash\\\\r\\\\nInput: s = \\\\\\\"a\\\\\\\", t = \\\\\\\"aa\\\\\\\"\\\\r\\\\nOutput: \\\\\\\"\\\\\\\"\\\\r\\\\nExplanation: Both 'a's from t must be included in the window.\\\\r\\\\nSince the largest window of s only has one 'a', return empty string.\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n-      m == s.length     \\\\r\\\\n-      n == t.length     \\\\r\\\\n-      1 <= m, n <= 105     \\\\r\\\\n-      s and t consist of uppercase and lowercase English letters.\\\",\\\"basename\\\":\\\"min-window\\\"},\\\"n-queens\\\":{\\\"title\\\":\\\"N-Queens\\\",\\\"description\\\":\\\"The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\\\",\\\"tags\\\":[\\\"hard\\\",\\\"backtracking\\\"],\\\"link\\\":\\\"https://leetcode.com/problems/n-queens/\\\",\\\"images\\\":[],\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nThe **n-queens** puzzle is the problem of placing n queens on an `n x n` chessboard such that no two queens attack each other.\\\\r\\\\n\\\\r\\\\nGiven an integer n, return all distinct solutions to the **n-queens puzzle**. You may return the answer in **any order**.\\\\r\\\\n\\\\r\\\\nEach solution contains a distinct board configuration of the n-queens' placement, where `'Q'` and `'.'` both indicate a queen and an empty space, respectively.\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n![](https://assets.leetcode.com/uploads/2020/11/13/queens.jpg)\\\\r\\\\n\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: n = 4\\\\r\\\\nOutput: [[\\\\\\\".Q..\\\\\\\",\\\\\\\"...Q\\\\\\\",\\\\\\\"Q...\\\\\\\",\\\\\\\"..Q.\\\\\\\"],[\\\\\\\"..Q.\\\\\\\",\\\\\\\"Q...\\\\\\\",\\\\\\\"...Q\\\\\\\",\\\\\\\".Q..\\\\\\\"]]\\\\r\\\\nExplanation: There exist two distinct solutions to the 4-queens puzzle as shown above\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: n = 1\\\\r\\\\nOutput: [[\\\\\\\"Q\\\\\\\"]]\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n- `1 <= n <= 9`\\\",\\\"basename\\\":\\\"n-queens\\\"},\\\"number-of-connected-components-in-an-undirected-graph\\\":{\\\"title\\\":\\\"Redundant Connection\\\",\\\"description\\\":\\\"find the number of connected components in an undirected graph.\\\",\\\"tags\\\":[\\\"medium\\\",\\\"graphs\\\"],\\\"link\\\":\\\"https://cheonhyangzhang.gitbooks.io/leetcode-solutions/content/323-number-of-connected-components-in-an-undirected-graph.html\\\",\\\"images\\\":[],\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nGiven n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to find the number of connected components in an undirected graph.\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\n\\\\r\\\\nExample 1:\\\\r\\\\n\\\\r\\\\n     0          3\\\\r\\\\n     |          |\\\\r\\\\n     1 --- 2    4\\\\r\\\\n\\\\r\\\\nGiven n = 5 and edges = [[0, 1], [1, 2], [3, 4]], return 2.\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\n\\\\r\\\\nExample 2:\\\\r\\\\n\\\\r\\\\n     0           4\\\\r\\\\n     |           |\\\\r\\\\n     1 --- 2 --- 3\\\\r\\\\n\\\\r\\\\nGiven n = 5 and edges = [[0, 1], [1, 2], [2, 3], [3, 4]], return 1.\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\nNote:\\\\r\\\\nYou can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges.\\\",\\\"basename\\\":\\\"number-of-connected-components-in-an-undirected-graph\\\"},\\\"number-of-islands\\\":{\\\"title\\\":\\\"Number of Islands\\\",\\\"description\\\":\\\"Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\\\",\\\"tags\\\":[\\\"medium\\\",\\\"graphs\\\"],\\\"link\\\":null,\\\"images\\\":[],\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nGiven an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\\\\r\\\\n\\\\r\\\\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\\\\r\\\\n\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: grid = [\\\\r\\\\n  [\\\\\\\"1\\\\\\\",\\\\\\\"1\\\\\\\",\\\\\\\"1\\\\\\\",\\\\\\\"1\\\\\\\",\\\\\\\"0\\\\\\\"],\\\\r\\\\n  [\\\\\\\"1\\\\\\\",\\\\\\\"1\\\\\\\",\\\\\\\"0\\\\\\\",\\\\\\\"1\\\\\\\",\\\\\\\"0\\\\\\\"],\\\\r\\\\n  [\\\\\\\"1\\\\\\\",\\\\\\\"1\\\\\\\",\\\\\\\"0\\\\\\\",\\\\\\\"0\\\\\\\",\\\\\\\"0\\\\\\\"],\\\\r\\\\n  [\\\\\\\"0\\\\\\\",\\\\\\\"0\\\\\\\",\\\\\\\"0\\\\\\\",\\\\\\\"0\\\\\\\",\\\\\\\"0\\\\\\\"]\\\\r\\\\n]\\\\r\\\\nOutput: 1\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\n\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n-\\\",\\\"basename\\\":\\\"number-of-islands\\\"},\\\"pacific-atlantic-water-flow\\\":{\\\"title\\\":\\\"Pacific Atlantic Water Flow\\\",\\\"description\\\":\\\"There is an m x n rectangular island that borders both the Pacific Ocean and Atlantic Ocean. The Pacific Ocean touches the island's left and top edges, and the Atlantic Ocean touches the island's right and bottom edges.\\\",\\\"tags\\\":[\\\"medium\\\",\\\"graphs\\\"],\\\"link\\\":\\\"https://leetcode.com/problems/pacific-atlantic-water-flow/\\\",\\\"images\\\":[],\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nThere is an m x n rectangular island that borders both the** Pacific Ocean** and Atlantic Ocean. The Pacific Ocean touches the island's left and top edges, and the Atlantic Ocean touches the island's right and bottom edges.\\\\r\\\\n\\\\r\\\\nThe island is partitioned into a grid of square cells. You are given an m x n integer matrix heights where heights[r][c] represents the **height above sea level** of the cell at coordinate (r, c).\\\\r\\\\n\\\\r\\\\nThe island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell's height is **less than or equal to** the current cell's height. Water can flow from any cell adjacent to an ocean into the ocean.\\\\r\\\\n\\\\r\\\\nReturn a **2D list** of grid coordinates result where result[i] = [ri, ci] denotes that rain water can flow from cell (ri, ci) to **both** the Pacific and Atlantic oceans.\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n![](https://assets.leetcode.com/uploads/2021/06/08/waterflow-grid.jpg)\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]\\\\r\\\\nOutput: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]\\\\r\\\\nExplanation: The following cells can flow to the Pacific and Atlantic oceans, as shown below:\\\\r\\\\n[0,4]: [0,4] -> Pacific Ocean \\\\r\\\\n       [0,4] -> Atlantic Ocean\\\\r\\\\n[1,3]: [1,3] -> [0,3] -> Pacific Ocean \\\\r\\\\n       [1,3] -> [1,4] -> Atlantic Ocean\\\\r\\\\n[1,4]: [1,4] -> [1,3] -> [0,3] -> Pacific Ocean \\\\r\\\\n       [1,4] -> Atlantic Ocean\\\\r\\\\n[2,2]: [2,2] -> [1,2] -> [0,2] -> Pacific Ocean \\\\r\\\\n       [2,2] -> [2,3] -> [2,4] -> Atlantic Ocean\\\\r\\\\n[3,0]: [3,0] -> Pacific Ocean \\\\r\\\\n       [3,0] -> [4,0] -> Atlantic Ocean\\\\r\\\\n[3,1]: [3,1] -> [3,0] -> Pacific Ocean \\\\r\\\\n       [3,1] -> [4,1] -> Atlantic Ocean\\\\r\\\\n[4,0]: [4,0] -> Pacific Ocean \\\\r\\\\n       [4,0] -> Atlantic Ocean\\\\r\\\\nNote that there are other possible paths for these cells to flow to the Pacific and Atlantic oceans.\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: heights = [[1]]\\\\r\\\\nOutput: [[0,0]]\\\\r\\\\nExplanation: The water can flow from the only cell to the Pacific and Atlantic oceans.\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n- m == heights.length\\\\r\\\\n- n == heights[r].length\\\\r\\\\n- 1 <= m, n <= 200\\\\r\\\\n- 0 <= heights[r][c] <= 10^5\\\",\\\"basename\\\":\\\"pacific-atlantic-water-flow\\\"},\\\"palindrome-partitioning\\\":{\\\"title\\\":\\\"Palindrome Partitioning\\\",\\\"description\\\":\\\"Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s.\\\",\\\"tags\\\":[],\\\"link\\\":\\\"https://leetcode.com/problems/palindrome-partitioning/\\\",\\\"images\\\":[],\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nGiven a string `s`, partition `s` such that every substring of the partition is a **palindrome**. Return all possible palindrome partitioning of `s`.\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: s = \\\\\\\"aab\\\\\\\"\\\\r\\\\nOutput: [[\\\\\\\"a\\\\\\\",\\\\\\\"a\\\\\\\",\\\\\\\"b\\\\\\\"],[\\\\\\\"aa\\\\\\\",\\\\\\\"b\\\\\\\"]]\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: s = \\\\\\\"a\\\\\\\"\\\\r\\\\nOutput: [[\\\\\\\"a\\\\\\\"]]\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n- 1 <= s.length <= 16 \\\\r\\\\n- `s` contains only lowercase English letters.\\\",\\\"basename\\\":\\\"palindrome-partitioning\\\"},\\\"permutations\\\":{\\\"title\\\":\\\"Permutations\\\",\\\"description\\\":\\\"Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.\\\",\\\"tags\\\":[\\\"medium\\\",\\\"backtracking\\\"],\\\"link\\\":\\\"https://leetcode.com/problems/permutations/\\\",\\\"images\\\":[],\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nGiven an array `nums` of distinct integers, return all the possible permutations. You can return the answer **in any order**.\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: nums = [1,2,3]\\\\r\\\\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: nums = [0,1]\\\\r\\\\nOutput: [[0,1],[1,0]]\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 3\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: nums = [1]\\\\r\\\\nOutput: [[1]]\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n- 1 <= nums.length <= 6 \\\\r\\\\n- -10 <= nums[i] <= 10 \\\\r\\\\n- All the integers of nums are unique.\\\",\\\"basename\\\":\\\"permutations\\\"},\\\"prompt\\\":{\\\"preview\\\":\\\"{\\\\\\\"add-two-numbers\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Add Two Numbers\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"medium\\\\\\\",\\\\\\\"linked-list\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/add-two-numbers/\\\\\\\",\\\\\\\"images\\\\\\\":[\\\\\\\"https://assets.leetcode.com/uploads/2020/10/02/addtwonumber1.jpg\\\\\\\"],\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/10/02/addtwonumber1.jpg)\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: l1 = [2,4,3], l2 = [5,6,4]\\\\\\\\r\\\\\\\\nOutput: [7,0,8]\\\\\\\\r\\\\\\\\nExplanation: 342 + 465 = 807.\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: l1 = [0], l2 = [0]\\\\\\\\r\\\\\\\\nOutput: [0]\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 3\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\\\\\\\\r\\\\\\\\nOutput: [8,9,9,9,0,0,0,1]\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- The number of nodes in each linked list is in the range [1, 100]. \\\\\\\\r\\\\\\\\n- 0 <= Node.val <= 9 \\\\\\\\r\\\\\\\\n- It is guaranteed that the list represents a number that does not have leading zeros.\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"add-two-numbers\\\\\\\"},\\\\\\\"balanced-binary-tree\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Balanced Binary Tree\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"Given a binary tree, determine if it is height-balanced.\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"easy\\\\\\\",\\\\\\\"binary-tree\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/balanced-binary-tree/\\\\\\\",\\\\\\\"images\\\\\\\":[\\\\\\\"https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg\\\\\\\"],\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nGiven a binary tree, determine if it is height-balanced.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg)\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: root = [3,9,20,null,null,15,7]\\\\\\\\r\\\\\\\\nOutput: true\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg)\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: root = [1,2,2,3,3,null,null,4,4]\\\\\\\\r\\\\\\\\nOutput: false\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 3\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: root = []\\\\\\\\r\\\\\\\\nOutput: true\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- The number of nodes in the tree is in the range [0, 5000]. \\\\\\\\r\\\\\\\\n- -10^4 <= Node.val <= 10^4\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"balanced-binary-tree\\\\\\\"},\\\\\\\"binary-search\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Binary Search\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"medium\\\\\\\",\\\\\\\"binary-search\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/binary-search/\\\\\\\",\\\\\\\"images\\\\\\\":[],\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nGiven an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nYou must write an algorithm with O(log n) runtime complexity.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: nums = [-1,0,3,5,9,12], target = 9\\\\\\\\r\\\\\\\\nOutput: 4\\\\\\\\r\\\\\\\\nExplanation: 9 exists in nums and its index is 4\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: nums = [-1,0,3,5,9,12], target = 2\\\\\\\\r\\\\\\\\nOutput: -1\\\\\\\\r\\\\\\\\nExplanation: 2 does not exist in nums so return -1\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n-     1 <= nums.length <= 104\\\\\\\\r\\\\\\\\n-     -104 < nums[i], target < 104\\\\\\\\r\\\\\\\\n-     All the integers in nums are unique.\\\\\\\\r\\\\\\\\n-     uunums is sorted in ascending order.\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"binary-search\\\\\\\"},\\\\\\\"binary-tree-level-order-traversal\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Binary Tree Level Order Traversal\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"medium\\\\\\\",\\\\\\\"binary-tree\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/binary-tree-level-order-traversal/\\\\\\\",\\\\\\\"images\\\\\\\":[\\\\\\\"https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg\\\\\\\"],\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nGiven the `root` of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n![](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: root = [3,9,20,null,null,15,7]\\\\\\\\r\\\\\\\\nOutput: [[3],[9,20],[15,7]]\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: root = [1]\\\\\\\\r\\\\\\\\nOutput: [[1]]\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- The number of nodes in the tree is in the range [0, 2000]. \\\\\\\\r\\\\\\\\n- -1000 <= Node.val <= 1000\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"binary-tree-level-order-traversal\\\\\\\"},\\\\\\\"binary-tree-maximum-path-sum\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Binary Tree Maximum Path Sum\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"Given the root of a binary tree, return the maximum path sum of any non-empty path.\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"hard\\\\\\\",\\\\\\\"binary-tree\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/binary-tree-maximum-path-sum/\\\\\\\",\\\\\\\"images\\\\\\\":[\\\\\\\"https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg\\\\\\\",\\\\\\\"https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg\\\\\\\"],\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nA path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nThe path sum of a path is the sum of the node's values in the path.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nGiven the root of a binary tree, return the maximum path sum of any non-empty path.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg)\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: root = [1,2,3]\\\\\\\\r\\\\\\\\nOutput: 6\\\\\\\\r\\\\\\\\nExplanation: The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6.\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg)\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: root = [-10,9,20,null,null,15,7]\\\\\\\\r\\\\\\\\nOutput: 42\\\\\\\\r\\\\\\\\nExplanation: The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42.\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- The number of nodes in the tree is in the range [1, 3 * 10^4]. \\\\\\\\r\\\\\\\\n- -1000 <= Node.val <= 1000\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"binary-tree-maximum-path-sum\\\\\\\"},\\\\\\\"binary-tree-right-side-view\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Binary Tree Right Side View\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"medium\\\\\\\",\\\\\\\"binary-tree\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/binary-tree-right-side-view/\\\\\\\",\\\\\\\"images\\\\\\\":[\\\\\\\"https://assets.leetcode.com/uploads/2021/02/14/tree.jpg\\\\\\\"],\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nGiven the `root` of a binary tree, imagine yourself standing on the **right side** of it, return the values of the nodes you can see ordered from top to bottom.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n![](https://assets.leetcode.com/uploads/2021/02/14/tree.jpg)\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: root = [1,2,3,null,5,null,4]\\\\\\\\r\\\\\\\\nOutput: [1,3,4]\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: root = [1,null,3]\\\\\\\\r\\\\\\\\nOutput: [1,3]\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- The number of nodes in the tree is in the range [0, 100]. \\\\\\\\r\\\\\\\\n- -100 <= Node.val <= 100\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"binary-tree-right-side-view\\\\\\\"},\\\\\\\"car-fleet\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Car Fleet\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"There are n cars going to the same destination along a one-lane road. The destination is target miles away.\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"medium\\\\\\\",\\\\\\\"stack\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/car-fleet/\\\\\\\",\\\\\\\"images\\\\\\\":[],\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nThere are `n` cars going to the same destination along a one-lane road. The destination is `target` miles away.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nYou are given two integer array position and speed, both of length n, where position[i] is the position of the ith car and speed[i] is the speed of the ith car (in miles per hour).\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nA car can never pass another car ahead of it, but it can catch up to it and drive bumper to bumper at the same speed. The faster car will slow down to match the slower car's speed. The distance between these two cars is ignored (i.e., they are assumed to have the same position).\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nA car fleet is some non-empty set of cars driving at the same position and same speed. Note that a single car is also a car fleet.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nIf a car catches up to a car fleet right at the destination point, it will still be considered as one car fleet.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nReturn the number of car fleets that will arrive at the destination.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]\\\\\\\\r\\\\\\\\nOutput: 3\\\\\\\\r\\\\\\\\nExplanation:\\\\\\\\r\\\\\\\\nThe cars starting at 10 (speed 2) and 8 (speed 4) become a fleet, meeting each other at 12.\\\\\\\\r\\\\\\\\nThe car starting at 0 does not catch up to any other car, so it is a fleet by itself.\\\\\\\\r\\\\\\\\nThe cars starting at 5 (speed 1) and 3 (speed 3) become a fleet, meeting each other at 6. The fleet moves at speed 1 until it reaches target.\\\\\\\\r\\\\\\\\nNote that no other cars meet these fleets before the destination, so the answer is 3.\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: target = 10, position = [3], speed = [3]\\\\\\\\r\\\\\\\\nOutput: 1\\\\\\\\r\\\\\\\\nExplanation: There is only one car, hence there is only one fleet.\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 3\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: target = 100, position = [0,2,4], speed = [4,2,1]\\\\\\\\r\\\\\\\\nOutput: 1\\\\\\\\r\\\\\\\\nExplanation:\\\\\\\\r\\\\\\\\nThe cars starting at 0 (speed 4) and 2 (speed 2) become a fleet, meeting each other at 4. The fleet moves at speed 2.\\\\\\\\r\\\\\\\\nThen, the fleet (speed 2) and the car starting at 4 (speed 1) become one fleet, meeting each other at 6. The fleet moves at speed 1 until it reaches target.\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n-      n == position.length == speed.length     \\\\\\\\r\\\\\\\\n-      1 <= n <= 105\\\\\\\\r\\\\\\\\n-      0 < target <= 106\\\\\\\\r\\\\\\\\n-      0 <= position[i] < target\\\\\\\\r\\\\\\\\n-      All the values of position are unique.\\\\\\\\r\\\\\\\\n-      0 < speed[i] <= 106\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"car-fleet\\\\\\\"},\\\\\\\"character-replacement\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Character Replacement\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"Longest Repeating Character Replacement\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"medium\\\\\\\",\\\\\\\"sliding-window\\\\\\\"],\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nYou are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nReturn the length of the longest substring containing the same letter you can get after performing the above operations.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: s = \\\\\\\\\\\\\\\"ABAB\\\\\\\\\\\\\\\", k = 2\\\\\\\\r\\\\\\\\nOutput: 4\\\\\\\\r\\\\\\\\nExplanation: Replace the two 'A's with two 'B's or vice versa.\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: s = \\\\\\\\\\\\\\\"AABABBA\\\\\\\\\\\\\\\", k = 1\\\\\\\\r\\\\\\\\nOutput: 4\\\\\\\\r\\\\\\\\nExplanation: Replace the one 'A' in the middle with 'B' and form \\\\\\\\\\\\\\\"AABBBBA\\\\\\\\\\\\\\\".\\\\\\\\r\\\\\\\\nThe substring \\\\\\\\\\\\\\\"BBBB\\\\\\\\\\\\\\\" has the longest repeating letters, which is 4.\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- 1 <= s.length <= 105\\\\\\\\r\\\\\\\\n- s consists of only uppercase English letters.\\\\\\\\r\\\\\\\\n- 0 <= k <= s.length\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"character-replacement\\\\\\\"},\\\\\\\"clone-graph\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Clone Graph\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"medium\\\\\\\",\\\\\\\"graphs\\\\\\\"],\\\\\\\"link\\\\\\\":null,\\\\\\\"images\\\\\\\":[],\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nGiven an `m x n` 2D binary grid `grid` which represents a map of `'1's` (land) and `'0's` (water), return the number of islands.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nAn **island** is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: grid = [\\\\\\\\r\\\\\\\\n  [\\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\"],\\\\\\\\r\\\\\\\\n  [\\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\"],\\\\\\\\r\\\\\\\\n  [\\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\"],\\\\\\\\r\\\\\\\\n  [\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\"]\\\\\\\\r\\\\\\\\n]\\\\\\\\r\\\\\\\\nOutput: 1\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n-\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"clone-graph\\\\\\\"},\\\\\\\"combination-sum-ii\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Combination Sum II\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"medium\\\\\\\",\\\\\\\"backtracking\\\\\\\"],\\\\\\\"link\\\\\\\":null,\\\\\\\"images\\\\\\\":[],\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nGiven a collection of candidate numbers (`candidates`) and a target number (`target`), find all unique combinations in `candidates` where the candidate numbers sum to target.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nEach number in candidates may only be used **once** in the combination.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n**Note**: The solution set must not contain duplicate combinations.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: candidates = [10,1,2,7,6,1,5], target = 8\\\\\\\\r\\\\\\\\nOutput: \\\\\\\\r\\\\\\\\n[\\\\\\\\r\\\\\\\\n[1,1,6],\\\\\\\\r\\\\\\\\n[1,2,5],\\\\\\\\r\\\\\\\\n[1,7],\\\\\\\\r\\\\\\\\n[2,6]\\\\\\\\r\\\\\\\\n]\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: candidates = [2,5,2,1,2], target = 5\\\\\\\\r\\\\\\\\nOutput: \\\\\\\\r\\\\\\\\n[\\\\\\\\r\\\\\\\\n[1,2,2],\\\\\\\\r\\\\\\\\n[5]\\\\\\\\r\\\\\\\\n]\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- 1 <= candidates.length <= 100 \\\\\\\\r\\\\\\\\n- 1 <= candidates[i] <= 50 \\\\\\\\r\\\\\\\\n- 1 <= target <= 30\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"combination-sum-ii\\\\\\\"},\\\\\\\"combination-sum\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Combination Sum\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"The test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input.\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"medium\\\\\\\",\\\\\\\"backtracking\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/combination-sum/\\\\\\\",\\\\\\\"images\\\\\\\":[],\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nGiven an array of **distinct** integers candidates and a target integer target, return a list of all **unique combinations** of candidates where the chosen numbers sum to target. You may return the combinations in **any order**.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nThe **same** number may be chosen from candidates an **unlimited number of times**. Two combinations are unique if the frequency of at least one of the chosen numbers is different.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nThe test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n \\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: candidates = [2,3,6,7], target = 7\\\\\\\\r\\\\\\\\nOutput: [[2,2,3],[7]]\\\\\\\\r\\\\\\\\nExplanation:\\\\\\\\r\\\\\\\\n2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\\\\\\\\r\\\\\\\\n7 is a candidate, and 7 = 7.\\\\\\\\r\\\\\\\\nThese are the only two combinations.\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: candidates = [2,3,5], target = 8\\\\\\\\r\\\\\\\\nOutput: [[2,2,2,2],[2,3,3],[3,5]]\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- 1 <= candidates.length <= 30\\\\\\\\r\\\\\\\\n- 2 <= candidates[i] <= 40\\\\\\\\r\\\\\\\\n- All elements of candidates are distinct.\\\\\\\\r\\\\\\\\n- 1 <= target <= 40\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"combination-sum\\\\\\\"},\\\\\\\"construct-binary-tree-from-preorder-and-inorder-traversal\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Construct Binary Tree from Preorder and Inorder Traversal\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"medium\\\\\\\",\\\\\\\"binary-tree\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/\\\\\\\",\\\\\\\"images\\\\\\\":[\\\\\\\"https://assets.leetcode.com/uploads/2021/02/19/tree.jpg\\\\\\\"],\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nGiven two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n![](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg)\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]\\\\\\\\r\\\\\\\\nOutput: [3,9,20,null,null,15,7]\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: preorder = [-1], inorder = [-1]\\\\\\\\r\\\\\\\\nOutput: [-1]\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- 1 <= preorder.length <= 3000 \\\\\\\\r\\\\\\\\n- inorder.length == preorder.length\\\\\\\\r\\\\\\\\n- -3000 <= preorder[i], inorder[i] <= 3000 \\\\\\\\r\\\\\\\\n- preorder and inorder consist of unique values. \\\\\\\\r\\\\\\\\n- Each value of inorder also appears in preorder. \\\\\\\\r\\\\\\\\n- preorder is guaranteed to be the preorder traversal of the tree. \\\\\\\\r\\\\\\\\n- inorder is guaranteed to be the inorder traversal of the tree.\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"construct-binary-tree-from-preorder-and-inorder-traversal\\\\\\\"},\\\\\\\"container-with-most-water\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Container With Most Water\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"A container with most water example\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"two-pointers\\\\\\\",\\\\\\\"medium\\\\\\\"],\\\\\\\"images\\\\\\\":[\\\\\\\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg\\\\\\\"],\\\\\\\"preview\\\\\\\":\\\\\\\"## Container With Most Water\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nYou are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nReturn the maximum amount of water a container can store.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nNotice that you may not slant the container.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n![](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg)\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\nInput: height = [1,8,6,2,5,4,8,3,7]\\\\\\\\r\\\\\\\\nOutput: 49\\\\\\\\r\\\\\\\\nExplanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\nInput: height = [1,1]\\\\\\\\r\\\\\\\\nOutput: 1\\\\\\\\r\\\\\\\\n```\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"container-with-most-water\\\\\\\"},\\\\\\\"copy-list-with-random-pointer\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Copy List with Random Pointer\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null.\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"medium\\\\\\\",\\\\\\\"linked-list\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/copy-list-with-random-pointer/\\\\\\\",\\\\\\\"images\\\\\\\":[\\\\\\\"https://assets.leetcode.com/uploads/2019/12/18/e1.png\\\\\\\",\\\\\\\"https://assets.leetcode.com/uploads/2019/12/18/e2.png\\\\\\\",\\\\\\\"https://assets.leetcode.com/uploads/2019/12/18/e3.png\\\\\\\"],\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nA linked list of length `n` is given such that each node contains an additional random pointer, which could point to any node in the list, or `null`.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nConstruct a deep copy of the list. The deep copy should consist of exactly n **brand new **nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. **None of the pointers in the new list should point to nodes in the original list.**\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nFor example, if there are two nodes X and Y in the original list, where X.random --> Y, then for the corresponding two nodes x and y in the copied list, x.random --> y.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nReturn the head of the copied linked list.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nThe linked list is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- `val`: an integer representing `Node.val`\\\\\\\\r\\\\\\\\n- `random_index`: the index of the node (range from `0` to `n-1`) that the `random pointer` points to, or null if it does not point to any node.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nYour code will **only** be given the head of the original linked list.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n![](https://assets.leetcode.com/uploads/2019/12/18/e1.png)\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\\\\\\\\r\\\\\\\\nOutput: [[7,null],[13,0],[11,4],[10,2],[1,0]]\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n![](https://assets.leetcode.com/uploads/2019/12/18/e2.png)\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: head = [[1,1],[2,1]]\\\\\\\\r\\\\\\\\nOutput: [[1,1],[2,1]]\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 3\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n![](https://assets.leetcode.com/uploads/2019/12/18/e3.png)\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: head = [[3,null],[3,0],[3,null]]\\\\\\\\r\\\\\\\\nOutput: [[3,null],[3,0],[3,null]]\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- 0 <= n <= 1000\\\\\\\\r\\\\\\\\n- -104 <= Node.val <= 104\\\\\\\\r\\\\\\\\n- Node.random is null or is pointing to some node in the linked list.\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"copy-list-with-random-pointer\\\\\\\"},\\\\\\\"count-good-nodes-in-binary-tree\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Count Good Nodes in Binary Tree\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"Given a binary tree root, a node X in the tree is named good if in the path from root to X there are no nodes with a value greater than X.\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"medium\\\\\\\",\\\\\\\"binary-tree\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/count-good-nodes-in-binary-tree/\\\\\\\",\\\\\\\"images\\\\\\\":[\\\\\\\"https://assets.leetcode.com/uploads/2020/04/02/test_sample_1.png\\\\\\\",\\\\\\\"https://assets.leetcode.com/uploads/2020/04/02/test_sample_2.png\\\\\\\"],\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nGiven a binary tree root, a node X in the tree is named good if in the path from root to X there are no nodes with a value greater than X.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nReturn the number of **good** nodes in the binary tree.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n \\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/04/02/test_sample_1.png)\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: root = [3,1,4,3,null,1,5]\\\\\\\\r\\\\\\\\nOutput: 4\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nExplanation: Nodes in blue are good.\\\\\\\\r\\\\\\\\nRoot Node (3) is always a good node.\\\\\\\\r\\\\\\\\nNode 4 -> (3,4) is the maximum value in the path starting from the root.\\\\\\\\r\\\\\\\\nNode 5 -> (3,4,5) is the maximum value in the path\\\\\\\\r\\\\\\\\nNode 3 -> (3,1,3) is the maximum value in the path.\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/04/02/test_sample_2.png)\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: root = [3,3,null,4,2]\\\\\\\\r\\\\\\\\nOutput: 3\\\\\\\\r\\\\\\\\nExplanation: Node 2 -> (3, 3, 2) is not good, because \\\\\\\\\\\\\\\"3\\\\\\\\\\\\\\\" is higher than it.\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 3\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: root = [1]\\\\\\\\r\\\\\\\\nOutput: 1\\\\\\\\r\\\\\\\\nExplanation: Root is considered as good.\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- The number of nodes in the binary tree is in the range [1, 10^5]. \\\\\\\\r\\\\\\\\n- Each node's value is between [-10^4, 10^4].\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"count-good-nodes-in-binary-tree\\\\\\\"},\\\\\\\"course-schedule-ii\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Course Schedule II\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"Return the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"medium\\\\\\\",\\\\\\\"graph\\\\\\\",\\\\\\\"topological-sort\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/course-schedule-ii/\\\\\\\",\\\\\\\"images\\\\\\\":[],\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nThere are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where `prerequisites[i] = [ai, bi]` indicates that you must take course bi first if you want to take course ai.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nFor example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\\\\\\\\r\\\\\\\\nReturn the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return **an empty array**.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: numCourses = 2, prerequisites = [[1,0]]\\\\\\\\r\\\\\\\\nOutput: [0,1]\\\\\\\\r\\\\\\\\nExplanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]\\\\\\\\r\\\\\\\\nOutput: [0,2,1,3]\\\\\\\\r\\\\\\\\nExplanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.\\\\\\\\r\\\\\\\\nSo one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 3\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: numCourses = 1, prerequisites = []\\\\\\\\r\\\\\\\\nOutput: [0]\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- 1 <= numCourses <= 2000 \\\\\\\\r\\\\\\\\n- 0 <= prerequisites.length <= numCourses * (numCourses - 1)\\\\\\\\r\\\\\\\\n- prerequisites[i].length == 2 \\\\\\\\r\\\\\\\\n- 0 <= ai, bi < numCourses \\\\\\\\r\\\\\\\\n- ai != bi \\\\\\\\r\\\\\\\\n- All the pairs [ai, bi] are distinct.\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"course-schedule-ii\\\\\\\"},\\\\\\\"course-schedule\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Course Schedule\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"Return true if you can finish all courses. Otherwise, return false.\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"medium\\\\\\\",\\\\\\\"graph\\\\\\\",\\\\\\\"topological-sort\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/course-schedule/\\\\\\\",\\\\\\\"images\\\\\\\":[],\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nThere are a total of `numCourses` courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where `prerequisites[i] = [ai, bi]` indicates that you **must** take course bi first if you want to take course ai.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nFor example, the pair `[0, 1]`, indicates that to take course 0 you have to first take course 1.\\\\\\\\r\\\\\\\\nReturn true if you can finish all courses. Otherwise, return `false`.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: numCourses = 2, prerequisites = [[1,0]]\\\\\\\\r\\\\\\\\nOutput: true\\\\\\\\r\\\\\\\\nExplanation: There are a total of 2 courses to take. \\\\\\\\r\\\\\\\\nTo take course 1 you should have finished course 0. So it is possible.\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: numCourses = 2, prerequisites = [[1,0],[0,1]]\\\\\\\\r\\\\\\\\nOutput: false\\\\\\\\r\\\\\\\\nExplanation: There are a total of 2 courses to take. \\\\\\\\r\\\\\\\\nTo take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- 1 <= numCourses <= 2000 \\\\\\\\r\\\\\\\\n- 0 <= prerequisites.length <= 5000 \\\\\\\\r\\\\\\\\n- prerequisites[i].length == 2 \\\\\\\\r\\\\\\\\n- 0 <= ai, bi < numCourses \\\\\\\\r\\\\\\\\n- All the pairs prerequisites[i] are unique.\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"course-schedule\\\\\\\"},\\\\\\\"daily-temperatures\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Daily Temperatures\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"medium\\\\\\\",\\\\\\\"stack\\\\\\\",\\\\\\\"sliding-window\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/daily-temperatures/\\\\\\\",\\\\\\\"images\\\\\\\":[],\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nGiven an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: temperatures = [73,74,75,71,69,72,76,73]\\\\\\\\r\\\\\\\\nOutput: [1,1,4,2,1,1,0,0]\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: temperatures = [30,40,50,60]\\\\\\\\r\\\\\\\\nOutput: [1,1,1,0]\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n-     1 <= temperatures.length <= 105\\\\\\\\r\\\\\\\\n-     30 <= temperatures[i] <= 100\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"daily-temperatures\\\\\\\"},\\\\\\\"design-add-and-search-words-data-structure\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Design Add and Search Words Data Structure\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"Design a data structure that supports adding new words and finding if a string matches any previously added string.\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"medium\\\\\\\",\\\\\\\"trie\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/design-add-and-search-words-data-structure/\\\\\\\",\\\\\\\"images\\\\\\\":[],\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nDesign a data structure that supports adding new words and finding if a string matches any previously added string.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nImplement the `WordDictionary` class:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- WordDictionary() Initializes the object.\\\\\\\\r\\\\\\\\n- void addWord(word) Adds word to the data structure, it can be matched later.\\\\\\\\r\\\\\\\\n- bool search(word) Returns true if there is any string in the data structure that matches word or false otherwise. word may contain dots '.' where dots can be matched with any letter.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput\\\\\\\\r\\\\\\\\n[\\\\\\\\\\\\\\\"WordDictionary\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"addWord\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"addWord\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"addWord\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"search\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"search\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"search\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"search\\\\\\\\\\\\\\\"]\\\\\\\\r\\\\\\\\n[[],[\\\\\\\\\\\\\\\"bad\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\"dad\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\"mad\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\"pad\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\"bad\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\".ad\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\"b..\\\\\\\\\\\\\\\"]]\\\\\\\\r\\\\\\\\nOutput\\\\\\\\r\\\\\\\\n[null,null,null,null,false,true,true,true]\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nExplanation\\\\\\\\r\\\\\\\\nWordDictionary wordDictionary = new WordDictionary();\\\\\\\\r\\\\\\\\nwordDictionary.addWord(\\\\\\\\\\\\\\\"bad\\\\\\\\\\\\\\\");\\\\\\\\r\\\\\\\\nwordDictionary.addWord(\\\\\\\\\\\\\\\"dad\\\\\\\\\\\\\\\");\\\\\\\\r\\\\\\\\nwordDictionary.addWord(\\\\\\\\\\\\\\\"mad\\\\\\\\\\\\\\\");\\\\\\\\r\\\\\\\\nwordDictionary.search(\\\\\\\\\\\\\\\"pad\\\\\\\\\\\\\\\"); // return False\\\\\\\\r\\\\\\\\nwordDictionary.search(\\\\\\\\\\\\\\\"bad\\\\\\\\\\\\\\\"); // return True\\\\\\\\r\\\\\\\\nwordDictionary.search(\\\\\\\\\\\\\\\".ad\\\\\\\\\\\\\\\"); // return True\\\\\\\\r\\\\\\\\nwordDictionary.search(\\\\\\\\\\\\\\\"b..\\\\\\\\\\\\\\\"); // return True\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- 1 <= word.length <= 25\\\\\\\\r\\\\\\\\n- word in addWord consists of lowercase English letters.\\\\\\\\r\\\\\\\\n- word in search consist of '.' or lowercase English letters.\\\\\\\\r\\\\\\\\n- There will be at most 3 dots in word for search queries.\\\\\\\\r\\\\\\\\n- At most 104 calls will be made to addWord and search.\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"design-add-and-search-words-data-structure\\\\\\\"},\\\\\\\"design-twitter\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Design Twitter\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"https://leetcode.com/problems/design-twitter/\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"medium\\\\\\\",\\\\\\\"heap\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/design-twitter/\\\\\\\",\\\\\\\"images\\\\\\\":[],\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nDesign a simplified version of Twitter where users can post tweets, follow/unfollow another user, and is able to see the 10 most recent tweets in the user's news feed.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nImplement the `Twitter` class:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- Twitter() Initializes your twitter object.\\\\\\\\r\\\\\\\\n- void postTweet(int userId, int tweetId) Composes a new tweet with ID tweetId by the user userId. Each call to this function will be made with a unique tweetId.\\\\\\\\r\\\\\\\\n- List<Integer> getNewsFeed(int userId) Retrieves the 10 most recent tweet IDs in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user themself. Tweets must be ordered from most recent to least recent.\\\\\\\\r\\\\\\\\n- void follow(int followerId, int followeeId) The user with ID followerId started following the user with ID followeeId.\\\\\\\\r\\\\\\\\n- void unfollow(int followerId, int followeeId) The user with ID followerId started unfollowing the user with ID followeeId.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput\\\\\\\\r\\\\\\\\n[\\\\\\\\\\\\\\\"Twitter\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"postTweet\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"getNewsFeed\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"follow\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"postTweet\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"getNewsFeed\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"unfollow\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"getNewsFeed\\\\\\\\\\\\\\\"]\\\\\\\\r\\\\\\\\n[[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]\\\\\\\\r\\\\\\\\nOutput\\\\\\\\r\\\\\\\\n[null, null, [5], null, null, [6, 5], null, [5]]\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nExplanation\\\\\\\\r\\\\\\\\nTwitter twitter = new Twitter();\\\\\\\\r\\\\\\\\ntwitter.postTweet(1, 5); // User 1 posts a new tweet (id = 5).\\\\\\\\r\\\\\\\\ntwitter.getNewsFeed(1);  // User 1's news feed should return a list with 1 tweet id -> [5]. return [5]\\\\\\\\r\\\\\\\\ntwitter.follow(1, 2);    // User 1 follows user 2.\\\\\\\\r\\\\\\\\ntwitter.postTweet(2, 6); // User 2 posts a new tweet (id = 6).\\\\\\\\r\\\\\\\\ntwitter.getNewsFeed(1);  // User 1's news feed should return a list with 2 tweet ids -> [6, 5]. Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.\\\\\\\\r\\\\\\\\ntwitter.unfollow(1, 2);  // User 1 unfollows user 2.\\\\\\\\r\\\\\\\\ntwitter.getNewsFeed(1);  // User 1's news feed should return a list with 1 tweet id -> [5], since user 1 is no longer following user 2.\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- 1 <= userId, followerId, followeeId <= 500\\\\\\\\r\\\\\\\\n- 0 <= tweetId <= 10^4\\\\\\\\r\\\\\\\\n- All the tweets have unique IDs.\\\\\\\\r\\\\\\\\n- At most 3 * 10^4 calls will be made to postTweet, getNewsFeed, follow, and unfollow.\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"design-twitter\\\\\\\"},\\\\\\\"diameter-of-binary-tree\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Diameter of Binary Tree\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"Given the root of a binary tree, return the length of the diameter of the tree.\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"easy\\\\\\\",\\\\\\\"binary-tree\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/diameter-of-binary-tree/\\\\\\\",\\\\\\\"images\\\\\\\":[\\\\\\\"https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg\\\\\\\"],\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nGiven the `root` of a binary tree, return the **length** of the diameter of the tree.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nThe **diameter** of a binary tree is the **length** of the longest path between any two nodes in a tree. This path may or may not pass through the root.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nThe **length** of a path between two nodes is represented by the number of edges between them.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n![](https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg)\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: root = [1,2,3,4,5]\\\\\\\\r\\\\\\\\nOutput: 3\\\\\\\\r\\\\\\\\nExplanation: 3 is the length of the path [4,2,1,3] or [5,2,1,3].\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: root = [1,2]\\\\\\\\r\\\\\\\\nOutput: 1\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- The number of nodes in the tree is in the range [1, 104]. \\\\\\\\r\\\\\\\\n- -100 <= Node.val <= 100\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"diameter-of-binary-tree\\\\\\\"},\\\\\\\"evaluate-polish-reverse-notation\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Evaluate Reverse Polish Notation\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation.  Evaluate the expression. Return an integer that represents the value of the expression.\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"medium\\\\\\\",\\\\\\\"stack\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/evaluate-reverse-polish-notation/\\\\\\\",\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nYou are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nEvaluate the expression. Return an integer that represents the value of the expression.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nNote that:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n    The valid operators are '+', '-', '*', and '/'.\\\\\\\\r\\\\\\\\n    Each operand may be an integer or another expression.\\\\\\\\r\\\\\\\\n    The division between two integers always truncates toward zero.\\\\\\\\r\\\\\\\\n    There will not be any division by zero.\\\\\\\\r\\\\\\\\n    The input represents a valid arithmetic expression in a reverse polish notation.\\\\\\\\r\\\\\\\\n    The answer and all the intermediate calculations can be represented in a 32-bit integer.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: tokens = [\\\\\\\\\\\\\\\"2\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"+\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"3\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"*\\\\\\\\\\\\\\\"]\\\\\\\\r\\\\\\\\nOutput: 9\\\\\\\\r\\\\\\\\nExplanation: ((2 + 1) * 3) = 9\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: tokens = [\\\\\\\\\\\\\\\"4\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"13\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"5\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"+\\\\\\\\\\\\\\\"]\\\\\\\\r\\\\\\\\nOutput: 6\\\\\\\\r\\\\\\\\nExplanation: (4 + (13 / 5)) = 6\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- 1 <= tokens.length <= 104\\\\\\\\r\\\\\\\\n- tokens[i] is either an operator: \\\\\\\\\\\\\\\"+\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"-\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"*\\\\\\\\\\\\\\\", or \\\\\\\\\\\\\\\"/\\\\\\\\\\\\\\\", or an integer in the range [-200, 200].\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"evaluate-polish-reverse-notation\\\\\\\"},\\\\\\\"find-median-from-data-stream\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Find Median from Data Stream\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"hard\\\\\\\",\\\\\\\"heap\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/find-median-from-data-stream/\\\\\\\",\\\\\\\"images\\\\\\\":[],\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nThe **median** is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- For example, for arr = [2,3,4], the median is 3.\\\\\\\\r\\\\\\\\n- For example, for arr = [2,3], the median is (2 + 3) / 2 = 2.5.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nImplement the MedianFinder class:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- MedianFinder() initializes the MedianFinder object.\\\\\\\\r\\\\\\\\n- void addNum(int num) adds the integer num from the data stream to the data structure.\\\\\\\\r\\\\\\\\n- double findMedian() returns the median of all elements so far. Answers within 10-5 of the actual answer will be accepted.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput\\\\\\\\r\\\\\\\\n[\\\\\\\\\\\\\\\"MedianFinder\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"addNum\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"addNum\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"findMedian\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"addNum\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"findMedian\\\\\\\\\\\\\\\"]\\\\\\\\r\\\\\\\\n[[], [1], [2], [], [3], []]\\\\\\\\r\\\\\\\\nOutput\\\\\\\\r\\\\\\\\n[null, null, null, 1.5, null, 2.0]\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nExplanation\\\\\\\\r\\\\\\\\nMedianFinder medianFinder = new MedianFinder();\\\\\\\\r\\\\\\\\nmedianFinder.addNum(1);    // arr = [1]\\\\\\\\r\\\\\\\\nmedianFinder.addNum(2);    // arr = [1, 2]\\\\\\\\r\\\\\\\\nmedianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2)\\\\\\\\r\\\\\\\\nmedianFinder.addNum(3);    // arr[1, 2, 3]\\\\\\\\r\\\\\\\\nmedianFinder.findMedian(); // return 2.0\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- -10^5 <= num <= 10^5 \\\\\\\\r\\\\\\\\n- There will be at least one element in the data structure before calling findMedian. \\\\\\\\r\\\\\\\\n- At most 5 * 10^4 calls will be made to addNum and findMedian.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Follow up:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- If all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?\\\\\\\\r\\\\\\\\n- If 99% of all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"find-median-from-data-stream\\\\\\\"},\\\\\\\"find-min\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Find Minimum in Rotated Sorted Array\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"Given the sorted rotated array nums of unique elements, return the minimum element of this array.\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"medium\\\\\\\",\\\\\\\"binary-search\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/\\\\\\\",\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nSuppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n    `[4,5,6,7,0,1,2]` if it was rotated 4 times.\\\\\\\\r\\\\\\\\n    `[0,1,2,4,5,6,7]` if it was rotated 7 times.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nNotice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nGiven the sorted rotated array nums of unique elements, return the minimum element of this array.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nYou must write an algorithm that runs in O(log n) time.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: nums = [3,4,5,1,2]\\\\\\\\r\\\\\\\\nOutput: 1\\\\\\\\r\\\\\\\\nExplanation: The original array was [1,2,3,4,5] rotated 3 times.\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: nums = [4,5,6,7,0,1,2]\\\\\\\\r\\\\\\\\nOutput: 0\\\\\\\\r\\\\\\\\nExplanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n-      n == nums.length     \\\\\\\\r\\\\\\\\n-      1 <= n <= 5000     \\\\\\\\r\\\\\\\\n-      -5000 <= nums[i] <= 5000     \\\\\\\\r\\\\\\\\n-      All the integers of nums are unique.     \\\\\\\\r\\\\\\\\n-      nums is sorted and rotated between 1 and n times.\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"find-min\\\\\\\"},\\\\\\\"find-the-duplicate-number\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Find the Duplicate Number\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"medium\\\\\\\",\\\\\\\"linked-list\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/find-the-duplicate-number/\\\\\\\",\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nGiven an array of integers nums containing `n + 1` integers where each integer is in the range `[1, n]` inclusive.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nThere is only **one repeated number** in nums, return this repeated number.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nYou must solve the problem **without** modifying the array nums and uses only constant extra space.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: nums = [1,3,4,2,2]\\\\\\\\r\\\\\\\\nOutput: 2\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: nums = [3,1,3,4,2]\\\\\\\\r\\\\\\\\nOutput: 3\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- 1 <= n <= 10^5 \\\\\\\\r\\\\\\\\n- nums.length == n + 1 \\\\\\\\r\\\\\\\\n- 1 <= nums[i] <= n \\\\\\\\r\\\\\\\\n- All the integers in nums appear only **once** except for **precisely one** **integer** which appears **two or more** times.\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"find-the-duplicate-number\\\\\\\"},\\\\\\\"generate-parenthesis\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Generate Parentheses\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"medium\\\\\\\",\\\\\\\"stack\\\\\\\",\\\\\\\"backtracking\\\\\\\"],\\\\\\\"link\\\\\\\":null,\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nGiven n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: n = 3\\\\\\\\r\\\\\\\\nOutput: [\\\\\\\\\\\\\\\"((()))\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"(()())\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"(())()\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"()(())\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"()()()\\\\\\\\\\\\\\\"]\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: n = 1\\\\\\\\r\\\\\\\\nOutput: [\\\\\\\\\\\\\\\"()\\\\\\\\\\\\\\\"]\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- 1 <= n <= 8\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"generate-parenthesis\\\\\\\"},\\\\\\\"hello-world\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Hello World\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"A simple hello world example\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"sample\\\\\\\"],\\\\\\\"preview\\\\\\\":\\\\\\\"This is  a simple hello world example.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\n$ dsa run hello-world.js\\\\\\\\r\\\\\\\\n```\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"hello-world\\\\\\\"},\\\\\\\"implement-trie-prefix-tree\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Trie\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"A trie (pronounced as \\\\\\\\\\\\\\\"try\\\\\\\\\\\\\\\") or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"medium\\\\\\\",\\\\\\\"trie\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/implement-trie-prefix-tree/\\\\\\\",\\\\\\\"images\\\\\\\":[],\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nA trie (pronounced as \\\\\\\\\\\\\\\"try\\\\\\\\\\\\\\\") or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nImplement the Trie class:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- Trie() Initializes the trie object.\\\\\\\\r\\\\\\\\n- void insert(String word) Inserts the string word into the trie.\\\\\\\\r\\\\\\\\n- boolean search(String word) Returns true if the string word is in the trie (i.e., was inserted before), and false otherwise.\\\\\\\\r\\\\\\\\n- boolean startsWith(String prefix) Returns true if there is a previously nserted string word that has the prefix prefix, and false otherwise.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput\\\\\\\\r\\\\\\\\n[\\\\\\\\\\\\\\\"Trie\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"insert\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"search\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"search\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"startsWith\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"insert\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"search\\\\\\\\\\\\\\\"]\\\\\\\\r\\\\\\\\n[[], [\\\\\\\\\\\\\\\"apple\\\\\\\\\\\\\\\"], [\\\\\\\\\\\\\\\"apple\\\\\\\\\\\\\\\"], [\\\\\\\\\\\\\\\"app\\\\\\\\\\\\\\\"], [\\\\\\\\\\\\\\\"app\\\\\\\\\\\\\\\"], [\\\\\\\\\\\\\\\"app\\\\\\\\\\\\\\\"], [\\\\\\\\\\\\\\\"app\\\\\\\\\\\\\\\"]]\\\\\\\\r\\\\\\\\nOutput\\\\\\\\r\\\\\\\\n[null, null, true, false, true, null, true]\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nExplanation\\\\\\\\r\\\\\\\\nTrie trie = new Trie();\\\\\\\\r\\\\\\\\ntrie.insert(\\\\\\\\\\\\\\\"apple\\\\\\\\\\\\\\\");\\\\\\\\r\\\\\\\\ntrie.search(\\\\\\\\\\\\\\\"apple\\\\\\\\\\\\\\\");   // return True\\\\\\\\r\\\\\\\\ntrie.search(\\\\\\\\\\\\\\\"app\\\\\\\\\\\\\\\");     // return False\\\\\\\\r\\\\\\\\ntrie.startsWith(\\\\\\\\\\\\\\\"app\\\\\\\\\\\\\\\"); // return True\\\\\\\\r\\\\\\\\ntrie.insert(\\\\\\\\\\\\\\\"app\\\\\\\\\\\\\\\");\\\\\\\\r\\\\\\\\ntrie.search(\\\\\\\\\\\\\\\"app\\\\\\\\\\\\\\\");     // return True\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- 1 <= word.length, prefix.length <= 2000 \\\\\\\\r\\\\\\\\n- word and prefix consist only of lowercase English letters. \\\\\\\\r\\\\\\\\n- At most 3 * 104 calls in total will be made to insert, search, and startsWith.\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"implement-trie-prefix-tree\\\\\\\"},\\\\\\\"index\\\\\\\":{\\\\\\\"preview\\\\\\\":\\\\\\\"const { getFilesInDirectory, getDirAbsoluteUri } = require('../functions');\\\\\\\\r\\\\\\\\nconst md2json = require('markdown-to-json');\\\\\\\\r\\\\\\\\nconst fs = require('fs');\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nconst DEBUG = false;\\\\\\\\r\\\\\\\\nconst PROMPT_FILE = 'prompt.json';\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nconst options = {\\\\\\\\r\\\\\\\\n    minify: false,\\\\\\\\r\\\\\\\\n    width: DEBUG ? 0 : 9000000,\\\\\\\\r\\\\\\\\n    outfile: null,\\\\\\\\r\\\\\\\\n};\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n/**\\\\\\\\r\\\\\\\\n * Creates a compiled json file from all the markdown files in the prompt directory\\\\\\\\r\\\\\\\\n */\\\\\\\\r\\\\\\\\nconst createCompiledJson = () => {\\\\\\\\r\\\\\\\\n    let parsed_prompt_dict = {};\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n    getFilesInDirectory('./prompt/')\\\\\\\\r\\\\\\\\n        .then((files) => {\\\\\\\\r\\\\\\\\n            const absolutePathForFiles = files.map((file) => {\\\\\\\\r\\\\\\\\n                return getDirAbsoluteUri(file, './prompt/');\\\\\\\\r\\\\\\\\n            });\\\\\\\\r\\\\\\\\n            if (DEBUG) console.log(\\\\\\\\\\\\\\\"absolutePathForFiles: \\\\\\\\\\\\\\\", absolutePathForFiles);\\\\\\\\r\\\\\\\\n            const promptsData = md2json.parse(absolutePathForFiles, options);\\\\\\\\r\\\\\\\\n            if (DEBUG) console.log(promptsData);\\\\\\\\r\\\\\\\\n            parsed_prompt_dict = JSON.parse(promptsData);\\\\\\\\r\\\\\\\\n            // Object.values(parsed_prompt_dict).map((prompt) => {\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n            //     prompt.preview\\\\\\\\r\\\\\\\\n            // });\\\\\\\\r\\\\\\\\n            // console.log(\\\\\\\\\\\\\\\"promptsData: \\\\\\\\\\\\\\\", parsed_prompt_dict);\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n            // Save as a json\\\\\\\\r\\\\\\\\n            const json = JSON.stringify(parsed_prompt_dict);\\\\\\\\r\\\\\\\\n            const prompt_file_path = getDirAbsoluteUri(PROMPT_FILE, './prompt/');\\\\\\\\r\\\\\\\\n            fs.writeFile(prompt_file_path, json, (err) => {\\\\\\\\r\\\\\\\\n                if (err) throw err;\\\\\\\\r\\\\\\\\n                console.log('The file has been saved!');\\\\\\\\r\\\\\\\\n            });\\\\\\\\r\\\\\\\\n        })\\\\\\\\r\\\\\\\\n        .catch((error) => {\\\\\\\\r\\\\\\\\n            console.error(error);\\\\\\\\r\\\\\\\\n        });\\\\\\\\r\\\\\\\\n};\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nconst getLatestModified = async () => {\\\\\\\\r\\\\\\\\n    const files = await getFilesInDirectory('./prompt/');\\\\\\\\r\\\\\\\\n    let latestModified = null;\\\\\\\\r\\\\\\\\n    let latestFile = null;\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n    const absolutePathForFiles = files.map((file) => {\\\\\\\\r\\\\\\\\n        return getDirAbsoluteUri(file, './prompt/');\\\\\\\\r\\\\\\\\n    });\\\\\\\\r\\\\\\\\n    for (const file of absolutePathForFiles) {\\\\\\\\r\\\\\\\\n        const stats = await fs.promises.stat(file);\\\\\\\\r\\\\\\\\n        if (!latestModified || stats.mtime > latestModified) {\\\\\\\\r\\\\\\\\n            latestModified = stats.mtime;\\\\\\\\r\\\\\\\\n            latestFile = file;\\\\\\\\r\\\\\\\\n        }\\\\\\\\r\\\\\\\\n    }\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n    return latestFile;\\\\\\\\r\\\\\\\\n};\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n/**\\\\\\\\r\\\\\\\\n * Checks if prompt.json exists, if not, creates it, then returns the parsed json\\\\\\\\r\\\\\\\\n * @param {String} prompt_slug - The slug of the prompt to return, if empty, returns all prompts\\\\\\\\r\\\\\\\\n * @returns {Object} parsed_prompt_dict\\\\\\\\r\\\\\\\\n */\\\\\\\\r\\\\\\\\nconst getPromptDict = async (prompt_slug = \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\") => {\\\\\\\\r\\\\\\\\n    // check if prompt.json exists\\\\\\\\r\\\\\\\\n    const prompt_file_path = getDirAbsoluteUri(PROMPT_FILE, './prompt/');\\\\\\\\r\\\\\\\\n    if (!fs.existsSync(prompt_file_path)) {\\\\\\\\r\\\\\\\\n        createCompiledJson();\\\\\\\\r\\\\\\\\n    }\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n    // If exists, check if it's the latest modified file, if not, update the prompt.json\\\\\\\\r\\\\\\\\n    const latestModified = await getLatestModified();\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n    let parsed_prompt_dict;\\\\\\\\r\\\\\\\\n    if (latestModified !== prompt_file_path) {\\\\\\\\r\\\\\\\\n        console.log(\\\\\\\\\\\\\\\"latestModified: \\\\\\\\\\\\\\\", latestModified);\\\\\\\\r\\\\\\\\n        createCompiledJson();\\\\\\\\r\\\\\\\\n    }\\\\\\\\r\\\\\\\\n    try {\\\\\\\\r\\\\\\\\n        parsed_prompt_dict = require(prompt_file_path);\\\\\\\\r\\\\\\\\n    }\\\\\\\\r\\\\\\\\n    catch (e) {\\\\\\\\r\\\\\\\\n        // Delete the prompt.json file and try again\\\\\\\\r\\\\\\\\n        fs.unlinkSync(prompt_file_path);\\\\\\\\r\\\\\\\\n        // If it fails this time exit and print\\\\\\\\r\\\\\\\\n        try{\\\\\\\\r\\\\\\\\n            parsed_prompt_dict = require(prompt_file_path);\\\\\\\\r\\\\\\\\n        \\\\\\\\r\\\\\\\\n        }\\\\\\\\r\\\\\\\\n        catch (e) {\\\\\\\\r\\\\\\\\n            console.error(\\\\\\\\\\\\\\\"Error: \\\\\\\\\\\\\\\", e);\\\\\\\\r\\\\\\\\n            process.exit(1);\\\\\\\\r\\\\\\\\n        }\\\\\\\\r\\\\\\\\n    }\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n    if (prompt_slug === \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\") {\\\\\\\\r\\\\\\\\n        return parsed_prompt_dict;\\\\\\\\r\\\\\\\\n    }\\\\\\\\r\\\\\\\\n    return parsed_prompt_dict[prompt_slug];\\\\\\\\r\\\\\\\\n};\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n(async () => {\\\\\\\\r\\\\\\\\n    const sample = await getPromptDict();\\\\\\\\r\\\\\\\\n    if (DEBUG) console.log(\\\\\\\\\\\\\\\"sample: \\\\\\\\\\\\\\\", sample);\\\\\\\\r\\\\\\\\n}\\\\\\\\r\\\\\\\\n)();\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nmodule.exports = { getPromptDict, createCompiledJson };\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n// const parsed_prompt_dict = require(PROMPT_FILE);\\\\\\\\r\\\\\\\\n// module.exports = parsed_prompt_dict;\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"index\\\\\\\"},\\\\\\\"invert-binary-tree\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Invert Binary Tree\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"Given the `root` of a binary tree, invert the tree, and return its root.\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"easy\\\\\\\",\\\\\\\"binary-tree\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/invert-binary-tree/\\\\\\\",\\\\\\\"images\\\\\\\":[\\\\\\\"https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg\\\\\\\",\\\\\\\"https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg\\\\\\\"],\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nGiven the root of a binary tree, invert the tree, and return its root.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n![](https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg)\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: root = [4,2,7,1,3,6,9]\\\\\\\\r\\\\\\\\nOutput: [4,7,2,9,6,3,1]\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n![](https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg)\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: root = [2,1,3]\\\\\\\\r\\\\\\\\nOutput: [2,3,1]\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 3\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: root = []\\\\\\\\r\\\\\\\\nOutput: []\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- The number of nodes in the tree is in the range [0, 100]. \\\\\\\\r\\\\\\\\n- -100 <= Node.val <= 100\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"invert-binary-tree\\\\\\\"},\\\\\\\"k-closest\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"k closest points to origin\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane and an integer k, return the k closest points to the origin (0, 0).\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"medium\\\\\\\",\\\\\\\"heap\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/k-closest-points-to-origin/\\\\\\\",\\\\\\\"images\\\\\\\":[\\\\\\\"https://assets.leetcode.com/uploads/2021/03/03/closestplane1.jpg\\\\\\\"],\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nGiven an array of points where `points[i] = [xi, yi]` represents a point on the **X-Y** plane and an integer k, return the k closest points to the origin (0, 0).\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nThe distance between two points on the X-Y plane is the Euclidean distance (i.e., âˆš(x1 - x2)2 + (y1 - y2)2).\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nYou may return the answer in **any order**. The answer is **guaranteed** to be **unique** (except for the order that it is in).\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n![](https://assets.leetcode.com/uploads/2021/03/03/closestplane1.jpg)\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: points = [[1,3],[-2,2]], k = 1\\\\\\\\r\\\\\\\\nOutput: [[-2,2]]\\\\\\\\r\\\\\\\\nExplanation:\\\\\\\\r\\\\\\\\nThe distance between (1, 3) and the origin is sqrt(10).\\\\\\\\r\\\\\\\\nThe distance between (-2, 2) and the origin is sqrt(8).\\\\\\\\r\\\\\\\\nSince sqrt(8) < sqrt(10), (-2, 2) is closer to the origin.\\\\\\\\r\\\\\\\\nWe only want the closest k = 1 points from the origin, so the answer is just [[-2,2]].\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: points = [[3,3],[5,-1],[-2,4]], k = 2\\\\\\\\r\\\\\\\\nOutput: [[3,3],[-2,4]]\\\\\\\\r\\\\\\\\nExplanation: The answer [[-2,4],[3,3]] would also be accepted.\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- 1 <= k <= points.length <= 104\\\\\\\\r\\\\\\\\n- -104 < xi, yi < 104\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"k-closest\\\\\\\"},\\\\\\\"key-based-value-store\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Time Based Key-value Store\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"Design a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the key's value at a certain timestamp.\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"medium\\\\\\\",\\\\\\\"binary-search\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/time-based-key-value-store/\\\\\\\",\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nDesign a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the key's value at a certain timestamp.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nImplement the TimeMap class:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- `TimeMap()` Initializes the object of the data structure\\\\\\\\r\\\\\\\\n- `void set(String key, String value, int timestamp)` Stores the key `key` with the value `value` at the given time timestamp.\\\\\\\\r\\\\\\\\n- `String get(String key, int timestamp)` Returns a value such that set was called previously, with `timestamp_prev <= timestamp`. If there are multiple such values, it returns the value associated with the largest `timestamp_prev`. If there are no values, it returns `\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"`.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput\\\\\\\\r\\\\\\\\n[\\\\\\\\\\\\\\\"TimeMap\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"set\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"get\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"get\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"set\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"get\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"get\\\\\\\\\\\\\\\"]\\\\\\\\r\\\\\\\\n[[], [\\\\\\\\\\\\\\\"foo\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"bar\\\\\\\\\\\\\\\", 1], [\\\\\\\\\\\\\\\"foo\\\\\\\\\\\\\\\", 1], [\\\\\\\\\\\\\\\"foo\\\\\\\\\\\\\\\", 3], [\\\\\\\\\\\\\\\"foo\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"bar2\\\\\\\\\\\\\\\", 4], [\\\\\\\\\\\\\\\"foo\\\\\\\\\\\\\\\", 4], [\\\\\\\\\\\\\\\"foo\\\\\\\\\\\\\\\", 5]]\\\\\\\\r\\\\\\\\nOutput\\\\\\\\r\\\\\\\\n[null, null, \\\\\\\\\\\\\\\"bar\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"bar\\\\\\\\\\\\\\\", null, \\\\\\\\\\\\\\\"bar2\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"bar2\\\\\\\\\\\\\\\"]\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nExplanation\\\\\\\\r\\\\\\\\nTimeMap timeMap = new TimeMap();\\\\\\\\r\\\\\\\\ntimeMap.set(\\\\\\\\\\\\\\\"foo\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"bar\\\\\\\\\\\\\\\", 1);  // store the key \\\\\\\\\\\\\\\"foo\\\\\\\\\\\\\\\" and value \\\\\\\\\\\\\\\"bar\\\\\\\\\\\\\\\" along with timestamp = 1.\\\\\\\\r\\\\\\\\ntimeMap.get(\\\\\\\\\\\\\\\"foo\\\\\\\\\\\\\\\", 1);         // return \\\\\\\\\\\\\\\"bar\\\\\\\\\\\\\\\"\\\\\\\\r\\\\\\\\ntimeMap.get(\\\\\\\\\\\\\\\"foo\\\\\\\\\\\\\\\", 3);         // return \\\\\\\\\\\\\\\"bar\\\\\\\\\\\\\\\", since there is no value corresponding to foo at timestamp 3 and timestamp 2, then the only value is at timestamp 1 is \\\\\\\\\\\\\\\"bar\\\\\\\\\\\\\\\".\\\\\\\\r\\\\\\\\ntimeMap.set(\\\\\\\\\\\\\\\"foo\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"bar2\\\\\\\\\\\\\\\", 4); // store the key \\\\\\\\\\\\\\\"foo\\\\\\\\\\\\\\\" and value \\\\\\\\\\\\\\\"bar2\\\\\\\\\\\\\\\" along with timestamp = 4.\\\\\\\\r\\\\\\\\ntimeMap.get(\\\\\\\\\\\\\\\"foo\\\\\\\\\\\\\\\", 4);         // return \\\\\\\\\\\\\\\"bar2\\\\\\\\\\\\\\\"\\\\\\\\r\\\\\\\\ntimeMap.get(\\\\\\\\\\\\\\\"foo\\\\\\\\\\\\\\\", 5);         // return \\\\\\\\\\\\\\\"bar2\\\\\\\\\\\\\\\"\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n-      1 <= key.length, value.length <= 100     \\\\\\\\r\\\\\\\\n-      key and value consist of lowercase English letters and digits.     \\\\\\\\r\\\\\\\\n-      1 <= timestamp <= 107     \\\\\\\\r\\\\\\\\n-      All the timestamps timestamp of set are strictly increasing.     \\\\\\\\r\\\\\\\\n-      At most 2 * 105 calls will be made to set and get.\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"key-based-value-store\\\\\\\"},\\\\\\\"koko-eating-bananas\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"koko-eating-bananas\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"Return the minimum integer k such that she can eat all the bananas within h hours.\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"medium\\\\\\\",\\\\\\\"binary-search\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/koko-eating-bananas/\\\\\\\",\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nKoko loves to eat bananas. There are `n` piles of bananas, the ith pile has `piles[i]` bananas. The guards have gone and will come back in `h` hours.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nKoko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nKoko likes to eat slowly but still wants to finish eating all the bananas before the guards return.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nReturn the minimum integer `k` such that she can eat all the bananas within `h` hours.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: piles = [3,6,7,11], h = 8\\\\\\\\r\\\\\\\\nOutput: 4\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: piles = [30,11,23,4,20], h = 5\\\\\\\\r\\\\\\\\nOutput: 30\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 3\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: piles = [30,11,23,4,20], h = 6\\\\\\\\r\\\\\\\\nOutput: 23\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n-      1 <= piles.length <= 104     \\\\\\\\r\\\\\\\\n-      piles.length <= h <= 109     \\\\\\\\r\\\\\\\\n-      1 <= piles[i] <= 109\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"koko-eating-bananas\\\\\\\"},\\\\\\\"kth-largest-element-in-an-array\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"kth largest elements in a stream\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"Given an integer array nums and an integer k, return the kth largest element in the array.\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"medium\\\\\\\",\\\\\\\"heap\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/kth-largest-element-in-an-array/\\\\\\\",\\\\\\\"images\\\\\\\":[],\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nGiven an integer array nums and an integer `k`, return the `kth` largest element in the array.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nNote that it is the `kth` largest element in the sorted order, not the `kth` distinct element.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nYou must solve it in `O(n)` time complexity.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: nums = [3,2,1,5,6,4], k = 2\\\\\\\\r\\\\\\\\nOutput: 5\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: nums = [3,2,3,1,2,4,5,5,6], k = 4\\\\\\\\r\\\\\\\\nOutput: 4\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- 1 <= k <= nums.length <= 10^5 \\\\\\\\r\\\\\\\\n- -10^4 <= nums[i] <= 10^4\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"kth-largest-element-in-an-array\\\\\\\"},\\\\\\\"kth-smallest-element-in-a-bst\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Kth Smallest Element in a BST\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"Given the root of a binary search tree, and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree.\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"medium\\\\\\\",\\\\\\\"binary-tree\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/kth-smallest-element-in-a-bst/\\\\\\\",\\\\\\\"images\\\\\\\":[\\\\\\\"https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg\\\\\\\",\\\\\\\"https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg\\\\\\\"],\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nGiven the `root` of a binary search tree, and an integer k, return the kth smallest value (**1-indexed**) of all the values of the nodes in the tree.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n![](https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg)\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: root = [3,1,4,null,2], k = 1\\\\\\\\r\\\\\\\\nOutput: 1\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n![](https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg)\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: root = [5,3,6,2,4,null,null,1], k = 3\\\\\\\\r\\\\\\\\nOutput: 3\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- The number of nodes in the tree is n.\\\\\\\\r\\\\\\\\n- 1 <= k <= n <= 104\\\\\\\\r\\\\\\\\n- 0 <= Node.val <= 104\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"kth-smallest-element-in-a-bst\\\\\\\"},\\\\\\\"largest-rectangle-area\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Largest Rectangle in Histogram\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"Given an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"medium\\\\\\\",\\\\\\\"stack\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/largest-rectangle-in-histogram/\\\\\\\",\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nGiven an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n![image](https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg)\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: heights = [2,1,5,6,2,3]\\\\\\\\r\\\\\\\\nOutput: 10\\\\\\\\r\\\\\\\\nExplanation: The above is a histogram where width of each bar is 1.\\\\\\\\r\\\\\\\\nThe largest rectangle is shown in the red area, which has an area = 10 units.\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n![image](https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg)\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: heights = [2,4]\\\\\\\\r\\\\\\\\nOutput: 4\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n-      1 <= heights.length <= 105     \\\\\\\\r\\\\\\\\n-      0 <= heights[i] <= 104\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"largest-rectangle-area\\\\\\\"},\\\\\\\"last-stone-weight\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Last Stone Weight\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"You are given an array of integers stones where stones[i] is the weight of the ith stone.\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"easy\\\\\\\",\\\\\\\"heap\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/last-stone-weight/\\\\\\\",\\\\\\\"images\\\\\\\":[],\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nYou are given an array of integers stones where `stones[i]` is the weight of the ith stone.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nWe are playing a game with the stones. On each turn, we choose the **heaviest two stones** and smash them together. Suppose the heaviest two stones have weights x and y with x <= y. The result of this smash is:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- If x == y, both stones are destroyed, and\\\\\\\\r\\\\\\\\n- If x != y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x.\\\\\\\\r\\\\\\\\nAt the end of the game, there is **at most one** stone left.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nReturn the weight of the last remaining stone. If there are no stones left, return 0.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: stones = [2,7,4,1,8,1]\\\\\\\\r\\\\\\\\nOutput: 1\\\\\\\\r\\\\\\\\nExplanation: \\\\\\\\r\\\\\\\\nWe combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then,\\\\\\\\r\\\\\\\\nwe combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then,\\\\\\\\r\\\\\\\\nwe combine 2 and 1 to get 1 so the array converts to [1,1,1] then,\\\\\\\\r\\\\\\\\nwe combine 1 and 1 to get 0 so the array converts to [1] then that's the value of the last stone.\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: stones = [1]\\\\\\\\r\\\\\\\\nOutput: 1\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- 1 <= stones.length <= 30 \\\\\\\\r\\\\\\\\n- 1 <= stones[i] <= 1000\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"last-stone-weight\\\\\\\"},\\\\\\\"length-of-longest-substring\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Length of Longest Substring\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"Given a string s, find the length of the longest substring without repeating characters.\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"medium\\\\\\\",\\\\\\\"sliding-window\\\\\\\"],\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nGiven a string s, find the length of the longest substring without repeating characters.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: s = \\\\\\\\\\\\\\\"abcabcbb\\\\\\\\\\\\\\\"\\\\\\\\r\\\\\\\\nOutput: 3\\\\\\\\r\\\\\\\\nExplanation: The answer is \\\\\\\\\\\\\\\"abc\\\\\\\\\\\\\\\", with the length of 3.\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: s = \\\\\\\\\\\\\\\"bbbbb\\\\\\\\\\\\\\\"\\\\\\\\r\\\\\\\\nOutput: 1\\\\\\\\r\\\\\\\\nExplanation: The answer is \\\\\\\\\\\\\\\"b\\\\\\\\\\\\\\\", with the length of 1.\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 3\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: s = \\\\\\\\\\\\\\\"pwwkew\\\\\\\\\\\\\\\"\\\\\\\\r\\\\\\\\nOutput: 3\\\\\\\\r\\\\\\\\nExplanation: The answer is \\\\\\\\\\\\\\\"wke\\\\\\\\\\\\\\\", with the length of 3.\\\\\\\\r\\\\\\\\nNotice that the answer must be a substring, \\\\\\\\\\\\\\\"pwke\\\\\\\\\\\\\\\" is a subsequence and not a substring.\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- 0 <= s.length <= 5 * 104\\\\\\\\r\\\\\\\\n- s consists of English letters, digits, symbols and spaces.\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"length-of-longest-substring\\\\\\\"},\\\\\\\"letter-combinations-of-a-phone-number\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Palindrome Partitioning\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"hard\\\\\\\",\\\\\\\"backtracking\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/letter-combinations-of-a-phone-number/\\\\\\\",\\\\\\\"images\\\\\\\":[],\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nGiven a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in **any order**.\\\\\\\\r\\\\\\\\nA mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n![Example 1](https://assets.leetcode.com/uploads/2022/03/15/1200px-telephone-keypad2svg.png)\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: digits = \\\\\\\\\\\\\\\"23\\\\\\\\\\\\\\\"\\\\\\\\r\\\\\\\\nOutput: [\\\\\\\\\\\\\\\"ad\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"ae\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"af\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"bd\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"be\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"bf\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"cd\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"ce\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"cf\\\\\\\\\\\\\\\"]\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: digits = \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\r\\\\\\\\nOutput: []\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 3\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: digits = \\\\\\\\\\\\\\\"2\\\\\\\\\\\\\\\"\\\\\\\\r\\\\\\\\nOutput: [\\\\\\\\\\\\\\\"a\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"b\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"c\\\\\\\\\\\\\\\"]\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- 0 <= digits.length <= 4\\\\\\\\r\\\\\\\\n- digits[i] is a digit in the range ['2', '9']\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"letter-combinations-of-a-phone-number\\\\\\\"},\\\\\\\"linked-list-cycle\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Linked List Cycle\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"Given head, the head of a linked list, determine if the linked list has a cycle in it.\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"medium\\\\\\\",\\\\\\\"linked-list\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/linked-list-cycle/\\\\\\\",\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nGiven `head`, the head of a linked list, determine if the linked list has a cycle in it.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. **Note that** pos **is not passed as a parameter**.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nReturn `true` if there is a cycle in the linked list. Otherwise, return `false`.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: head = [3,2,0,-4], pos = 1\\\\\\\\r\\\\\\\\nOutput: true\\\\\\\\r\\\\\\\\nExplanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: head = [1,2], pos = 0\\\\\\\\r\\\\\\\\nOutput: true\\\\\\\\r\\\\\\\\nExplanation: There is a cycle in the linked list, where the tail connects to the 0th node.\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- The number of the nodes in the list is in the range [0, 104]. \\\\\\\\r\\\\\\\\n- -10^5 <= Node.val <= 10^5 \\\\\\\\r\\\\\\\\n- pos is -1 or a valid index in the linked-list.\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"linked-list-cycle\\\\\\\"},\\\\\\\"lru-cache\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"LRU Cache\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"medium\\\\\\\",\\\\\\\"linked-list\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/lru-cache/\\\\\\\",\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nDesign a data structure that follows the constraints of a Least Recently Used (LRU) cache.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nImplement the `LRUCache` class:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- LRUCache(int capacity) Initialize the LRU cache with **positive** size capacity.\\\\\\\\r\\\\\\\\n- `int get(int key)` Return the value of the key if the key exists, otherwise return -1.\\\\\\\\r\\\\\\\\n- void `put(int key, int value)` Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, **evict** the least recently used key.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nThe functions get and put must each run in O(1) average time complexity.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput\\\\\\\\r\\\\\\\\n[\\\\\\\\\\\\\\\"LRUCache\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"put\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"put\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"get\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"put\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"get\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"put\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"get\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"get\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"get\\\\\\\\\\\\\\\"]\\\\\\\\r\\\\\\\\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\\\\\\\\r\\\\\\\\nOutput\\\\\\\\r\\\\\\\\n[null, null, null, 1, null, -1, null, -1, 3, 4]\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nExplanation\\\\\\\\r\\\\\\\\nLRUCache lRUCache = new LRUCache(2);\\\\\\\\r\\\\\\\\nlRUCache.put(1, 1); // cache is {1=1}\\\\\\\\r\\\\\\\\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\\\\\\\\r\\\\\\\\nlRUCache.get(1);    // return 1\\\\\\\\r\\\\\\\\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\\\\\\\\r\\\\\\\\nlRUCache.get(2);    // returns -1 (not found)\\\\\\\\r\\\\\\\\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\\\\\\\\r\\\\\\\\nlRUCache.get(1);    // return -1 (not found)\\\\\\\\r\\\\\\\\nlRUCache.get(3);    // return 3\\\\\\\\r\\\\\\\\nlRUCache.get(4);    // return 4\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- 1 <= capacity <= 3000\\\\\\\\r\\\\\\\\n- 0 <= key <= 104\\\\\\\\r\\\\\\\\n- 0 <= value <= 105\\\\\\\\r\\\\\\\\n- At most 2 * 105 calls will be made to get and put.\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"lru-cache\\\\\\\"},\\\\\\\"max-area-of-island\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Max Area of Island\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"You are given an m x n binary matrix grid. An island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"medium\\\\\\\",\\\\\\\"graphs\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/max-area-of-island/\\\\\\\",\\\\\\\"images\\\\\\\":[],\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nYou are given an m x n binary matrix grid. An island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nThe area of an island is the number of cells with a value 1 in the island.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nReturn the maximum area of an island in grid. If there is no island, return 0.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n![](https://assets.leetcode.com/uploads/2021/05/01/maxarea1-grid.jpg)\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]\\\\\\\\r\\\\\\\\nOutput: 6\\\\\\\\r\\\\\\\\nExplanation: The answer is not 11, because the island must be connected 4-directionally.\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: grid = [[0,0,0,0,0,0,0,0]]\\\\\\\\r\\\\\\\\nOutput: 0\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- m == grid.length \\\\\\\\r\\\\\\\\n- n == grid[i].length \\\\\\\\r\\\\\\\\n- 1 <= m, n <= 50 \\\\\\\\r\\\\\\\\n- grid[i][j] is either 0 or 1.\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"max-area-of-island\\\\\\\"},\\\\\\\"max-profit\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Max Profit\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"Best time to Buy and Sell Stock\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"easy\\\\\\\",\\\\\\\"sliding-window\\\\\\\"],\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nYou are given an array prices where prices[i] is the price of a given stock on the ith day.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: prices = [7,1,5,3,6,4]\\\\\\\\r\\\\\\\\nOutput: 5\\\\\\\\r\\\\\\\\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\\\\\\\\r\\\\\\\\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: prices = [7,6,4,3,1]\\\\\\\\r\\\\\\\\nOutput: 0\\\\\\\\r\\\\\\\\nExplanation: In this case, no transactions are done and the max profit = 0.\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n-  1 <= prices.length <= 105\\\\\\\\r\\\\\\\\n-  0 <= prices[i] <= 104\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"max-profit\\\\\\\"},\\\\\\\"max-sliding-window\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Max Sliding Window\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"Sliding Window Maximum\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"hard\\\\\\\",\\\\\\\"sliding-window\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/sliding-window-maximum/\\\\\\\",\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nYou are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.  Return the max sliding window.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: nums = [1,3,-1,-3,5,3,6,7], k = 3\\\\\\\\r\\\\\\\\nOutput: [3,3,5,5,6,7]\\\\\\\\r\\\\\\\\nExplanation: \\\\\\\\r\\\\\\\\nWindow position                Max\\\\\\\\r\\\\\\\\n---------------               -----\\\\\\\\r\\\\\\\\n[1  3  -1] -3  5  3  6  7       3\\\\\\\\r\\\\\\\\n 1 [3  -1  -3] 5  3  6  7       3\\\\\\\\r\\\\\\\\n 1  3 [-1  -3  5] 3  6  7       5\\\\\\\\r\\\\\\\\n 1  3  -1 [-3  5  3] 6  7       5\\\\\\\\r\\\\\\\\n 1  3  -1  -3 [5  3  6] 7       6\\\\\\\\r\\\\\\\\n 1  3  -1  -3  5 [3  6  7]      7\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: nums = [1], k = 1\\\\\\\\r\\\\\\\\nOutput: [1]\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n-      1 <= nums.length <= 10^5     \\\\\\\\r\\\\\\\\n-      -10^4 <= nums[i] <= 10^4     \\\\\\\\r\\\\\\\\n-      1 <= k <= nums.length\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"max-sliding-window\\\\\\\"},\\\\\\\"maximum-depth-of-binary-tree\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Maximum Depth of Binary Tree\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"easy\\\\\\\",\\\\\\\"binary-tree\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/maximum-depth-of-binary-tree/\\\\\\\",\\\\\\\"images\\\\\\\":[\\\\\\\"https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg\\\\\\\"],\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nGiven the root of a binary tree, return its maximum depth.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nA binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg)\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: root = [3,9,20,null,null,15,7]\\\\\\\\r\\\\\\\\nOutput: 3\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: root = [1,null,2]\\\\\\\\r\\\\\\\\nOutput: 2\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- The number of nodes in the tree is in the range [0, 104]. \\\\\\\\r\\\\\\\\n- -100 <= Node.val <= 100\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"maximum-depth-of-binary-tree\\\\\\\"},\\\\\\\"median-sorted-arrays\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Median of Two Sorted Arrays\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"hard\\\\\\\",\\\\\\\"binary-search\\\\\\\",\\\\\\\"array\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/median-of-two-sorted-arrays/\\\\\\\",\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nGiven two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively, return **the median** of the two sorted arrays.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nThe overall run time complexity should be `O(log (m+n))`.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: nums1 = [1,3], nums2 = [2]\\\\\\\\r\\\\\\\\nOutput: 2.00000\\\\\\\\r\\\\\\\\nExplanation: merged array = [1,2,3] and median is 2.\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: nums1 = [1,2], nums2 = [3,4]\\\\\\\\r\\\\\\\\nOutput: 2.50000\\\\\\\\r\\\\\\\\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n-      nums1.length == m     \\\\\\\\r\\\\\\\\n-      nums2.length == n     \\\\\\\\r\\\\\\\\n-      0 <= m <= 1000     \\\\\\\\r\\\\\\\\n-      0 <= n <= 1000     \\\\\\\\r\\\\\\\\n-      1 <= m + n <= 2000     \\\\\\\\r\\\\\\\\n-      -106 <= nums1[i], nums2[i] <= 106\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"median-sorted-arrays\\\\\\\"},\\\\\\\"merge-k-sorted-list\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Merge k Sorted Lists\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"hard\\\\\\\",\\\\\\\"linked-list\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/merge-k-sorted-lists/\\\\\\\",\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nYou are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nMerge all the linked-lists into one sorted linked-list and return it.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n \\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: lists = [[1,4,5],[1,3,4],[2,6]]\\\\\\\\r\\\\\\\\nOutput: [1,1,2,3,4,4,5,6]\\\\\\\\r\\\\\\\\nExplanation: The linked-lists are:\\\\\\\\r\\\\\\\\n[\\\\\\\\r\\\\\\\\n  1->4->5,\\\\\\\\r\\\\\\\\n  1->3->4,\\\\\\\\r\\\\\\\\n  2->6\\\\\\\\r\\\\\\\\n]\\\\\\\\r\\\\\\\\nmerging them into one sorted list:\\\\\\\\r\\\\\\\\n1->1->2->3->4->4->5->6\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 3\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: lists = [[]]\\\\\\\\r\\\\\\\\nOutput: []\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- k == lists.length \\\\\\\\r\\\\\\\\n- 0 <= k <= 10^4 \\\\\\\\r\\\\\\\\n- 0 <= lists[i].length <= 500 \\\\\\\\r\\\\\\\\n- -10^4 <= lists[i][j] <= 10^4 \\\\\\\\r\\\\\\\\n- lists[i] is sorted in **ascending order**. \\\\\\\\r\\\\\\\\n- The sum of lists[i].length will not exceed 10^4.\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"merge-k-sorted-list\\\\\\\"},\\\\\\\"merge-two-sorted-list\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Merge Two Sorted Lists\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"You are given the heads of two sorted linked lists list1 and list2. Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"easy\\\\\\\",\\\\\\\"linked-list\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/merge-two-sorted-lists/\\\\\\\",\\\\\\\"images\\\\\\\":[\\\\\\\"https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg\\\\\\\"],\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nYou are given the heads of two sorted linked lists list1 and list2.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nMerge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nReturn the head of the merged linked list.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg)\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: list1 = [1,2,4], list2 = [1,3,4]\\\\\\\\r\\\\\\\\nOutput: [1,1,2,3,4,4]\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: list1 = [], list2 = []\\\\\\\\r\\\\\\\\nOutput: []\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 3\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: list1 = [], list2 = [0]\\\\\\\\r\\\\\\\\nOutput: [0]\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- The number of nodes in both lists is in the range [0, 50]. \\\\\\\\r\\\\\\\\n- -100 <= Node.val <= 100 \\\\\\\\r\\\\\\\\n- Both list1 and list2 are sorted in non-decreasing order.\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"merge-two-sorted-list\\\\\\\"},\\\\\\\"min-stack\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Min Stack\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"Min Stack\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"medium\\\\\\\",\\\\\\\"stack\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/min-stack/\\\\\\\",\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nDesign a stack that supports push, pop, top, and retrieving the minimum element in constant time.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nImplement the MinStack class:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n    MinStack() initializes the stack object.\\\\\\\\r\\\\\\\\n    void push(int val) pushes the element val onto the stack.\\\\\\\\r\\\\\\\\n    void pop() removes the element on the top of the stack.\\\\\\\\r\\\\\\\\n    int top() gets the top element of the stack.\\\\\\\\r\\\\\\\\n    int getMin() retrieves the minimum element in the stack.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nYou must implement a solution with O(1) time complexity for each function.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput\\\\\\\\r\\\\\\\\n[\\\\\\\\\\\\\\\"MinStack\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"push\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"push\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"push\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"getMin\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"pop\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"top\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"getMin\\\\\\\\\\\\\\\"]\\\\\\\\r\\\\\\\\n[[],[-2],[0],[-3],[],[],[],[]]\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nOutput\\\\\\\\r\\\\\\\\n[null,null,null,null,-3,null,0,-2]\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nExplanation\\\\\\\\r\\\\\\\\nMinStack minStack = new MinStack();\\\\\\\\r\\\\\\\\nminStack.push(-2);\\\\\\\\r\\\\\\\\nminStack.push(0);\\\\\\\\r\\\\\\\\nminStack.push(-3);\\\\\\\\r\\\\\\\\nminStack.getMin(); // return -3\\\\\\\\r\\\\\\\\nminStack.pop();\\\\\\\\r\\\\\\\\nminStack.top();    // return 0\\\\\\\\r\\\\\\\\nminStack.getMin(); // return -2\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- -2^31 <= val <= 2^31 - 1     \\\\\\\\r\\\\\\\\n- Methods pop, top and getMin operations will always be called on non-empty stacks.     \\\\\\\\r\\\\\\\\n- At most 3 * 104 calls will be made to push, pop, top, and getMin.\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"min-stack\\\\\\\"},\\\\\\\"min-window\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Min Window Substring\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\".\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"hard\\\\\\\",\\\\\\\"sliding-window\\\\\\\"],\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nGiven two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\".\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: s = \\\\\\\\\\\\\\\"ADOBECODEBANC\\\\\\\\\\\\\\\", t = \\\\\\\\\\\\\\\"ABC\\\\\\\\\\\\\\\"\\\\\\\\r\\\\\\\\nOutput: \\\\\\\\\\\\\\\"BANC\\\\\\\\\\\\\\\"\\\\\\\\r\\\\\\\\nExplanation: The minimum window substring \\\\\\\\\\\\\\\"BANC\\\\\\\\\\\\\\\" includes 'A', 'B', and 'C' from string t.\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: s = \\\\\\\\\\\\\\\"a\\\\\\\\\\\\\\\", t = \\\\\\\\\\\\\\\"a\\\\\\\\\\\\\\\"\\\\\\\\r\\\\\\\\nOutput: \\\\\\\\\\\\\\\"a\\\\\\\\\\\\\\\"\\\\\\\\r\\\\\\\\nExplanation: The entire string s is the minimum window.\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 3\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: s = \\\\\\\\\\\\\\\"a\\\\\\\\\\\\\\\", t = \\\\\\\\\\\\\\\"aa\\\\\\\\\\\\\\\"\\\\\\\\r\\\\\\\\nOutput: \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\r\\\\\\\\nExplanation: Both 'a's from t must be included in the window.\\\\\\\\r\\\\\\\\nSince the largest window of s only has one 'a', return empty string.\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n-      m == s.length     \\\\\\\\r\\\\\\\\n-      n == t.length     \\\\\\\\r\\\\\\\\n-      1 <= m, n <= 105     \\\\\\\\r\\\\\\\\n-      s and t consist of uppercase and lowercase English letters.\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"min-window\\\\\\\"},\\\\\\\"n-queens\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"N-Queens\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"hard\\\\\\\",\\\\\\\"backtracking\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/n-queens/\\\\\\\",\\\\\\\"images\\\\\\\":[],\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nThe **n-queens** puzzle is the problem of placing n queens on an `n x n` chessboard such that no two queens attack each other.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nGiven an integer n, return all distinct solutions to the **n-queens puzzle**. You may return the answer in **any order**.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nEach solution contains a distinct board configuration of the n-queens' placement, where `'Q'` and `'.'` both indicate a queen and an empty space, respectively.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/11/13/queens.jpg)\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: n = 4\\\\\\\\r\\\\\\\\nOutput: [[\\\\\\\\\\\\\\\".Q..\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"...Q\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"Q...\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"..Q.\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\"..Q.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"Q...\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"...Q\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\".Q..\\\\\\\\\\\\\\\"]]\\\\\\\\r\\\\\\\\nExplanation: There exist two distinct solutions to the 4-queens puzzle as shown above\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: n = 1\\\\\\\\r\\\\\\\\nOutput: [[\\\\\\\\\\\\\\\"Q\\\\\\\\\\\\\\\"]]\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- `1 <= n <= 9`\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"n-queens\\\\\\\"},\\\\\\\"number-of-connected-components-in-an-undirected-graph\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Redundant Connection\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"find the number of connected components in an undirected graph.\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"medium\\\\\\\",\\\\\\\"graphs\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://cheonhyangzhang.gitbooks.io/leetcode-solutions/content/323-number-of-connected-components-in-an-undirected-graph.html\\\\\\\",\\\\\\\"images\\\\\\\":[],\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nGiven n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to find the number of connected components in an undirected graph.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nExample 1:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n     0          3\\\\\\\\r\\\\\\\\n     |          |\\\\\\\\r\\\\\\\\n     1 --- 2    4\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nGiven n = 5 and edges = [[0, 1], [1, 2], [3, 4]], return 2.\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nExample 2:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n     0           4\\\\\\\\r\\\\\\\\n     |           |\\\\\\\\r\\\\\\\\n     1 --- 2 --- 3\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nGiven n = 5 and edges = [[0, 1], [1, 2], [2, 3], [3, 4]], return 1.\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nNote:\\\\\\\\r\\\\\\\\nYou can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges.\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"number-of-connected-components-in-an-undirected-graph\\\\\\\"},\\\\\\\"number-of-islands\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Number of Islands\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"medium\\\\\\\",\\\\\\\"graphs\\\\\\\"],\\\\\\\"link\\\\\\\":null,\\\\\\\"images\\\\\\\":[],\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nGiven an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: grid = [\\\\\\\\r\\\\\\\\n  [\\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\"],\\\\\\\\r\\\\\\\\n  [\\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\"],\\\\\\\\r\\\\\\\\n  [\\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\"],\\\\\\\\r\\\\\\\\n  [\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\"]\\\\\\\\r\\\\\\\\n]\\\\\\\\r\\\\\\\\nOutput: 1\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n-\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"number-of-islands\\\\\\\"},\\\\\\\"pacific-atlantic-water-flow\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Pacific Atlantic Water Flow\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"There is an m x n rectangular island that borders both the Pacific Ocean and Atlantic Ocean. The Pacific Ocean touches the island's left and top edges, and the Atlantic Ocean touches the island's right and bottom edges.\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"medium\\\\\\\",\\\\\\\"graphs\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/pacific-atlantic-water-flow/\\\\\\\",\\\\\\\"images\\\\\\\":[],\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nThere is an m x n rectangular island that borders both the** Pacific Ocean** and Atlantic Ocean. The Pacific Ocean touches the island's left and top edges, and the Atlantic Ocean touches the island's right and bottom edges.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nThe island is partitioned into a grid of square cells. You are given an m x n integer matrix heights where heights[r][c] represents the **height above sea level** of the cell at coordinate (r, c).\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nThe island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell's height is **less than or equal to** the current cell's height. Water can flow from any cell adjacent to an ocean into the ocean.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nReturn a **2D list** of grid coordinates result where result[i] = [ri, ci] denotes that rain water can flow from cell (ri, ci) to **both** the Pacific and Atlantic oceans.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n![](https://assets.leetcode.com/uploads/2021/06/08/waterflow-grid.jpg)\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]\\\\\\\\r\\\\\\\\nOutput: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]\\\\\\\\r\\\\\\\\nExplanation: The following cells can flow to the Pacific and Atlantic oceans, as shown below:\\\\\\\\r\\\\\\\\n[0,4]: [0,4] -> Pacific Ocean \\\\\\\\r\\\\\\\\n       [0,4] -> Atlantic Ocean\\\\\\\\r\\\\\\\\n[1,3]: [1,3] -> [0,3] -> Pacific Ocean \\\\\\\\r\\\\\\\\n       [1,3] -> [1,4] -> Atlantic Ocean\\\\\\\\r\\\\\\\\n[1,4]: [1,4] -> [1,3] -> [0,3] -> Pacific Ocean \\\\\\\\r\\\\\\\\n       [1,4] -> Atlantic Ocean\\\\\\\\r\\\\\\\\n[2,2]: [2,2] -> [1,2] -> [0,2] -> Pacific Ocean \\\\\\\\r\\\\\\\\n       [2,2] -> [2,3] -> [2,4] -> Atlantic Ocean\\\\\\\\r\\\\\\\\n[3,0]: [3,0] -> Pacific Ocean \\\\\\\\r\\\\\\\\n       [3,0] -> [4,0] -> Atlantic Ocean\\\\\\\\r\\\\\\\\n[3,1]: [3,1] -> [3,0] -> Pacific Ocean \\\\\\\\r\\\\\\\\n       [3,1] -> [4,1] -> Atlantic Ocean\\\\\\\\r\\\\\\\\n[4,0]: [4,0] -> Pacific Ocean \\\\\\\\r\\\\\\\\n       [4,0] -> Atlantic Ocean\\\\\\\\r\\\\\\\\nNote that there are other possible paths for these cells to flow to the Pacific and Atlantic oceans.\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: heights = [[1]]\\\\\\\\r\\\\\\\\nOutput: [[0,0]]\\\\\\\\r\\\\\\\\nExplanation: The water can flow from the only cell to the Pacific and Atlantic oceans.\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- m == heights.length\\\\\\\\r\\\\\\\\n- n == heights[r].length\\\\\\\\r\\\\\\\\n- 1 <= m, n <= 200\\\\\\\\r\\\\\\\\n- 0 <= heights[r][c] <= 10^5\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"pacific-atlantic-water-flow\\\\\\\"},\\\\\\\"palindrome-partitioning\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Palindrome Partitioning\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s.\\\\\\\",\\\\\\\"tags\\\\\\\":[],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/palindrome-partitioning/\\\\\\\",\\\\\\\"images\\\\\\\":[],\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nGiven a string `s`, partition `s` such that every substring of the partition is a **palindrome**. Return all possible palindrome partitioning of `s`.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: s = \\\\\\\\\\\\\\\"aab\\\\\\\\\\\\\\\"\\\\\\\\r\\\\\\\\nOutput: [[\\\\\\\\\\\\\\\"a\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"a\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"b\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\"aa\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"b\\\\\\\\\\\\\\\"]]\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: s = \\\\\\\\\\\\\\\"a\\\\\\\\\\\\\\\"\\\\\\\\r\\\\\\\\nOutput: [[\\\\\\\\\\\\\\\"a\\\\\\\\\\\\\\\"]]\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- 1 <= s.length <= 16 \\\\\\\\r\\\\\\\\n- `s` contains only lowercase English letters.\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"palindrome-partitioning\\\\\\\"},\\\\\\\"permutations\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Permutations\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"medium\\\\\\\",\\\\\\\"backtracking\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/permutations/\\\\\\\",\\\\\\\"images\\\\\\\":[],\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nGiven an array `nums` of distinct integers, return all the possible permutations. You can return the answer **in any order**.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: nums = [1,2,3]\\\\\\\\r\\\\\\\\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: nums = [0,1]\\\\\\\\r\\\\\\\\nOutput: [[0,1],[1,0]]\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 3\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: nums = [1]\\\\\\\\r\\\\\\\\nOutput: [[1]]\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- 1 <= nums.length <= 6 \\\\\\\\r\\\\\\\\n- -10 <= nums[i] <= 10 \\\\\\\\r\\\\\\\\n- All the integers of nums are unique.\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"permutations\\\\\\\"},\\\\\\\"prompt\\\\\\\":{\\\\\\\"preview\\\\\\\":\\\\\\\"{\\\\\\\\\\\\\\\"add-two-numbers\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Add Two Numbers\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"linked-list\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/add-two-numbers/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2020/10/02/addtwonumber1.jpg\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/10/02/addtwonumber1.jpg)\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: l1 = [2,4,3], l2 = [5,6,4]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: [7,0,8]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation: 342 + 465 = 807.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: l1 = [0], l2 = [0]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: [0]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 3\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: [8,9,9,9,0,0,0,1]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- The number of nodes in each linked list is in the range [1, 100]. \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 0 <= Node.val <= 9 \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- It is guaranteed that the list represents a number that does not have leading zeros.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"add-two-numbers\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"balanced-binary-tree\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Balanced Binary Tree\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Given a binary tree, determine if it is height-balanced.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"easy\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"binary-tree\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/balanced-binary-tree/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nGiven a binary tree, determine if it is height-balanced.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg)\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: root = [3,9,20,null,null,15,7]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: true\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg)\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: root = [1,2,2,3,3,null,null,4,4]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: false\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 3\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: root = []\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: true\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- The number of nodes in the tree is in the range [0, 5000]. \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- -10^4 <= Node.val <= 10^4\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"balanced-binary-tree\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"binary-search\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Binary Search\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"binary-search\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/binary-search/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\":[],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nGiven an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nYou must write an algorithm with O(log n) runtime complexity.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: nums = [-1,0,3,5,9,12], target = 9\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: 4\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation: 9 exists in nums and its index is 4\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: nums = [-1,0,3,5,9,12], target = 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: -1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation: 2 does not exist in nums so return -1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n-     1 <= nums.length <= 104\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n-     -104 < nums[i], target < 104\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n-     All the integers in nums are unique.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n-     uunums is sorted in ascending order.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"binary-search\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"binary-tree-level-order-traversal\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Binary Tree Level Order Traversal\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"binary-tree\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/binary-tree-level-order-traversal/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nGiven the `root` of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: root = [3,9,20,null,null,15,7]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: [[3],[9,20],[15,7]]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: root = [1]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: [[1]]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- The number of nodes in the tree is in the range [0, 2000]. \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- -1000 <= Node.val <= 1000\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"binary-tree-level-order-traversal\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"binary-tree-maximum-path-sum\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Binary Tree Maximum Path Sum\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Given the root of a binary tree, return the maximum path sum of any non-empty path.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"hard\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"binary-tree\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/binary-tree-maximum-path-sum/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nA path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nThe path sum of a path is the sum of the node's values in the path.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nGiven the root of a binary tree, return the maximum path sum of any non-empty path.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg)\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: root = [1,2,3]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: 6\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation: The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg)\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: root = [-10,9,20,null,null,15,7]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: 42\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation: The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- The number of nodes in the tree is in the range [1, 3 * 10^4]. \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- -1000 <= Node.val <= 1000\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"binary-tree-maximum-path-sum\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"binary-tree-right-side-view\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Binary Tree Right Side View\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"binary-tree\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/binary-tree-right-side-view/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2021/02/14/tree.jpg\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nGiven the `root` of a binary tree, imagine yourself standing on the **right side** of it, return the values of the nodes you can see ordered from top to bottom.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2021/02/14/tree.jpg)\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: root = [1,2,3,null,5,null,4]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: [1,3,4]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: root = [1,null,3]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: [1,3]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- The number of nodes in the tree is in the range [0, 100]. \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- -100 <= Node.val <= 100\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"binary-tree-right-side-view\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"car-fleet\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Car Fleet\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"There are n cars going to the same destination along a one-lane road. The destination is target miles away.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"stack\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/car-fleet/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\":[],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nThere are `n` cars going to the same destination along a one-lane road. The destination is `target` miles away.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nYou are given two integer array position and speed, both of length n, where position[i] is the position of the ith car and speed[i] is the speed of the ith car (in miles per hour).\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nA car can never pass another car ahead of it, but it can catch up to it and drive bumper to bumper at the same speed. The faster car will slow down to match the slower car's speed. The distance between these two cars is ignored (i.e., they are assumed to have the same position).\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nA car fleet is some non-empty set of cars driving at the same position and same speed. Note that a single car is also a car fleet.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nIf a car catches up to a car fleet right at the destination point, it will still be considered as one car fleet.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nReturn the number of car fleets that will arrive at the destination.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: 3\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nThe cars starting at 10 (speed 2) and 8 (speed 4) become a fleet, meeting each other at 12.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nThe car starting at 0 does not catch up to any other car, so it is a fleet by itself.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nThe cars starting at 5 (speed 1) and 3 (speed 3) become a fleet, meeting each other at 6. The fleet moves at speed 1 until it reaches target.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nNote that no other cars meet these fleets before the destination, so the answer is 3.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: target = 10, position = [3], speed = [3]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation: There is only one car, hence there is only one fleet.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 3\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: target = 100, position = [0,2,4], speed = [4,2,1]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nThe cars starting at 0 (speed 4) and 2 (speed 2) become a fleet, meeting each other at 4. The fleet moves at speed 2.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nThen, the fleet (speed 2) and the car starting at 4 (speed 1) become one fleet, meeting each other at 6. The fleet moves at speed 1 until it reaches target.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n-      n == position.length == speed.length     \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n-      1 <= n <= 105\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n-      0 < target <= 106\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n-      0 <= position[i] < target\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n-      All the values of position are unique.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n-      0 < speed[i] <= 106\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"car-fleet\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"character-replacement\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Character Replacement\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Longest Repeating Character Replacement\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"sliding-window\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nYou are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nReturn the length of the longest substring containing the same letter you can get after performing the above operations.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: s = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"ABAB\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", k = 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: 4\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation: Replace the two 'A's with two 'B's or vice versa.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: s = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"AABABBA\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", k = 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: 4\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation: Replace the one 'A' in the middle with 'B' and form \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"AABBBBA\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\".\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nThe substring \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"BBBB\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" has the longest repeating letters, which is 4.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 1 <= s.length <= 105\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- s consists of only uppercase English letters.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 0 <= k <= s.length\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"character-replacement\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"clone-graph\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Clone Graph\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"graphs\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":null,\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\":[],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nGiven an `m x n` 2D binary grid `grid` which represents a map of `'1's` (land) and `'0's` (water), return the number of islands.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nAn **island** is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: grid = [\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n  [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n  [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n  [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n  [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n-\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"clone-graph\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"combination-sum-ii\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Combination Sum II\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"backtracking\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":null,\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\":[],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nGiven a collection of candidate numbers (`candidates`) and a target number (`target`), find all unique combinations in `candidates` where the candidate numbers sum to target.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nEach number in candidates may only be used **once** in the combination.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n**Note**: The solution set must not contain duplicate combinations.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: candidates = [10,1,2,7,6,1,5], target = 8\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n[\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n[1,1,6],\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n[1,2,5],\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n[1,7],\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n[2,6]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: candidates = [2,5,2,1,2], target = 5\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n[\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n[1,2,2],\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n[5]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 1 <= candidates.length <= 100 \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 1 <= candidates[i] <= 50 \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 1 <= target <= 30\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"combination-sum-ii\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"combination-sum\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Combination Sum\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"The test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"backtracking\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/combination-sum/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\":[],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nGiven an array of **distinct** integers candidates and a target integer target, return a list of all **unique combinations** of candidates where the chosen numbers sum to target. You may return the combinations in **any order**.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nThe **same** number may be chosen from candidates an **unlimited number of times**. Two combinations are unique if the frequency of at least one of the chosen numbers is different.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nThe test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: candidates = [2,3,6,7], target = 7\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: [[2,2,3],[7]]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n7 is a candidate, and 7 = 7.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nThese are the only two combinations.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: candidates = [2,3,5], target = 8\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: [[2,2,2,2],[2,3,3],[3,5]]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 1 <= candidates.length <= 30\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 2 <= candidates[i] <= 40\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- All elements of candidates are distinct.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 1 <= target <= 40\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"combination-sum\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"construct-binary-tree-from-preorder-and-inorder-traversal\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Construct Binary Tree from Preorder and Inorder Traversal\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"binary-tree\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2021/02/19/tree.jpg\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nGiven two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg)\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: [3,9,20,null,null,15,7]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: preorder = [-1], inorder = [-1]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: [-1]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 1 <= preorder.length <= 3000 \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- inorder.length == preorder.length\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- -3000 <= preorder[i], inorder[i] <= 3000 \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- preorder and inorder consist of unique values. \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- Each value of inorder also appears in preorder. \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- preorder is guaranteed to be the preorder traversal of the tree. \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- inorder is guaranteed to be the inorder traversal of the tree.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"construct-binary-tree-from-preorder-and-inorder-traversal\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"container-with-most-water\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Container With Most Water\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"A container with most water example\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"two-pointers\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"## Container With Most Water\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nYou are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nReturn the maximum amount of water a container can store.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nNotice that you may not slant the container.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n![](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg)\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: height = [1,8,6,2,5,4,8,3,7]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: 49\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: height = [1,1]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"container-with-most-water\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"copy-list-with-random-pointer\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Copy List with Random Pointer\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"linked-list\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/copy-list-with-random-pointer/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2019/12/18/e1.png\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2019/12/18/e2.png\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2019/12/18/e3.png\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nA linked list of length `n` is given such that each node contains an additional random pointer, which could point to any node in the list, or `null`.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nConstruct a deep copy of the list. The deep copy should consist of exactly n **brand new **nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. **None of the pointers in the new list should point to nodes in the original list.**\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nFor example, if there are two nodes X and Y in the original list, where X.random --> Y, then for the corresponding two nodes x and y in the copied list, x.random --> y.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nReturn the head of the copied linked list.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nThe linked list is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- `val`: an integer representing `Node.val`\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- `random_index`: the index of the node (range from `0` to `n-1`) that the `random pointer` points to, or null if it does not point to any node.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nYour code will **only** be given the head of the original linked list.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2019/12/18/e1.png)\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: [[7,null],[13,0],[11,4],[10,2],[1,0]]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2019/12/18/e2.png)\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: head = [[1,1],[2,1]]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: [[1,1],[2,1]]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 3\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2019/12/18/e3.png)\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: head = [[3,null],[3,0],[3,null]]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: [[3,null],[3,0],[3,null]]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 0 <= n <= 1000\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- -104 <= Node.val <= 104\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- Node.random is null or is pointing to some node in the linked list.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"copy-list-with-random-pointer\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"count-good-nodes-in-binary-tree\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Count Good Nodes in Binary Tree\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Given a binary tree root, a node X in the tree is named good if in the path from root to X there are no nodes with a value greater than X.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"binary-tree\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/count-good-nodes-in-binary-tree/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2020/04/02/test_sample_1.png\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2020/04/02/test_sample_2.png\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nGiven a binary tree root, a node X in the tree is named good if in the path from root to X there are no nodes with a value greater than X.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nReturn the number of **good** nodes in the binary tree.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/04/02/test_sample_1.png)\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: root = [3,1,4,3,null,1,5]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: 4\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation: Nodes in blue are good.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nRoot Node (3) is always a good node.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nNode 4 -> (3,4) is the maximum value in the path starting from the root.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nNode 5 -> (3,4,5) is the maximum value in the path\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nNode 3 -> (3,1,3) is the maximum value in the path.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/04/02/test_sample_2.png)\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: root = [3,3,null,4,2]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: 3\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation: Node 2 -> (3, 3, 2) is not good, because \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"3\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" is higher than it.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 3\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: root = [1]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation: Root is considered as good.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- The number of nodes in the binary tree is in the range [1, 10^5]. \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- Each node's value is between [-10^4, 10^4].\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"count-good-nodes-in-binary-tree\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"course-schedule-ii\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Course Schedule II\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Return the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"graph\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"topological-sort\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/course-schedule-ii/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\":[],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nThere are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where `prerequisites[i] = [ai, bi]` indicates that you must take course bi first if you want to take course ai.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nFor example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nReturn the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return **an empty array**.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: numCourses = 2, prerequisites = [[1,0]]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: [0,1]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: [0,2,1,3]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nSo one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 3\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: numCourses = 1, prerequisites = []\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: [0]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 1 <= numCourses <= 2000 \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 0 <= prerequisites.length <= numCourses * (numCourses - 1)\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- prerequisites[i].length == 2 \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 0 <= ai, bi < numCourses \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- ai != bi \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- All the pairs [ai, bi] are distinct.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"course-schedule-ii\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"course-schedule\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Course Schedule\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Return true if you can finish all courses. Otherwise, return false.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"graph\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"topological-sort\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/course-schedule/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\":[],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nThere are a total of `numCourses` courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where `prerequisites[i] = [ai, bi]` indicates that you **must** take course bi first if you want to take course ai.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nFor example, the pair `[0, 1]`, indicates that to take course 0 you have to first take course 1.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nReturn true if you can finish all courses. Otherwise, return `false`.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: numCourses = 2, prerequisites = [[1,0]]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: true\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation: There are a total of 2 courses to take. \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nTo take course 1 you should have finished course 0. So it is possible.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: numCourses = 2, prerequisites = [[1,0],[0,1]]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: false\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation: There are a total of 2 courses to take. \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nTo take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 1 <= numCourses <= 2000 \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 0 <= prerequisites.length <= 5000 \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- prerequisites[i].length == 2 \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 0 <= ai, bi < numCourses \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- All the pairs prerequisites[i] are unique.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"course-schedule\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"daily-temperatures\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Daily Temperatures\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"stack\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"sliding-window\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/daily-temperatures/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\":[],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nGiven an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: temperatures = [73,74,75,71,69,72,76,73]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: [1,1,4,2,1,1,0,0]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: temperatures = [30,40,50,60]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: [1,1,1,0]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n-     1 <= temperatures.length <= 105\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n-     30 <= temperatures[i] <= 100\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"daily-temperatures\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"design-add-and-search-words-data-structure\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Design Add and Search Words Data Structure\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Design a data structure that supports adding new words and finding if a string matches any previously added string.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"trie\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/design-add-and-search-words-data-structure/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\":[],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nDesign a data structure that supports adding new words and finding if a string matches any previously added string.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nImplement the `WordDictionary` class:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- WordDictionary() Initializes the object.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- void addWord(word) Adds word to the data structure, it can be matched later.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- bool search(word) Returns true if there is any string in the data structure that matches word or false otherwise. word may contain dots '.' where dots can be matched with any letter.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"WordDictionary\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"addWord\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"addWord\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"addWord\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"search\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"search\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"search\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"search\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n[[],[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bad\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"dad\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"mad\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"pad\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bad\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\".ad\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"b..\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n[null,null,null,null,false,true,true,true]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nWordDictionary wordDictionary = new WordDictionary();\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nwordDictionary.addWord(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bad\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\");\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nwordDictionary.addWord(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"dad\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\");\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nwordDictionary.addWord(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"mad\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\");\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nwordDictionary.search(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"pad\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"); // return False\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nwordDictionary.search(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bad\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"); // return True\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nwordDictionary.search(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\".ad\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"); // return True\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nwordDictionary.search(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"b..\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"); // return True\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 1 <= word.length <= 25\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- word in addWord consists of lowercase English letters.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- word in search consist of '.' or lowercase English letters.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- There will be at most 3 dots in word for search queries.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- At most 104 calls will be made to addWord and search.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"design-add-and-search-words-data-structure\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"design-twitter\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Design Twitter\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/design-twitter/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"heap\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/design-twitter/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\":[],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nDesign a simplified version of Twitter where users can post tweets, follow/unfollow another user, and is able to see the 10 most recent tweets in the user's news feed.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nImplement the `Twitter` class:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- Twitter() Initializes your twitter object.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- void postTweet(int userId, int tweetId) Composes a new tweet with ID tweetId by the user userId. Each call to this function will be made with a unique tweetId.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- List<Integer> getNewsFeed(int userId) Retrieves the 10 most recent tweet IDs in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user themself. Tweets must be ordered from most recent to least recent.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- void follow(int followerId, int followeeId) The user with ID followerId started following the user with ID followeeId.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- void unfollow(int followerId, int followeeId) The user with ID followerId started unfollowing the user with ID followeeId.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Twitter\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"postTweet\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"getNewsFeed\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"follow\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"postTweet\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"getNewsFeed\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"unfollow\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"getNewsFeed\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n[[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n[null, null, [5], null, null, [6, 5], null, [5]]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nTwitter twitter = new Twitter();\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\ntwitter.postTweet(1, 5); // User 1 posts a new tweet (id = 5).\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\ntwitter.getNewsFeed(1);  // User 1's news feed should return a list with 1 tweet id -> [5]. return [5]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\ntwitter.follow(1, 2);    // User 1 follows user 2.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\ntwitter.postTweet(2, 6); // User 2 posts a new tweet (id = 6).\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\ntwitter.getNewsFeed(1);  // User 1's news feed should return a list with 2 tweet ids -> [6, 5]. Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\ntwitter.unfollow(1, 2);  // User 1 unfollows user 2.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\ntwitter.getNewsFeed(1);  // User 1's news feed should return a list with 1 tweet id -> [5], since user 1 is no longer following user 2.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 1 <= userId, followerId, followeeId <= 500\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 0 <= tweetId <= 10^4\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- All the tweets have unique IDs.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- At most 3 * 10^4 calls will be made to postTweet, getNewsFeed, follow, and unfollow.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"design-twitter\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"diameter-of-binary-tree\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Diameter of Binary Tree\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Given the root of a binary tree, return the length of the diameter of the tree.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"easy\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"binary-tree\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/diameter-of-binary-tree/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nGiven the `root` of a binary tree, return the **length** of the diameter of the tree.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nThe **diameter** of a binary tree is the **length** of the longest path between any two nodes in a tree. This path may or may not pass through the root.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nThe **length** of a path between two nodes is represented by the number of edges between them.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg)\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: root = [1,2,3,4,5]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: 3\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation: 3 is the length of the path [4,2,1,3] or [5,2,1,3].\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: root = [1,2]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- The number of nodes in the tree is in the range [1, 104]. \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- -100 <= Node.val <= 100\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"diameter-of-binary-tree\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"evaluate-polish-reverse-notation\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Evaluate Reverse Polish Notation\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation.  Evaluate the expression. Return an integer that represents the value of the expression.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"stack\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/evaluate-reverse-polish-notation/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nYou are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nEvaluate the expression. Return an integer that represents the value of the expression.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nNote that:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n    The valid operators are '+', '-', '*', and '/'.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n    Each operand may be an integer or another expression.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n    The division between two integers always truncates toward zero.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n    There will not be any division by zero.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n    The input represents a valid arithmetic expression in a reverse polish notation.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n    The answer and all the intermediate calculations can be represented in a 32-bit integer.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: tokens = [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"+\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"3\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: 9\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation: ((2 + 1) * 3) = 9\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: tokens = [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"4\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"13\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"5\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"+\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: 6\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation: (4 + (13 / 5)) = 6\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 1 <= tokens.length <= 104\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- tokens[i] is either an operator: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"+\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"-\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", or \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", or an integer in the range [-200, 200].\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"evaluate-polish-reverse-notation\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"find-median-from-data-stream\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Find Median from Data Stream\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"hard\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"heap\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/find-median-from-data-stream/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\":[],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nThe **median** is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- For example, for arr = [2,3,4], the median is 3.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- For example, for arr = [2,3], the median is (2 + 3) / 2 = 2.5.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nImplement the MedianFinder class:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- MedianFinder() initializes the MedianFinder object.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- void addNum(int num) adds the integer num from the data stream to the data structure.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- double findMedian() returns the median of all elements so far. Answers within 10-5 of the actual answer will be accepted.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"MedianFinder\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"addNum\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"addNum\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"findMedian\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"addNum\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"findMedian\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n[[], [1], [2], [], [3], []]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n[null, null, null, 1.5, null, 2.0]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nMedianFinder medianFinder = new MedianFinder();\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nmedianFinder.addNum(1);    // arr = [1]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nmedianFinder.addNum(2);    // arr = [1, 2]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nmedianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2)\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nmedianFinder.addNum(3);    // arr[1, 2, 3]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nmedianFinder.findMedian(); // return 2.0\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- -10^5 <= num <= 10^5 \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- There will be at least one element in the data structure before calling findMedian. \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- At most 5 * 10^4 calls will be made to addNum and findMedian.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Follow up:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- If all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- If 99% of all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"find-median-from-data-stream\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"find-min\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Find Minimum in Rotated Sorted Array\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Given the sorted rotated array nums of unique elements, return the minimum element of this array.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"binary-search\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nSuppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n    `[4,5,6,7,0,1,2]` if it was rotated 4 times.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n    `[0,1,2,4,5,6,7]` if it was rotated 7 times.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nNotice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nGiven the sorted rotated array nums of unique elements, return the minimum element of this array.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nYou must write an algorithm that runs in O(log n) time.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: nums = [3,4,5,1,2]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation: The original array was [1,2,3,4,5] rotated 3 times.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: nums = [4,5,6,7,0,1,2]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: 0\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n-      n == nums.length     \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n-      1 <= n <= 5000     \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n-      -5000 <= nums[i] <= 5000     \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n-      All the integers of nums are unique.     \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n-      nums is sorted and rotated between 1 and n times.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"find-min\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"find-the-duplicate-number\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Find the Duplicate Number\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"linked-list\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/find-the-duplicate-number/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nGiven an array of integers nums containing `n + 1` integers where each integer is in the range `[1, n]` inclusive.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nThere is only **one repeated number** in nums, return this repeated number.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nYou must solve the problem **without** modifying the array nums and uses only constant extra space.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: nums = [1,3,4,2,2]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: nums = [3,1,3,4,2]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: 3\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 1 <= n <= 10^5 \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- nums.length == n + 1 \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 1 <= nums[i] <= n \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- All the integers in nums appear only **once** except for **precisely one** **integer** which appears **two or more** times.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"find-the-duplicate-number\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"generate-parenthesis\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Generate Parentheses\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"stack\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"backtracking\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":null,\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nGiven n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: n = 3\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"((()))\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"(()())\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"(())()\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"()(())\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"()()()\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: n = 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"()\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 1 <= n <= 8\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"generate-parenthesis\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"hello-world\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Hello World\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"A simple hello world example\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"sample\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"This is  a simple hello world example.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n$ dsa run hello-world.js\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"hello-world\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"implement-trie-prefix-tree\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Trie\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"A trie (pronounced as \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"try\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\") or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"trie\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/implement-trie-prefix-tree/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\":[],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nA trie (pronounced as \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"try\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\") or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nImplement the Trie class:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- Trie() Initializes the trie object.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- void insert(String word) Inserts the string word into the trie.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- boolean search(String word) Returns true if the string word is in the trie (i.e., was inserted before), and false otherwise.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- boolean startsWith(String prefix) Returns true if there is a previously nserted string word that has the prefix prefix, and false otherwise.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Trie\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"insert\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"search\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"search\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"startsWith\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"insert\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"search\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n[[], [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"apple\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"], [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"apple\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"], [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"app\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"], [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"app\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"], [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"app\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"], [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"app\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n[null, null, true, false, true, null, true]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nTrie trie = new Trie();\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\ntrie.insert(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"apple\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\");\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\ntrie.search(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"apple\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\");   // return True\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\ntrie.search(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"app\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\");     // return False\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\ntrie.startsWith(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"app\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"); // return True\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\ntrie.insert(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"app\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\");\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\ntrie.search(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"app\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\");     // return True\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 1 <= word.length, prefix.length <= 2000 \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- word and prefix consist only of lowercase English letters. \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- At most 3 * 104 calls in total will be made to insert, search, and startsWith.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"implement-trie-prefix-tree\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"index\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"const { getFilesInDirectory, getDirAbsoluteUri } = require('../functions');\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nconst md2json = require('markdown-to-json');\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nconst fs = require('fs');\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nconst DEBUG = false;\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nconst PROMPT_FILE = 'prompt.json';\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nconst options = {\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n    minify: false,\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n    width: DEBUG ? 0 : 9000000,\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n    outfile: null,\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n};\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n/**\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n * Creates a compiled json file from all the markdown files in the prompt directory\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n */\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nconst createCompiledJson = () => {\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n    let parsed_prompt_dict = {};\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n    getFilesInDirectory('./prompt/')\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n        .then((files) => {\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n            const absolutePathForFiles = files.map((file) => {\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n                return getDirAbsoluteUri(file, './prompt/');\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n            });\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n            if (DEBUG) console.log(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"absolutePathForFiles: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", absolutePathForFiles);\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n            const promptsData = md2json.parse(absolutePathForFiles, options);\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n            if (DEBUG) console.log(promptsData);\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n            parsed_prompt_dict = JSON.parse(promptsData);\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n            // Object.values(parsed_prompt_dict).map((prompt) => {\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n            //     prompt.preview\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n            // });\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n            // console.log(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"promptsData: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", parsed_prompt_dict);\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n            // Save as a json\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n            const json = JSON.stringify(parsed_prompt_dict);\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n            const prompt_file_path = getDirAbsoluteUri(PROMPT_FILE, './prompt/');\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n            fs.writeFile(prompt_file_path, json, (err) => {\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n                if (err) throw err;\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n                console.log('The file has been saved!');\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n            });\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n        })\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n        .catch((error) => {\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n            console.error(error);\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n        });\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n};\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nconst getLatestModified = async () => {\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n    const files = await getFilesInDirectory('./prompt/');\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n    let latestModified = null;\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n    let latestFile = null;\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n    const absolutePathForFiles = files.map((file) => {\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n        return getDirAbsoluteUri(file, './prompt/');\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n    });\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n    for (const file of absolutePathForFiles) {\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n        const stats = await fs.promises.stat(file);\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n        if (!latestModified || stats.mtime > latestModified) {\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n            latestModified = stats.mtime;\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n            latestFile = file;\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n        }\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n    return latestFile;\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n};\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n/**\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n * Checks if prompt.json exists, if not, creates it, then returns the parsed json\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n * @param {String} prompt_slug - The slug of the prompt to return, if empty, returns all prompts\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n * @returns {Object} parsed_prompt_dict\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n */\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nconst getPromptDict = async (prompt_slug = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\") => {\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n    // check if prompt.json exists\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n    const prompt_file_path = getDirAbsoluteUri(PROMPT_FILE, './prompt/');\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n    if (!fs.existsSync(prompt_file_path)) {\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n        createCompiledJson();\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n    // If exists, check if it's the latest modified file, if not, update the prompt.json\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n    const latestModified = await getLatestModified();\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n    let parsed_prompt_dict;\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n    if (latestModified !== prompt_file_path) {\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n        console.log(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"latestModified: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", latestModified);\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n        createCompiledJson();\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n    try {\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n        parsed_prompt_dict = require(prompt_file_path);\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n    catch (e) {\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n        // Delete the prompt.json file and try again\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n        fs.unlinkSync(prompt_file_path);\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n        // If it fails this time exit and print\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n        try{\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n            parsed_prompt_dict = require(prompt_file_path);\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n        }\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n        catch (e) {\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n            console.error(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Error: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", e);\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n            process.exit(1);\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n        }\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n    if (prompt_slug === \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\") {\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n        return parsed_prompt_dict;\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n    return parsed_prompt_dict[prompt_slug];\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n};\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n(async () => {\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n    const sample = await getPromptDict();\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n    if (DEBUG) console.log(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"sample: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", sample);\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n}\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n)();\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nmodule.exports = { getPromptDict, createCompiledJson };\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n// const parsed_prompt_dict = require(PROMPT_FILE);\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n// module.exports = parsed_prompt_dict;\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"index\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"invert-binary-tree\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Invert Binary Tree\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Given the `root` of a binary tree, invert the tree, and return its root.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"easy\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"binary-tree\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/invert-binary-tree/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nGiven the root of a binary tree, invert the tree, and return its root.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg)\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: root = [4,2,7,1,3,6,9]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: [4,7,2,9,6,3,1]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg)\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: root = [2,1,3]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: [2,3,1]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 3\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: root = []\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: []\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- The number of nodes in the tree is in the range [0, 100]. \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- -100 <= Node.val <= 100\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"invert-binary-tree\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"k-closest\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"k closest points to origin\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane and an integer k, return the k closest points to the origin (0, 0).\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"heap\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/k-closest-points-to-origin/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2021/03/03/closestplane1.jpg\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nGiven an array of points where `points[i] = [xi, yi]` represents a point on the **X-Y** plane and an integer k, return the k closest points to the origin (0, 0).\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nThe distance between two points on the X-Y plane is the Euclidean distance (i.e., âˆš(x1 - x2)2 + (y1 - y2)2).\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nYou may return the answer in **any order**. The answer is **guaranteed** to be **unique** (except for the order that it is in).\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2021/03/03/closestplane1.jpg)\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: points = [[1,3],[-2,2]], k = 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: [[-2,2]]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nThe distance between (1, 3) and the origin is sqrt(10).\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nThe distance between (-2, 2) and the origin is sqrt(8).\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nSince sqrt(8) < sqrt(10), (-2, 2) is closer to the origin.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nWe only want the closest k = 1 points from the origin, so the answer is just [[-2,2]].\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: points = [[3,3],[5,-1],[-2,4]], k = 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: [[3,3],[-2,4]]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation: The answer [[-2,4],[3,3]] would also be accepted.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 1 <= k <= points.length <= 104\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- -104 < xi, yi < 104\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"k-closest\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"key-based-value-store\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Time Based Key-value Store\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Design a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the key's value at a certain timestamp.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"binary-search\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/time-based-key-value-store/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nDesign a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the key's value at a certain timestamp.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nImplement the TimeMap class:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- `TimeMap()` Initializes the object of the data structure\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- `void set(String key, String value, int timestamp)` Stores the key `key` with the value `value` at the given time timestamp.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- `String get(String key, int timestamp)` Returns a value such that set was called previously, with `timestamp_prev <= timestamp`. If there are multiple such values, it returns the value associated with the largest `timestamp_prev`. If there are no values, it returns `\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"`.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"TimeMap\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"set\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"get\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"get\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"set\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"get\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"get\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n[[], [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"foo\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bar\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", 1], [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"foo\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", 1], [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"foo\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", 3], [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"foo\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bar2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", 4], [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"foo\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", 4], [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"foo\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", 5]]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n[null, null, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bar\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bar\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", null, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bar2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bar2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nTimeMap timeMap = new TimeMap();\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\ntimeMap.set(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"foo\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bar\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", 1);  // store the key \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"foo\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" and value \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bar\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" along with timestamp = 1.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\ntimeMap.get(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"foo\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", 1);         // return \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bar\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\ntimeMap.get(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"foo\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", 3);         // return \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bar\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", since there is no value corresponding to foo at timestamp 3 and timestamp 2, then the only value is at timestamp 1 is \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bar\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\".\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\ntimeMap.set(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"foo\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bar2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", 4); // store the key \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"foo\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" and value \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bar2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" along with timestamp = 4.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\ntimeMap.get(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"foo\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", 4);         // return \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bar2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\ntimeMap.get(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"foo\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", 5);         // return \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bar2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n-      1 <= key.length, value.length <= 100     \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n-      key and value consist of lowercase English letters and digits.     \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n-      1 <= timestamp <= 107     \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n-      All the timestamps timestamp of set are strictly increasing.     \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n-      At most 2 * 105 calls will be made to set and get.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"key-based-value-store\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"koko-eating-bananas\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"koko-eating-bananas\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Return the minimum integer k such that she can eat all the bananas within h hours.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"binary-search\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/koko-eating-bananas/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nKoko loves to eat bananas. There are `n` piles of bananas, the ith pile has `piles[i]` bananas. The guards have gone and will come back in `h` hours.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nKoko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nKoko likes to eat slowly but still wants to finish eating all the bananas before the guards return.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nReturn the minimum integer `k` such that she can eat all the bananas within `h` hours.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: piles = [3,6,7,11], h = 8\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: 4\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: piles = [30,11,23,4,20], h = 5\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: 30\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 3\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: piles = [30,11,23,4,20], h = 6\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: 23\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n-      1 <= piles.length <= 104     \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n-      piles.length <= h <= 109     \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n-      1 <= piles[i] <= 109\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"koko-eating-bananas\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"kth-largest-element-in-an-array\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"kth largest elements in a stream\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Given an integer array nums and an integer k, return the kth largest element in the array.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"heap\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/kth-largest-element-in-an-array/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\":[],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nGiven an integer array nums and an integer `k`, return the `kth` largest element in the array.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nNote that it is the `kth` largest element in the sorted order, not the `kth` distinct element.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nYou must solve it in `O(n)` time complexity.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: nums = [3,2,1,5,6,4], k = 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: 5\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: nums = [3,2,3,1,2,4,5,5,6], k = 4\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: 4\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 1 <= k <= nums.length <= 10^5 \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- -10^4 <= nums[i] <= 10^4\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"kth-largest-element-in-an-array\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"kth-smallest-element-in-a-bst\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Kth Smallest Element in a BST\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Given the root of a binary search tree, and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"binary-tree\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/kth-smallest-element-in-a-bst/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nGiven the `root` of a binary search tree, and an integer k, return the kth smallest value (**1-indexed**) of all the values of the nodes in the tree.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg)\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: root = [3,1,4,null,2], k = 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg)\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: root = [5,3,6,2,4,null,null,1], k = 3\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: 3\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- The number of nodes in the tree is n.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 1 <= k <= n <= 104\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 0 <= Node.val <= 104\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"kth-smallest-element-in-a-bst\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"largest-rectangle-area\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Largest Rectangle in Histogram\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Given an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"stack\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/largest-rectangle-in-histogram/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nGiven an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n![image](https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg)\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: heights = [2,1,5,6,2,3]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: 10\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation: The above is a histogram where width of each bar is 1.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nThe largest rectangle is shown in the red area, which has an area = 10 units.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n![image](https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg)\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: heights = [2,4]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: 4\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n-      1 <= heights.length <= 105     \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n-      0 <= heights[i] <= 104\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"largest-rectangle-area\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"last-stone-weight\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Last Stone Weight\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"You are given an array of integers stones where stones[i] is the weight of the ith stone.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"easy\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"heap\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/last-stone-weight/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\":[],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nYou are given an array of integers stones where `stones[i]` is the weight of the ith stone.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nWe are playing a game with the stones. On each turn, we choose the **heaviest two stones** and smash them together. Suppose the heaviest two stones have weights x and y with x <= y. The result of this smash is:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- If x == y, both stones are destroyed, and\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- If x != y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nAt the end of the game, there is **at most one** stone left.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nReturn the weight of the last remaining stone. If there are no stones left, return 0.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: stones = [2,7,4,1,8,1]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation: \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nWe combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then,\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nwe combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then,\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nwe combine 2 and 1 to get 1 so the array converts to [1,1,1] then,\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nwe combine 1 and 1 to get 0 so the array converts to [1] then that's the value of the last stone.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: stones = [1]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 1 <= stones.length <= 30 \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 1 <= stones[i] <= 1000\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"last-stone-weight\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"length-of-longest-substring\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Length of Longest Substring\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Given a string s, find the length of the longest substring without repeating characters.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"sliding-window\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nGiven a string s, find the length of the longest substring without repeating characters.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: s = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"abcabcbb\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: 3\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation: The answer is \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"abc\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", with the length of 3.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: s = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bbbbb\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation: The answer is \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"b\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", with the length of 1.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 3\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: s = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"pwwkew\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: 3\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation: The answer is \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"wke\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", with the length of 3.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nNotice that the answer must be a substring, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"pwke\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" is a subsequence and not a substring.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 0 <= s.length <= 5 * 104\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- s consists of English letters, digits, symbols and spaces.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"length-of-longest-substring\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"letter-combinations-of-a-phone-number\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Palindrome Partitioning\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"hard\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"backtracking\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/letter-combinations-of-a-phone-number/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\":[],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nGiven a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in **any order**.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nA mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n![Example 1](https://assets.leetcode.com/uploads/2022/03/15/1200px-telephone-keypad2svg.png)\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: digits = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"23\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"ad\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"ae\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"af\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bd\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"be\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bf\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"cd\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"ce\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"cf\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: digits = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: []\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 3\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: digits = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"a\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"b\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"c\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 0 <= digits.length <= 4\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- digits[i] is a digit in the range ['2', '9']\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"letter-combinations-of-a-phone-number\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"linked-list-cycle\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Linked List Cycle\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Given head, the head of a linked list, determine if the linked list has a cycle in it.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"linked-list\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/linked-list-cycle/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nGiven `head`, the head of a linked list, determine if the linked list has a cycle in it.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. **Note that** pos **is not passed as a parameter**.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nReturn `true` if there is a cycle in the linked list. Otherwise, return `false`.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: head = [3,2,0,-4], pos = 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: true\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: head = [1,2], pos = 0\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: true\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation: There is a cycle in the linked list, where the tail connects to the 0th node.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- The number of the nodes in the list is in the range [0, 104]. \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- -10^5 <= Node.val <= 10^5 \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- pos is -1 or a valid index in the linked-list.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"linked-list-cycle\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"lru-cache\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"LRU Cache\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"linked-list\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/lru-cache/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nDesign a data structure that follows the constraints of a Least Recently Used (LRU) cache.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nImplement the `LRUCache` class:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- LRUCache(int capacity) Initialize the LRU cache with **positive** size capacity.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- `int get(int key)` Return the value of the key if the key exists, otherwise return -1.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- void `put(int key, int value)` Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, **evict** the least recently used key.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nThe functions get and put must each run in O(1) average time complexity.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"LRUCache\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"put\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"put\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"get\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"put\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"get\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"put\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"get\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"get\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"get\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n[null, null, null, 1, null, -1, null, -1, 3, 4]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nLRUCache lRUCache = new LRUCache(2);\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nlRUCache.put(1, 1); // cache is {1=1}\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nlRUCache.get(1);    // return 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nlRUCache.get(2);    // returns -1 (not found)\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nlRUCache.get(1);    // return -1 (not found)\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nlRUCache.get(3);    // return 3\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nlRUCache.get(4);    // return 4\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 1 <= capacity <= 3000\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 0 <= key <= 104\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 0 <= value <= 105\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- At most 2 * 105 calls will be made to get and put.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"lru-cache\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"max-area-of-island\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Max Area of Island\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"You are given an m x n binary matrix grid. An island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"graphs\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/max-area-of-island/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\":[],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nYou are given an m x n binary matrix grid. An island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nThe area of an island is the number of cells with a value 1 in the island.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nReturn the maximum area of an island in grid. If there is no island, return 0.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2021/05/01/maxarea1-grid.jpg)\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: 6\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation: The answer is not 11, because the island must be connected 4-directionally.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: grid = [[0,0,0,0,0,0,0,0]]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: 0\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- m == grid.length \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- n == grid[i].length \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 1 <= m, n <= 50 \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- grid[i][j] is either 0 or 1.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"max-area-of-island\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"max-profit\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Max Profit\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Best time to Buy and Sell Stock\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"easy\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"sliding-window\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nYou are given an array prices where prices[i] is the price of a given stock on the ith day.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: prices = [7,1,5,3,6,4]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: 5\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: prices = [7,6,4,3,1]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: 0\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation: In this case, no transactions are done and the max profit = 0.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n-  1 <= prices.length <= 105\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n-  0 <= prices[i] <= 104\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"max-profit\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"max-sliding-window\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Max Sliding Window\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Sliding Window Maximum\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"hard\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"sliding-window\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/sliding-window-maximum/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nYou are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.  Return the max sliding window.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: nums = [1,3,-1,-3,5,3,6,7], k = 3\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: [3,3,5,5,6,7]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation: \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nWindow position                Max\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n---------------               -----\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n[1  3  -1] -3  5  3  6  7       3\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n 1 [3  -1  -3] 5  3  6  7       3\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n 1  3 [-1  -3  5] 3  6  7       5\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n 1  3  -1 [-3  5  3] 6  7       5\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n 1  3  -1  -3 [5  3  6] 7       6\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n 1  3  -1  -3  5 [3  6  7]      7\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: nums = [1], k = 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: [1]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n-      1 <= nums.length <= 10^5     \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n-      -10^4 <= nums[i] <= 10^4     \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n-      1 <= k <= nums.length\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"max-sliding-window\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"maximum-depth-of-binary-tree\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Maximum Depth of Binary Tree\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"easy\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"binary-tree\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/maximum-depth-of-binary-tree/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nGiven the root of a binary tree, return its maximum depth.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nA binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg)\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: root = [3,9,20,null,null,15,7]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: 3\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: root = [1,null,2]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- The number of nodes in the tree is in the range [0, 104]. \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- -100 <= Node.val <= 100\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"maximum-depth-of-binary-tree\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"median-sorted-arrays\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Median of Two Sorted Arrays\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"hard\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"binary-search\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"array\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/median-of-two-sorted-arrays/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nGiven two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively, return **the median** of the two sorted arrays.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nThe overall run time complexity should be `O(log (m+n))`.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: nums1 = [1,3], nums2 = [2]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: 2.00000\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation: merged array = [1,2,3] and median is 2.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: nums1 = [1,2], nums2 = [3,4]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: 2.50000\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n-      nums1.length == m     \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n-      nums2.length == n     \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n-      0 <= m <= 1000     \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n-      0 <= n <= 1000     \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n-      1 <= m + n <= 2000     \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n-      -106 <= nums1[i], nums2[i] <= 106\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"median-sorted-arrays\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"merge-k-sorted-list\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Merge k Sorted Lists\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"hard\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"linked-list\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/merge-k-sorted-lists/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nYou are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nMerge all the linked-lists into one sorted linked-list and return it.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: lists = [[1,4,5],[1,3,4],[2,6]]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: [1,1,2,3,4,4,5,6]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation: The linked-lists are:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n[\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n  1->4->5,\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n  1->3->4,\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n  2->6\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nmerging them into one sorted list:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n1->1->2->3->4->4->5->6\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 3\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: lists = [[]]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: []\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- k == lists.length \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 0 <= k <= 10^4 \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 0 <= lists[i].length <= 500 \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- -10^4 <= lists[i][j] <= 10^4 \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- lists[i] is sorted in **ascending order**. \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- The sum of lists[i].length will not exceed 10^4.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"merge-k-sorted-list\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"merge-two-sorted-list\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Merge Two Sorted Lists\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"You are given the heads of two sorted linked lists list1 and list2. Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"easy\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"linked-list\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/merge-two-sorted-lists/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nYou are given the heads of two sorted linked lists list1 and list2.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nMerge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nReturn the head of the merged linked list.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg)\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: list1 = [1,2,4], list2 = [1,3,4]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: [1,1,2,3,4,4]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: list1 = [], list2 = []\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: []\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 3\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: list1 = [], list2 = [0]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: [0]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- The number of nodes in both lists is in the range [0, 50]. \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- -100 <= Node.val <= 100 \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- Both list1 and list2 are sorted in non-decreasing order.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"merge-two-sorted-list\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"min-stack\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Min Stack\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Min Stack\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"stack\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/min-stack/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nDesign a stack that supports push, pop, top, and retrieving the minimum element in constant time.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nImplement the MinStack class:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n    MinStack() initializes the stack object.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n    void push(int val) pushes the element val onto the stack.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n    void pop() removes the element on the top of the stack.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n    int top() gets the top element of the stack.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n    int getMin() retrieves the minimum element in the stack.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nYou must implement a solution with O(1) time complexity for each function.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"MinStack\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"push\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"push\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"push\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"getMin\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"pop\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"top\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"getMin\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n[[],[-2],[0],[-3],[],[],[],[]]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n[null,null,null,null,-3,null,0,-2]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nMinStack minStack = new MinStack();\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nminStack.push(-2);\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nminStack.push(0);\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nminStack.push(-3);\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nminStack.getMin(); // return -3\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nminStack.pop();\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nminStack.top();    // return 0\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nminStack.getMin(); // return -2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- -2^31 <= val <= 2^31 - 1     \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- Methods pop, top and getMin operations will always be called on non-empty stacks.     \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- At most 3 * 104 calls will be made to push, pop, top, and getMin.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"min-stack\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"min-window\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Min Window Substring\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\".\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"hard\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"sliding-window\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nGiven two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\".\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: s = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"ADOBECODEBANC\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", t = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"ABC\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"BANC\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation: The minimum window substring \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"BANC\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" includes 'A', 'B', and 'C' from string t.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: s = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"a\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", t = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"a\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"a\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation: The entire string s is the minimum window.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 3\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: s = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"a\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", t = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"aa\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation: Both 'a's from t must be included in the window.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nSince the largest window of s only has one 'a', return empty string.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n-      m == s.length     \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n-      n == t.length     \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n-      1 <= m, n <= 105     \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n-      s and t consist of uppercase and lowercase English letters.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"min-window\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"n-queens\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"N-Queens\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"hard\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"backtracking\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/n-queens/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\":[],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nThe **n-queens** puzzle is the problem of placing n queens on an `n x n` chessboard such that no two queens attack each other.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nGiven an integer n, return all distinct solutions to the **n-queens puzzle**. You may return the answer in **any order**.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nEach solution contains a distinct board configuration of the n-queens' placement, where `'Q'` and `'.'` both indicate a queen and an empty space, respectively.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/11/13/queens.jpg)\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: n = 4\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: [[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\".Q..\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"...Q\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Q...\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"..Q.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"..Q.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Q...\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"...Q\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\".Q..\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation: There exist two distinct solutions to the 4-queens puzzle as shown above\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: n = 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: [[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Q\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- `1 <= n <= 9`\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"n-queens\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"number-of-connected-components-in-an-undirected-graph\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Redundant Connection\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"find the number of connected components in an undirected graph.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"graphs\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://cheonhyangzhang.gitbooks.io/leetcode-solutions/content/323-number-of-connected-components-in-an-undirected-graph.html\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\":[],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nGiven n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to find the number of connected components in an undirected graph.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExample 1:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n     0          3\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n     |          |\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n     1 --- 2    4\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nGiven n = 5 and edges = [[0, 1], [1, 2], [3, 4]], return 2.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExample 2:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n     0           4\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n     |           |\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n     1 --- 2 --- 3\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nGiven n = 5 and edges = [[0, 1], [1, 2], [2, 3], [3, 4]], return 1.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nNote:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nYou can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"number-of-connected-components-in-an-undirected-graph\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"number-of-islands\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Number of Islands\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"graphs\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":null,\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\":[],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nGiven an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: grid = [\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n  [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n  [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n  [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n  [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n-\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"number-of-islands\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"pacific-atlantic-water-flow\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Pacific Atlantic Water Flow\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"There is an m x n rectangular island that borders both the Pacific Ocean and Atlantic Ocean. The Pacific Ocean touches the island's left and top edges, and the Atlantic Ocean touches the island's right and bottom edges.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"graphs\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/pacific-atlantic-water-flow/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\":[],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nThere is an m x n rectangular island that borders both the** Pacific Ocean** and Atlantic Ocean. The Pacific Ocean touches the island's left and top edges, and the Atlantic Ocean touches the island's right and bottom edges.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nThe island is partitioned into a grid of square cells. You are given an m x n integer matrix heights where heights[r][c] represents the **height above sea level** of the cell at coordinate (r, c).\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nThe island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell's height is **less than or equal to** the current cell's height. Water can flow from any cell adjacent to an ocean into the ocean.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nReturn a **2D list** of grid coordinates result where result[i] = [ri, ci] denotes that rain water can flow from cell (ri, ci) to **both** the Pacific and Atlantic oceans.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2021/06/08/waterflow-grid.jpg)\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation: The following cells can flow to the Pacific and Atlantic oceans, as shown below:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n[0,4]: [0,4] -> Pacific Ocean \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n       [0,4] -> Atlantic Ocean\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n[1,3]: [1,3] -> [0,3] -> Pacific Ocean \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n       [1,3] -> [1,4] -> Atlantic Ocean\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n[1,4]: [1,4] -> [1,3] -> [0,3] -> Pacific Ocean \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n       [1,4] -> Atlantic Ocean\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n[2,2]: [2,2] -> [1,2] -> [0,2] -> Pacific Ocean \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n       [2,2] -> [2,3] -> [2,4] -> Atlantic Ocean\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n[3,0]: [3,0] -> Pacific Ocean \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n       [3,0] -> [4,0] -> Atlantic Ocean\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n[3,1]: [3,1] -> [3,0] -> Pacific Ocean \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n       [3,1] -> [4,1] -> Atlantic Ocean\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n[4,0]: [4,0] -> Pacific Ocean \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n       [4,0] -> Atlantic Ocean\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nNote that there are other possible paths for these cells to flow to the Pacific and Atlantic oceans.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: heights = [[1]]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: [[0,0]]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation: The water can flow from the only cell to the Pacific and Atlantic oceans.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- m == heights.length\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- n == heights[r].length\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 1 <= m, n <= 200\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 0 <= heights[r][c] <= 10^5\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"pacific-atlantic-water-flow\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"palindrome-partitioning\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Palindrome Partitioning\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/palindrome-partitioning/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\":[],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nGiven a string `s`, partition `s` such that every substring of the partition is a **palindrome**. Return all possible palindrome partitioning of `s`.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: s = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"aab\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: [[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"a\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"a\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"b\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"aa\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"b\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: s = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"a\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: [[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"a\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 1 <= s.length <= 16 \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- `s` contains only lowercase English letters.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"palindrome-partitioning\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"permutations\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Permutations\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"backtracking\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/permutations/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\":[],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nGiven an array `nums` of distinct integers, return all the possible permutations. You can return the answer **in any order**.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: nums = [1,2,3]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: nums = [0,1]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: [[0,1],[1,0]]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 3\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: nums = [1]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: [[1]]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 1 <= nums.length <= 6 \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- -10 <= nums[i] <= 10 \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- All the integers of nums are unique.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"permutations\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"prompt\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"add-two-numbers\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Add Two Numbers\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"linked-list\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/add-two-numbers/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2020/10/02/addtwonumber1.jpg\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/10/02/addtwonumber1.jpg)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: l1 = [2,4,3], l2 = [5,6,4]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: [7,0,8]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation: 342 + 465 = 807.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: l1 = [0], l2 = [0]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: [0]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 3\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: [8,9,9,9,0,0,0,1]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- The number of nodes in each linked list is in the range [1, 100]. \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 0 <= Node.val <= 9 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- It is guaranteed that the list represents a number that does not have leading zeros.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"add-two-numbers\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"balanced-binary-tree\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Balanced Binary Tree\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Given a binary tree, determine if it is height-balanced.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"easy\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"binary-tree\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/balanced-binary-tree/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nGiven a binary tree, determine if it is height-balanced.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: root = [3,9,20,null,null,15,7]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: true\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: root = [1,2,2,3,3,null,null,4,4]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: false\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 3\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: root = []\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: true\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- The number of nodes in the tree is in the range [0, 5000]. \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- -10^4 <= Node.val <= 10^4\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"balanced-binary-tree\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"binary-search\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Binary Search\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"binary-search\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/binary-search/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nGiven an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYou must write an algorithm with O(log n) runtime complexity.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: nums = [-1,0,3,5,9,12], target = 9\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: 4\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation: 9 exists in nums and its index is 4\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: nums = [-1,0,3,5,9,12], target = 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: -1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation: 2 does not exist in nums so return -1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n-     1 <= nums.length <= 104\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n-     -104 < nums[i], target < 104\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n-     All the integers in nums are unique.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n-     uunums is sorted in ascending order.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"binary-search\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"binary-tree-level-order-traversal\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Binary Tree Level Order Traversal\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"binary-tree\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/binary-tree-level-order-traversal/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nGiven the `root` of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: root = [3,9,20,null,null,15,7]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: [[3],[9,20],[15,7]]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: root = [1]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: [[1]]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- The number of nodes in the tree is in the range [0, 2000]. \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- -1000 <= Node.val <= 1000\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"binary-tree-level-order-traversal\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"binary-tree-maximum-path-sum\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Binary Tree Maximum Path Sum\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Given the root of a binary tree, return the maximum path sum of any non-empty path.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"hard\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"binary-tree\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/binary-tree-maximum-path-sum/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nA path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nThe path sum of a path is the sum of the node's values in the path.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nGiven the root of a binary tree, return the maximum path sum of any non-empty path.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: root = [1,2,3]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: 6\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation: The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: root = [-10,9,20,null,null,15,7]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: 42\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation: The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- The number of nodes in the tree is in the range [1, 3 * 10^4]. \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- -1000 <= Node.val <= 1000\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"binary-tree-maximum-path-sum\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"binary-tree-right-side-view\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Binary Tree Right Side View\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"binary-tree\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/binary-tree-right-side-view/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2021/02/14/tree.jpg\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nGiven the `root` of a binary tree, imagine yourself standing on the **right side** of it, return the values of the nodes you can see ordered from top to bottom.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2021/02/14/tree.jpg)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: root = [1,2,3,null,5,null,4]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: [1,3,4]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: root = [1,null,3]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: [1,3]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- The number of nodes in the tree is in the range [0, 100]. \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- -100 <= Node.val <= 100\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"binary-tree-right-side-view\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"car-fleet\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Car Fleet\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"There are n cars going to the same destination along a one-lane road. The destination is target miles away.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"stack\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/car-fleet/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nThere are `n` cars going to the same destination along a one-lane road. The destination is `target` miles away.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYou are given two integer array position and speed, both of length n, where position[i] is the position of the ith car and speed[i] is the speed of the ith car (in miles per hour).\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nA car can never pass another car ahead of it, but it can catch up to it and drive bumper to bumper at the same speed. The faster car will slow down to match the slower car's speed. The distance between these two cars is ignored (i.e., they are assumed to have the same position).\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nA car fleet is some non-empty set of cars driving at the same position and same speed. Note that a single car is also a car fleet.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nIf a car catches up to a car fleet right at the destination point, it will still be considered as one car fleet.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nReturn the number of car fleets that will arrive at the destination.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: 3\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nThe cars starting at 10 (speed 2) and 8 (speed 4) become a fleet, meeting each other at 12.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nThe car starting at 0 does not catch up to any other car, so it is a fleet by itself.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nThe cars starting at 5 (speed 1) and 3 (speed 3) become a fleet, meeting each other at 6. The fleet moves at speed 1 until it reaches target.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nNote that no other cars meet these fleets before the destination, so the answer is 3.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: target = 10, position = [3], speed = [3]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation: There is only one car, hence there is only one fleet.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 3\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: target = 100, position = [0,2,4], speed = [4,2,1]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nThe cars starting at 0 (speed 4) and 2 (speed 2) become a fleet, meeting each other at 4. The fleet moves at speed 2.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nThen, the fleet (speed 2) and the car starting at 4 (speed 1) become one fleet, meeting each other at 6. The fleet moves at speed 1 until it reaches target.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n-      n == position.length == speed.length     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n-      1 <= n <= 105\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n-      0 < target <= 106\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n-      0 <= position[i] < target\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n-      All the values of position are unique.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n-      0 < speed[i] <= 106\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"car-fleet\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"character-replacement\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Character Replacement\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Longest Repeating Character Replacement\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"sliding-window\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYou are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nReturn the length of the longest substring containing the same letter you can get after performing the above operations.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: s = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"ABAB\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", k = 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: 4\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation: Replace the two 'A's with two 'B's or vice versa.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: s = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"AABABBA\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", k = 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: 4\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation: Replace the one 'A' in the middle with 'B' and form \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"AABBBBA\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\".\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nThe substring \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"BBBB\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" has the longest repeating letters, which is 4.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 1 <= s.length <= 105\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- s consists of only uppercase English letters.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 0 <= k <= s.length\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"character-replacement\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"clone-graph\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Clone Graph\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"graphs\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":null,\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nGiven an `m x n` 2D binary grid `grid` which represents a map of `'1's` (land) and `'0's` (water), return the number of islands.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nAn **island** is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: grid = [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n  [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n  [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n  [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n  [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n-\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"clone-graph\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"combination-sum-ii\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Combination Sum II\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"backtracking\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":null,\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nGiven a collection of candidate numbers (`candidates`) and a target number (`target`), find all unique combinations in `candidates` where the candidate numbers sum to target.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nEach number in candidates may only be used **once** in the combination.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n**Note**: The solution set must not contain duplicate combinations.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: candidates = [10,1,2,7,6,1,5], target = 8\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n[1,1,6],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n[1,2,5],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n[1,7],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n[2,6]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: candidates = [2,5,2,1,2], target = 5\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n[1,2,2],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n[5]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 1 <= candidates.length <= 100 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 1 <= candidates[i] <= 50 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 1 <= target <= 30\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"combination-sum-ii\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"combination-sum\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Combination Sum\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"The test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"backtracking\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/combination-sum/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nGiven an array of **distinct** integers candidates and a target integer target, return a list of all **unique combinations** of candidates where the chosen numbers sum to target. You may return the combinations in **any order**.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nThe **same** number may be chosen from candidates an **unlimited number of times**. Two combinations are unique if the frequency of at least one of the chosen numbers is different.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nThe test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: candidates = [2,3,6,7], target = 7\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: [[2,2,3],[7]]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n7 is a candidate, and 7 = 7.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nThese are the only two combinations.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: candidates = [2,3,5], target = 8\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: [[2,2,2,2],[2,3,3],[3,5]]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 1 <= candidates.length <= 30\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 2 <= candidates[i] <= 40\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- All elements of candidates are distinct.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 1 <= target <= 40\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"combination-sum\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"construct-binary-tree-from-preorder-and-inorder-traversal\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Construct Binary Tree from Preorder and Inorder Traversal\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"binary-tree\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2021/02/19/tree.jpg\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nGiven two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: [3,9,20,null,null,15,7]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: preorder = [-1], inorder = [-1]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: [-1]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 1 <= preorder.length <= 3000 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- inorder.length == preorder.length\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- -3000 <= preorder[i], inorder[i] <= 3000 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- preorder and inorder consist of unique values. \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- Each value of inorder also appears in preorder. \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- preorder is guaranteed to be the preorder traversal of the tree. \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- inorder is guaranteed to be the inorder traversal of the tree.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"construct-binary-tree-from-preorder-and-inorder-traversal\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"container-with-most-water\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Container With Most Water\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A container with most water example\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"two-pointers\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"## Container With Most Water\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYou are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nReturn the maximum amount of water a container can store.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nNotice that you may not slant the container.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n![](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: height = [1,8,6,2,5,4,8,3,7]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: 49\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: height = [1,1]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"container-with-most-water\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"copy-list-with-random-pointer\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Copy List with Random Pointer\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"linked-list\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/copy-list-with-random-pointer/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2019/12/18/e1.png\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2019/12/18/e2.png\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2019/12/18/e3.png\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nA linked list of length `n` is given such that each node contains an additional random pointer, which could point to any node in the list, or `null`.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nConstruct a deep copy of the list. The deep copy should consist of exactly n **brand new **nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. **None of the pointers in the new list should point to nodes in the original list.**\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nFor example, if there are two nodes X and Y in the original list, where X.random --> Y, then for the corresponding two nodes x and y in the copied list, x.random --> y.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nReturn the head of the copied linked list.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nThe linked list is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- `val`: an integer representing `Node.val`\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- `random_index`: the index of the node (range from `0` to `n-1`) that the `random pointer` points to, or null if it does not point to any node.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYour code will **only** be given the head of the original linked list.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2019/12/18/e1.png)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: [[7,null],[13,0],[11,4],[10,2],[1,0]]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2019/12/18/e2.png)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: head = [[1,1],[2,1]]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: [[1,1],[2,1]]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 3\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2019/12/18/e3.png)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: head = [[3,null],[3,0],[3,null]]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: [[3,null],[3,0],[3,null]]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 0 <= n <= 1000\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- -104 <= Node.val <= 104\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- Node.random is null or is pointing to some node in the linked list.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"copy-list-with-random-pointer\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"count-good-nodes-in-binary-tree\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Count Good Nodes in Binary Tree\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Given a binary tree root, a node X in the tree is named good if in the path from root to X there are no nodes with a value greater than X.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"binary-tree\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/count-good-nodes-in-binary-tree/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2020/04/02/test_sample_1.png\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2020/04/02/test_sample_2.png\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nGiven a binary tree root, a node X in the tree is named good if in the path from root to X there are no nodes with a value greater than X.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nReturn the number of **good** nodes in the binary tree.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/04/02/test_sample_1.png)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: root = [3,1,4,3,null,1,5]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: 4\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation: Nodes in blue are good.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nRoot Node (3) is always a good node.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nNode 4 -> (3,4) is the maximum value in the path starting from the root.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nNode 5 -> (3,4,5) is the maximum value in the path\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nNode 3 -> (3,1,3) is the maximum value in the path.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/04/02/test_sample_2.png)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: root = [3,3,null,4,2]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: 3\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation: Node 2 -> (3, 3, 2) is not good, because \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"3\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" is higher than it.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 3\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: root = [1]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation: Root is considered as good.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- The number of nodes in the binary tree is in the range [1, 10^5]. \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- Each node's value is between [-10^4, 10^4].\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"count-good-nodes-in-binary-tree\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"course-schedule-ii\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Course Schedule II\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Return the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"graph\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"topological-sort\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/course-schedule-ii/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nThere are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where `prerequisites[i] = [ai, bi]` indicates that you must take course bi first if you want to take course ai.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nFor example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nReturn the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return **an empty array**.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: numCourses = 2, prerequisites = [[1,0]]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: [0,1]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: [0,2,1,3]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nSo one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 3\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: numCourses = 1, prerequisites = []\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: [0]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 1 <= numCourses <= 2000 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 0 <= prerequisites.length <= numCourses * (numCourses - 1)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- prerequisites[i].length == 2 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 0 <= ai, bi < numCourses \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- ai != bi \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- All the pairs [ai, bi] are distinct.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"course-schedule-ii\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"course-schedule\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Course Schedule\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Return true if you can finish all courses. Otherwise, return false.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"graph\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"topological-sort\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/course-schedule/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nThere are a total of `numCourses` courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where `prerequisites[i] = [ai, bi]` indicates that you **must** take course bi first if you want to take course ai.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nFor example, the pair `[0, 1]`, indicates that to take course 0 you have to first take course 1.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nReturn true if you can finish all courses. Otherwise, return `false`.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: numCourses = 2, prerequisites = [[1,0]]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: true\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation: There are a total of 2 courses to take. \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nTo take course 1 you should have finished course 0. So it is possible.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: numCourses = 2, prerequisites = [[1,0],[0,1]]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: false\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation: There are a total of 2 courses to take. \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nTo take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 1 <= numCourses <= 2000 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 0 <= prerequisites.length <= 5000 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- prerequisites[i].length == 2 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 0 <= ai, bi < numCourses \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- All the pairs prerequisites[i] are unique.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"course-schedule\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"daily-temperatures\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Daily Temperatures\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"stack\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"sliding-window\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/daily-temperatures/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nGiven an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: temperatures = [73,74,75,71,69,72,76,73]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: [1,1,4,2,1,1,0,0]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: temperatures = [30,40,50,60]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: [1,1,1,0]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n-     1 <= temperatures.length <= 105\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n-     30 <= temperatures[i] <= 100\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"daily-temperatures\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"design-add-and-search-words-data-structure\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Design Add and Search Words Data Structure\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Design a data structure that supports adding new words and finding if a string matches any previously added string.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"trie\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/design-add-and-search-words-data-structure/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nDesign a data structure that supports adding new words and finding if a string matches any previously added string.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nImplement the `WordDictionary` class:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- WordDictionary() Initializes the object.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- void addWord(word) Adds word to the data structure, it can be matched later.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- bool search(word) Returns true if there is any string in the data structure that matches word or false otherwise. word may contain dots '.' where dots can be matched with any letter.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"WordDictionary\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"addWord\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"addWord\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"addWord\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"search\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"search\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"search\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"search\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n[[],[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bad\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"dad\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"mad\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"pad\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bad\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\".ad\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"b..\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n[null,null,null,null,false,true,true,true]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nWordDictionary wordDictionary = new WordDictionary();\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nwordDictionary.addWord(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bad\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\");\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nwordDictionary.addWord(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"dad\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\");\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nwordDictionary.addWord(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"mad\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\");\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nwordDictionary.search(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"pad\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"); // return False\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nwordDictionary.search(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bad\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"); // return True\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nwordDictionary.search(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\".ad\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"); // return True\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nwordDictionary.search(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"b..\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"); // return True\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 1 <= word.length <= 25\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- word in addWord consists of lowercase English letters.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- word in search consist of '.' or lowercase English letters.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- There will be at most 3 dots in word for search queries.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- At most 104 calls will be made to addWord and search.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"design-add-and-search-words-data-structure\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"design-twitter\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Design Twitter\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/design-twitter/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"heap\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/design-twitter/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nDesign a simplified version of Twitter where users can post tweets, follow/unfollow another user, and is able to see the 10 most recent tweets in the user's news feed.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nImplement the `Twitter` class:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- Twitter() Initializes your twitter object.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- void postTweet(int userId, int tweetId) Composes a new tweet with ID tweetId by the user userId. Each call to this function will be made with a unique tweetId.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- List<Integer> getNewsFeed(int userId) Retrieves the 10 most recent tweet IDs in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user themself. Tweets must be ordered from most recent to least recent.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- void follow(int followerId, int followeeId) The user with ID followerId started following the user with ID followeeId.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- void unfollow(int followerId, int followeeId) The user with ID followerId started unfollowing the user with ID followeeId.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Twitter\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"postTweet\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"getNewsFeed\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"follow\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"postTweet\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"getNewsFeed\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"unfollow\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"getNewsFeed\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n[[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n[null, null, [5], null, null, [6, 5], null, [5]]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nTwitter twitter = new Twitter();\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ntwitter.postTweet(1, 5); // User 1 posts a new tweet (id = 5).\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ntwitter.getNewsFeed(1);  // User 1's news feed should return a list with 1 tweet id -> [5]. return [5]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ntwitter.follow(1, 2);    // User 1 follows user 2.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ntwitter.postTweet(2, 6); // User 2 posts a new tweet (id = 6).\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ntwitter.getNewsFeed(1);  // User 1's news feed should return a list with 2 tweet ids -> [6, 5]. Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ntwitter.unfollow(1, 2);  // User 1 unfollows user 2.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ntwitter.getNewsFeed(1);  // User 1's news feed should return a list with 1 tweet id -> [5], since user 1 is no longer following user 2.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 1 <= userId, followerId, followeeId <= 500\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 0 <= tweetId <= 10^4\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- All the tweets have unique IDs.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- At most 3 * 10^4 calls will be made to postTweet, getNewsFeed, follow, and unfollow.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"design-twitter\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"diameter-of-binary-tree\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Diameter of Binary Tree\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Given the root of a binary tree, return the length of the diameter of the tree.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"easy\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"binary-tree\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/diameter-of-binary-tree/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nGiven the `root` of a binary tree, return the **length** of the diameter of the tree.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nThe **diameter** of a binary tree is the **length** of the longest path between any two nodes in a tree. This path may or may not pass through the root.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nThe **length** of a path between two nodes is represented by the number of edges between them.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: root = [1,2,3,4,5]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: 3\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation: 3 is the length of the path [4,2,1,3] or [5,2,1,3].\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: root = [1,2]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- The number of nodes in the tree is in the range [1, 104]. \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- -100 <= Node.val <= 100\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"diameter-of-binary-tree\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"evaluate-polish-reverse-notation\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Evaluate Reverse Polish Notation\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation.  Evaluate the expression. Return an integer that represents the value of the expression.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"stack\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/evaluate-reverse-polish-notation/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYou are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nEvaluate the expression. Return an integer that represents the value of the expression.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nNote that:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    The valid operators are '+', '-', '*', and '/'.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Each operand may be an integer or another expression.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    The division between two integers always truncates toward zero.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    There will not be any division by zero.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    The input represents a valid arithmetic expression in a reverse polish notation.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    The answer and all the intermediate calculations can be represented in a 32-bit integer.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: tokens = [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"+\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"3\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: 9\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation: ((2 + 1) * 3) = 9\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: tokens = [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"4\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"13\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"5\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"+\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: 6\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation: (4 + (13 / 5)) = 6\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 1 <= tokens.length <= 104\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- tokens[i] is either an operator: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"+\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"-\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", or \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", or an integer in the range [-200, 200].\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"evaluate-polish-reverse-notation\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"find-median-from-data-stream\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Find Median from Data Stream\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"hard\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"heap\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/find-median-from-data-stream/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nThe **median** is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- For example, for arr = [2,3,4], the median is 3.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- For example, for arr = [2,3], the median is (2 + 3) / 2 = 2.5.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nImplement the MedianFinder class:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- MedianFinder() initializes the MedianFinder object.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- void addNum(int num) adds the integer num from the data stream to the data structure.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- double findMedian() returns the median of all elements so far. Answers within 10-5 of the actual answer will be accepted.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"MedianFinder\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"addNum\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"addNum\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"findMedian\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"addNum\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"findMedian\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n[[], [1], [2], [], [3], []]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n[null, null, null, 1.5, null, 2.0]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nMedianFinder medianFinder = new MedianFinder();\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nmedianFinder.addNum(1);    // arr = [1]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nmedianFinder.addNum(2);    // arr = [1, 2]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nmedianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nmedianFinder.addNum(3);    // arr[1, 2, 3]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nmedianFinder.findMedian(); // return 2.0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- -10^5 <= num <= 10^5 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- There will be at least one element in the data structure before calling findMedian. \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- At most 5 * 10^4 calls will be made to addNum and findMedian.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Follow up:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- If all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- If 99% of all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"find-median-from-data-stream\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"find-min\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Find Minimum in Rotated Sorted Array\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Given the sorted rotated array nums of unique elements, return the minimum element of this array.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"binary-search\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nSuppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    `[4,5,6,7,0,1,2]` if it was rotated 4 times.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    `[0,1,2,4,5,6,7]` if it was rotated 7 times.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nNotice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nGiven the sorted rotated array nums of unique elements, return the minimum element of this array.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYou must write an algorithm that runs in O(log n) time.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: nums = [3,4,5,1,2]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation: The original array was [1,2,3,4,5] rotated 3 times.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: nums = [4,5,6,7,0,1,2]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: 0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n-      n == nums.length     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n-      1 <= n <= 5000     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n-      -5000 <= nums[i] <= 5000     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n-      All the integers of nums are unique.     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n-      nums is sorted and rotated between 1 and n times.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"find-min\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"find-the-duplicate-number\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Find the Duplicate Number\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"linked-list\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/find-the-duplicate-number/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nGiven an array of integers nums containing `n + 1` integers where each integer is in the range `[1, n]` inclusive.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nThere is only **one repeated number** in nums, return this repeated number.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYou must solve the problem **without** modifying the array nums and uses only constant extra space.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: nums = [1,3,4,2,2]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: nums = [3,1,3,4,2]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: 3\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 1 <= n <= 10^5 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- nums.length == n + 1 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 1 <= nums[i] <= n \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- All the integers in nums appear only **once** except for **precisely one** **integer** which appears **two or more** times.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"find-the-duplicate-number\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"generate-parenthesis\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Generate Parentheses\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"stack\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"backtracking\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":null,\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nGiven n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: n = 3\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"((()))\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"(()())\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"(())()\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"()(())\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"()()()\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: n = 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"()\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 1 <= n <= 8\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"generate-parenthesis\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"hello-world\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Hello World\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A simple hello world example\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"sample\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"This is  a simple hello world example.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n$ dsa run hello-world.js\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"hello-world\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"implement-trie-prefix-tree\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Trie\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A trie (pronounced as \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"try\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\") or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"trie\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/implement-trie-prefix-tree/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nA trie (pronounced as \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"try\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\") or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nImplement the Trie class:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- Trie() Initializes the trie object.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- void insert(String word) Inserts the string word into the trie.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- boolean search(String word) Returns true if the string word is in the trie (i.e., was inserted before), and false otherwise.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- boolean startsWith(String prefix) Returns true if there is a previously nserted string word that has the prefix prefix, and false otherwise.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Trie\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"insert\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"search\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"search\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"startsWith\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"insert\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"search\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n[[], [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"apple\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"], [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"apple\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"], [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"app\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"], [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"app\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"], [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"app\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"], [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"app\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n[null, null, true, false, true, null, true]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nTrie trie = new Trie();\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ntrie.insert(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"apple\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\");\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ntrie.search(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"apple\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\");   // return True\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ntrie.search(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"app\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\");     // return False\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ntrie.startsWith(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"app\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"); // return True\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ntrie.insert(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"app\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\");\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ntrie.search(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"app\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\");     // return True\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 1 <= word.length, prefix.length <= 2000 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- word and prefix consist only of lowercase English letters. \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- At most 3 * 104 calls in total will be made to insert, search, and startsWith.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"implement-trie-prefix-tree\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"index\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"const { getFilesInDirectory, getDirAbsoluteUri } = require('../functions');\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nconst md2json = require('markdown-to-json');\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nconst fs = require('fs');\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nconst DEBUG = false;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nconst PROMPT_FILE = 'prompt.json';\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nconst options = {\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    minify: false,\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    width: DEBUG ? 0 : 9000000,\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    outfile: null,\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n};\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n/**\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n * Creates a compiled json file from all the markdown files in the prompt directory\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n */\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nconst createCompiledJson = () => {\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    let parsed_prompt_dict = {};\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    getFilesInDirectory('./prompt/')\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        .then((files) => {\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            const absolutePathForFiles = files.map((file) => {\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                return getDirAbsoluteUri(file, './prompt/');\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            });\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            if (DEBUG) console.log(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"absolutePathForFiles: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", absolutePathForFiles);\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            const promptsData = md2json.parse(absolutePathForFiles, options);\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            if (DEBUG) console.log(promptsData);\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            parsed_prompt_dict = JSON.parse(promptsData);\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            // Object.values(parsed_prompt_dict).map((prompt) => {\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            //     prompt.preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            // });\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            // console.log(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"promptsData: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", parsed_prompt_dict);\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            // Save as a json\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            const json = JSON.stringify(parsed_prompt_dict);\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            const prompt_file_path = getDirAbsoluteUri(PROMPT_FILE, './prompt/');\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            fs.writeFile(prompt_file_path, json, (err) => {\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                if (err) throw err;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                console.log('The file has been saved!');\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            });\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        })\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        .catch((error) => {\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            console.error(error);\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        });\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n};\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nconst getLatestModified = async () => {\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    const files = await getFilesInDirectory('./prompt/');\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    let latestModified = null;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    let latestFile = null;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    const absolutePathForFiles = files.map((file) => {\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        return getDirAbsoluteUri(file, './prompt/');\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    });\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    for (const file of absolutePathForFiles) {\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        const stats = await fs.promises.stat(file);\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        if (!latestModified || stats.mtime > latestModified) {\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            latestModified = stats.mtime;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            latestFile = file;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        }\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    return latestFile;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n};\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n/**\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n * Checks if prompt.json exists, if not, creates it, then returns the parsed json\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n * @param {String} prompt_slug - The slug of the prompt to return, if empty, returns all prompts\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n * @returns {Object} parsed_prompt_dict\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n */\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nconst getPromptDict = async (prompt_slug = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\") => {\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    // check if prompt.json exists\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    const prompt_file_path = getDirAbsoluteUri(PROMPT_FILE, './prompt/');\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if (!fs.existsSync(prompt_file_path)) {\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        createCompiledJson();\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    // If exists, check if it's the latest modified file, if not, update the prompt.json\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    const latestModified = await getLatestModified();\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    let parsed_prompt_dict;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if (latestModified !== prompt_file_path) {\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        console.log(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"latestModified: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", latestModified);\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        createCompiledJson();\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    try {\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        parsed_prompt_dict = require(prompt_file_path);\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    catch (e) {\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        // Delete the prompt.json file and try again\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        fs.unlinkSync(prompt_file_path);\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        // If it fails this time exit and print\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        try{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            parsed_prompt_dict = require(prompt_file_path);\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        }\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        catch (e) {\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            console.error(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Error: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", e);\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            process.exit(1);\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        }\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if (prompt_slug === \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\") {\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        return parsed_prompt_dict;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    return parsed_prompt_dict[prompt_slug];\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n};\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n(async () => {\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    const sample = await getPromptDict();\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if (DEBUG) console.log(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"sample: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", sample);\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n}\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n)();\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nmodule.exports = { getPromptDict, createCompiledJson };\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n// const parsed_prompt_dict = require(PROMPT_FILE);\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n// module.exports = parsed_prompt_dict;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"index\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"invert-binary-tree\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Invert Binary Tree\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Given the `root` of a binary tree, invert the tree, and return its root.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"easy\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"binary-tree\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/invert-binary-tree/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nGiven the root of a binary tree, invert the tree, and return its root.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: root = [4,2,7,1,3,6,9]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: [4,7,2,9,6,3,1]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: root = [2,1,3]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: [2,3,1]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 3\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: root = []\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: []\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- The number of nodes in the tree is in the range [0, 100]. \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- -100 <= Node.val <= 100\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"invert-binary-tree\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"k-closest\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"k closest points to origin\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane and an integer k, return the k closest points to the origin (0, 0).\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"heap\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/k-closest-points-to-origin/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2021/03/03/closestplane1.jpg\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nGiven an array of points where `points[i] = [xi, yi]` represents a point on the **X-Y** plane and an integer k, return the k closest points to the origin (0, 0).\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nThe distance between two points on the X-Y plane is the Euclidean distance (i.e., âˆš(x1 - x2)2 + (y1 - y2)2).\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYou may return the answer in **any order**. The answer is **guaranteed** to be **unique** (except for the order that it is in).\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2021/03/03/closestplane1.jpg)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: points = [[1,3],[-2,2]], k = 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: [[-2,2]]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nThe distance between (1, 3) and the origin is sqrt(10).\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nThe distance between (-2, 2) and the origin is sqrt(8).\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nSince sqrt(8) < sqrt(10), (-2, 2) is closer to the origin.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nWe only want the closest k = 1 points from the origin, so the answer is just [[-2,2]].\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: points = [[3,3],[5,-1],[-2,4]], k = 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: [[3,3],[-2,4]]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation: The answer [[-2,4],[3,3]] would also be accepted.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 1 <= k <= points.length <= 104\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- -104 < xi, yi < 104\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"k-closest\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"key-based-value-store\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Time Based Key-value Store\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Design a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the key's value at a certain timestamp.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"binary-search\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/time-based-key-value-store/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nDesign a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the key's value at a certain timestamp.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nImplement the TimeMap class:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- `TimeMap()` Initializes the object of the data structure\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- `void set(String key, String value, int timestamp)` Stores the key `key` with the value `value` at the given time timestamp.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- `String get(String key, int timestamp)` Returns a value such that set was called previously, with `timestamp_prev <= timestamp`. If there are multiple such values, it returns the value associated with the largest `timestamp_prev`. If there are no values, it returns `\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"`.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"TimeMap\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"set\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"get\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"get\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"set\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"get\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"get\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n[[], [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"foo\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bar\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", 1], [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"foo\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", 1], [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"foo\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", 3], [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"foo\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bar2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", 4], [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"foo\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", 4], [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"foo\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", 5]]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n[null, null, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bar\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bar\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", null, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bar2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bar2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nTimeMap timeMap = new TimeMap();\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ntimeMap.set(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"foo\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bar\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", 1);  // store the key \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"foo\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" and value \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bar\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" along with timestamp = 1.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ntimeMap.get(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"foo\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", 1);         // return \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bar\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ntimeMap.get(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"foo\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", 3);         // return \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bar\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", since there is no value corresponding to foo at timestamp 3 and timestamp 2, then the only value is at timestamp 1 is \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bar\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\".\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ntimeMap.set(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"foo\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bar2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", 4); // store the key \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"foo\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" and value \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bar2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" along with timestamp = 4.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ntimeMap.get(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"foo\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", 4);         // return \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bar2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ntimeMap.get(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"foo\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", 5);         // return \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bar2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n-      1 <= key.length, value.length <= 100     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n-      key and value consist of lowercase English letters and digits.     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n-      1 <= timestamp <= 107     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n-      All the timestamps timestamp of set are strictly increasing.     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n-      At most 2 * 105 calls will be made to set and get.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"key-based-value-store\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"koko-eating-bananas\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"koko-eating-bananas\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Return the minimum integer k such that she can eat all the bananas within h hours.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"binary-search\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/koko-eating-bananas/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nKoko loves to eat bananas. There are `n` piles of bananas, the ith pile has `piles[i]` bananas. The guards have gone and will come back in `h` hours.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nKoko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nKoko likes to eat slowly but still wants to finish eating all the bananas before the guards return.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nReturn the minimum integer `k` such that she can eat all the bananas within `h` hours.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: piles = [3,6,7,11], h = 8\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: 4\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: piles = [30,11,23,4,20], h = 5\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: 30\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 3\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: piles = [30,11,23,4,20], h = 6\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: 23\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n-      1 <= piles.length <= 104     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n-      piles.length <= h <= 109     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n-      1 <= piles[i] <= 109\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"koko-eating-bananas\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"kth-largest-element-in-an-array\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"kth largest elements in a stream\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Given an integer array nums and an integer k, return the kth largest element in the array.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"heap\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/kth-largest-element-in-an-array/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nGiven an integer array nums and an integer `k`, return the `kth` largest element in the array.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nNote that it is the `kth` largest element in the sorted order, not the `kth` distinct element.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYou must solve it in `O(n)` time complexity.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: nums = [3,2,1,5,6,4], k = 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: 5\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: nums = [3,2,3,1,2,4,5,5,6], k = 4\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: 4\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 1 <= k <= nums.length <= 10^5 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- -10^4 <= nums[i] <= 10^4\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"kth-largest-element-in-an-array\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"kth-smallest-element-in-a-bst\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Kth Smallest Element in a BST\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Given the root of a binary search tree, and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"binary-tree\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/kth-smallest-element-in-a-bst/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nGiven the `root` of a binary search tree, and an integer k, return the kth smallest value (**1-indexed**) of all the values of the nodes in the tree.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: root = [3,1,4,null,2], k = 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: root = [5,3,6,2,4,null,null,1], k = 3\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: 3\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- The number of nodes in the tree is n.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 1 <= k <= n <= 104\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 0 <= Node.val <= 104\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"kth-smallest-element-in-a-bst\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"largest-rectangle-area\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Largest Rectangle in Histogram\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Given an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"stack\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/largest-rectangle-in-histogram/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nGiven an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n![image](https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: heights = [2,1,5,6,2,3]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: 10\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation: The above is a histogram where width of each bar is 1.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nThe largest rectangle is shown in the red area, which has an area = 10 units.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n![image](https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: heights = [2,4]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: 4\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n-      1 <= heights.length <= 105     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n-      0 <= heights[i] <= 104\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"largest-rectangle-area\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"last-stone-weight\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Last Stone Weight\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"You are given an array of integers stones where stones[i] is the weight of the ith stone.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"easy\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"heap\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/last-stone-weight/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYou are given an array of integers stones where `stones[i]` is the weight of the ith stone.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nWe are playing a game with the stones. On each turn, we choose the **heaviest two stones** and smash them together. Suppose the heaviest two stones have weights x and y with x <= y. The result of this smash is:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- If x == y, both stones are destroyed, and\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- If x != y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nAt the end of the game, there is **at most one** stone left.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nReturn the weight of the last remaining stone. If there are no stones left, return 0.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: stones = [2,7,4,1,8,1]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nWe combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then,\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nwe combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then,\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nwe combine 2 and 1 to get 1 so the array converts to [1,1,1] then,\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nwe combine 1 and 1 to get 0 so the array converts to [1] then that's the value of the last stone.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: stones = [1]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 1 <= stones.length <= 30 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 1 <= stones[i] <= 1000\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"last-stone-weight\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"length-of-longest-substring\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Length of Longest Substring\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Given a string s, find the length of the longest substring without repeating characters.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"sliding-window\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nGiven a string s, find the length of the longest substring without repeating characters.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: s = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"abcabcbb\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: 3\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation: The answer is \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"abc\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", with the length of 3.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: s = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bbbbb\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation: The answer is \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"b\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", with the length of 1.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 3\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: s = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"pwwkew\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: 3\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation: The answer is \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"wke\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", with the length of 3.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nNotice that the answer must be a substring, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"pwke\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" is a subsequence and not a substring.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 0 <= s.length <= 5 * 104\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- s consists of English letters, digits, symbols and spaces.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"length-of-longest-substring\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"letter-combinations-of-a-phone-number\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Palindrome Partitioning\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"hard\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"backtracking\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/letter-combinations-of-a-phone-number/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nGiven a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in **any order**.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nA mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n![Example 1](https://assets.leetcode.com/uploads/2022/03/15/1200px-telephone-keypad2svg.png)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: digits = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"23\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"ad\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"ae\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"af\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bd\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"be\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bf\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"cd\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"ce\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"cf\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: digits = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: []\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 3\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: digits = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"a\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"b\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"c\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 0 <= digits.length <= 4\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- digits[i] is a digit in the range ['2', '9']\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"letter-combinations-of-a-phone-number\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"linked-list-cycle\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Linked List Cycle\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Given head, the head of a linked list, determine if the linked list has a cycle in it.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"linked-list\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/linked-list-cycle/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nGiven `head`, the head of a linked list, determine if the linked list has a cycle in it.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. **Note that** pos **is not passed as a parameter**.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nReturn `true` if there is a cycle in the linked list. Otherwise, return `false`.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: head = [3,2,0,-4], pos = 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: true\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: head = [1,2], pos = 0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: true\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation: There is a cycle in the linked list, where the tail connects to the 0th node.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- The number of the nodes in the list is in the range [0, 104]. \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- -10^5 <= Node.val <= 10^5 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- pos is -1 or a valid index in the linked-list.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"linked-list-cycle\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"lru-cache\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"LRU Cache\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"linked-list\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/lru-cache/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nDesign a data structure that follows the constraints of a Least Recently Used (LRU) cache.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nImplement the `LRUCache` class:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- LRUCache(int capacity) Initialize the LRU cache with **positive** size capacity.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- `int get(int key)` Return the value of the key if the key exists, otherwise return -1.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- void `put(int key, int value)` Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, **evict** the least recently used key.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nThe functions get and put must each run in O(1) average time complexity.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"LRUCache\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"put\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"put\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"get\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"put\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"get\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"put\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"get\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"get\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"get\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n[null, null, null, 1, null, -1, null, -1, 3, 4]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nLRUCache lRUCache = new LRUCache(2);\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nlRUCache.put(1, 1); // cache is {1=1}\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nlRUCache.get(1);    // return 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nlRUCache.get(2);    // returns -1 (not found)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nlRUCache.get(1);    // return -1 (not found)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nlRUCache.get(3);    // return 3\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nlRUCache.get(4);    // return 4\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 1 <= capacity <= 3000\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 0 <= key <= 104\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 0 <= value <= 105\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- At most 2 * 105 calls will be made to get and put.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"lru-cache\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"max-area-of-island\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Max Area of Island\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"You are given an m x n binary matrix grid. An island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"graphs\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/max-area-of-island/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYou are given an m x n binary matrix grid. An island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nThe area of an island is the number of cells with a value 1 in the island.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nReturn the maximum area of an island in grid. If there is no island, return 0.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2021/05/01/maxarea1-grid.jpg)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: 6\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation: The answer is not 11, because the island must be connected 4-directionally.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: grid = [[0,0,0,0,0,0,0,0]]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: 0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- m == grid.length \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- n == grid[i].length \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 1 <= m, n <= 50 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- grid[i][j] is either 0 or 1.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"max-area-of-island\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"max-profit\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Max Profit\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Best time to Buy and Sell Stock\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"easy\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"sliding-window\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYou are given an array prices where prices[i] is the price of a given stock on the ith day.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: prices = [7,1,5,3,6,4]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: 5\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: prices = [7,6,4,3,1]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: 0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation: In this case, no transactions are done and the max profit = 0.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n-  1 <= prices.length <= 105\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n-  0 <= prices[i] <= 104\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"max-profit\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"max-sliding-window\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Max Sliding Window\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Sliding Window Maximum\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"hard\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"sliding-window\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/sliding-window-maximum/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYou are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.  Return the max sliding window.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: nums = [1,3,-1,-3,5,3,6,7], k = 3\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: [3,3,5,5,6,7]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nWindow position                Max\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n---------------               -----\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n[1  3  -1] -3  5  3  6  7       3\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n 1 [3  -1  -3] 5  3  6  7       3\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n 1  3 [-1  -3  5] 3  6  7       5\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n 1  3  -1 [-3  5  3] 6  7       5\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n 1  3  -1  -3 [5  3  6] 7       6\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n 1  3  -1  -3  5 [3  6  7]      7\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: nums = [1], k = 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: [1]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n-      1 <= nums.length <= 10^5     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n-      -10^4 <= nums[i] <= 10^4     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n-      1 <= k <= nums.length\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"max-sliding-window\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"maximum-depth-of-binary-tree\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Maximum Depth of Binary Tree\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"easy\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"binary-tree\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/maximum-depth-of-binary-tree/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nGiven the root of a binary tree, return its maximum depth.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nA binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: root = [3,9,20,null,null,15,7]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: 3\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: root = [1,null,2]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- The number of nodes in the tree is in the range [0, 104]. \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- -100 <= Node.val <= 100\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"maximum-depth-of-binary-tree\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"median-sorted-arrays\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Median of Two Sorted Arrays\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"hard\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"binary-search\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"array\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/median-of-two-sorted-arrays/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nGiven two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively, return **the median** of the two sorted arrays.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nThe overall run time complexity should be `O(log (m+n))`.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: nums1 = [1,3], nums2 = [2]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: 2.00000\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation: merged array = [1,2,3] and median is 2.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: nums1 = [1,2], nums2 = [3,4]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: 2.50000\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n-      nums1.length == m     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n-      nums2.length == n     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n-      0 <= m <= 1000     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n-      0 <= n <= 1000     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n-      1 <= m + n <= 2000     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n-      -106 <= nums1[i], nums2[i] <= 106\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"median-sorted-arrays\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"merge-k-sorted-list\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Merge k Sorted Lists\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"hard\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"linked-list\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/merge-k-sorted-lists/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYou are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nMerge all the linked-lists into one sorted linked-list and return it.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: lists = [[1,4,5],[1,3,4],[2,6]]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: [1,1,2,3,4,4,5,6]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation: The linked-lists are:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n  1->4->5,\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n  1->3->4,\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n  2->6\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nmerging them into one sorted list:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n1->1->2->3->4->4->5->6\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 3\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: lists = [[]]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: []\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- k == lists.length \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 0 <= k <= 10^4 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 0 <= lists[i].length <= 500 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- -10^4 <= lists[i][j] <= 10^4 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- lists[i] is sorted in **ascending order**. \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- The sum of lists[i].length will not exceed 10^4.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"merge-k-sorted-list\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"merge-two-sorted-list\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Merge Two Sorted Lists\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"You are given the heads of two sorted linked lists list1 and list2. Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"easy\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"linked-list\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/merge-two-sorted-lists/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYou are given the heads of two sorted linked lists list1 and list2.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nMerge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nReturn the head of the merged linked list.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: list1 = [1,2,4], list2 = [1,3,4]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: [1,1,2,3,4,4]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: list1 = [], list2 = []\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: []\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 3\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: list1 = [], list2 = [0]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: [0]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- The number of nodes in both lists is in the range [0, 50]. \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- -100 <= Node.val <= 100 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- Both list1 and list2 are sorted in non-decreasing order.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"merge-two-sorted-list\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"min-stack\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Min Stack\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Min Stack\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"stack\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/min-stack/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nDesign a stack that supports push, pop, top, and retrieving the minimum element in constant time.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nImplement the MinStack class:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    MinStack() initializes the stack object.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    void push(int val) pushes the element val onto the stack.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    void pop() removes the element on the top of the stack.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    int top() gets the top element of the stack.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    int getMin() retrieves the minimum element in the stack.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYou must implement a solution with O(1) time complexity for each function.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"MinStack\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"push\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"push\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"push\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"getMin\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"pop\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"top\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"getMin\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n[[],[-2],[0],[-3],[],[],[],[]]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n[null,null,null,null,-3,null,0,-2]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nMinStack minStack = new MinStack();\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nminStack.push(-2);\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nminStack.push(0);\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nminStack.push(-3);\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nminStack.getMin(); // return -3\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nminStack.pop();\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nminStack.top();    // return 0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nminStack.getMin(); // return -2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- -2^31 <= val <= 2^31 - 1     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- Methods pop, top and getMin operations will always be called on non-empty stacks.     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- At most 3 * 104 calls will be made to push, pop, top, and getMin.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"min-stack\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"min-window\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Min Window Substring\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\".\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"hard\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"sliding-window\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nGiven two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\".\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: s = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"ADOBECODEBANC\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", t = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"ABC\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"BANC\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation: The minimum window substring \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"BANC\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" includes 'A', 'B', and 'C' from string t.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: s = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"a\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", t = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"a\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"a\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation: The entire string s is the minimum window.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 3\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: s = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"a\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", t = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"aa\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation: Both 'a's from t must be included in the window.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nSince the largest window of s only has one 'a', return empty string.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n-      m == s.length     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n-      n == t.length     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n-      1 <= m, n <= 105     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n-      s and t consist of uppercase and lowercase English letters.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"min-window\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"n-queens\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"N-Queens\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"hard\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"backtracking\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/n-queens/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nThe **n-queens** puzzle is the problem of placing n queens on an `n x n` chessboard such that no two queens attack each other.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nGiven an integer n, return all distinct solutions to the **n-queens puzzle**. You may return the answer in **any order**.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nEach solution contains a distinct board configuration of the n-queens' placement, where `'Q'` and `'.'` both indicate a queen and an empty space, respectively.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/11/13/queens.jpg)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: n = 4\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: [[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\".Q..\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"...Q\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Q...\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"..Q.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"..Q.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Q...\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"...Q\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\".Q..\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation: There exist two distinct solutions to the 4-queens puzzle as shown above\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: n = 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: [[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Q\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- `1 <= n <= 9`\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"n-queens\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"number-of-connected-components-in-an-undirected-graph\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Redundant Connection\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"find the number of connected components in an undirected graph.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"graphs\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://cheonhyangzhang.gitbooks.io/leetcode-solutions/content/323-number-of-connected-components-in-an-undirected-graph.html\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nGiven n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to find the number of connected components in an undirected graph.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExample 1:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n     0          3\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n     |          |\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n     1 --- 2    4\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nGiven n = 5 and edges = [[0, 1], [1, 2], [3, 4]], return 2.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExample 2:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n     0           4\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n     |           |\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n     1 --- 2 --- 3\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nGiven n = 5 and edges = [[0, 1], [1, 2], [2, 3], [3, 4]], return 1.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nNote:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYou can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"number-of-connected-components-in-an-undirected-graph\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"number-of-islands\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Number of Islands\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"graphs\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":null,\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nGiven an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: grid = [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n  [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n  [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n  [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n  [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n-\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"number-of-islands\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"pacific-atlantic-water-flow\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Pacific Atlantic Water Flow\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"There is an m x n rectangular island that borders both the Pacific Ocean and Atlantic Ocean. The Pacific Ocean touches the island's left and top edges, and the Atlantic Ocean touches the island's right and bottom edges.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"graphs\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/pacific-atlantic-water-flow/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nThere is an m x n rectangular island that borders both the** Pacific Ocean** and Atlantic Ocean. The Pacific Ocean touches the island's left and top edges, and the Atlantic Ocean touches the island's right and bottom edges.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nThe island is partitioned into a grid of square cells. You are given an m x n integer matrix heights where heights[r][c] represents the **height above sea level** of the cell at coordinate (r, c).\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nThe island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell's height is **less than or equal to** the current cell's height. Water can flow from any cell adjacent to an ocean into the ocean.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nReturn a **2D list** of grid coordinates result where result[i] = [ri, ci] denotes that rain water can flow from cell (ri, ci) to **both** the Pacific and Atlantic oceans.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2021/06/08/waterflow-grid.jpg)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation: The following cells can flow to the Pacific and Atlantic oceans, as shown below:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n[0,4]: [0,4] -> Pacific Ocean \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n       [0,4] -> Atlantic Ocean\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n[1,3]: [1,3] -> [0,3] -> Pacific Ocean \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n       [1,3] -> [1,4] -> Atlantic Ocean\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n[1,4]: [1,4] -> [1,3] -> [0,3] -> Pacific Ocean \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n       [1,4] -> Atlantic Ocean\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n[2,2]: [2,2] -> [1,2] -> [0,2] -> Pacific Ocean \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n       [2,2] -> [2,3] -> [2,4] -> Atlantic Ocean\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n[3,0]: [3,0] -> Pacific Ocean \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n       [3,0] -> [4,0] -> Atlantic Ocean\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n[3,1]: [3,1] -> [3,0] -> Pacific Ocean \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n       [3,1] -> [4,1] -> Atlantic Ocean\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n[4,0]: [4,0] -> Pacific Ocean \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n       [4,0] -> Atlantic Ocean\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nNote that there are other possible paths for these cells to flow to the Pacific and Atlantic oceans.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: heights = [[1]]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: [[0,0]]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation: The water can flow from the only cell to the Pacific and Atlantic oceans.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- m == heights.length\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- n == heights[r].length\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 1 <= m, n <= 200\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 0 <= heights[r][c] <= 10^5\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"pacific-atlantic-water-flow\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"palindrome-partitioning\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Palindrome Partitioning\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/palindrome-partitioning/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nGiven a string `s`, partition `s` such that every substring of the partition is a **palindrome**. Return all possible palindrome partitioning of `s`.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: s = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"aab\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: [[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"a\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"a\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"b\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"aa\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"b\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: s = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"a\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: [[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"a\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 1 <= s.length <= 16 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- `s` contains only lowercase English letters.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"palindrome-partitioning\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"permutations\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Permutations\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"backtracking\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/permutations/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nGiven an array `nums` of distinct integers, return all the possible permutations. You can return the answer **in any order**.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: nums = [1,2,3]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: nums = [0,1]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: [[0,1],[1,0]]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 3\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: nums = [1]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: [[1]]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 1 <= nums.length <= 6 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- -10 <= nums[i] <= 10 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- All the integers of nums are unique.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"permutations\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"redundant-connection\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Redundant Connection\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"In this problem, a tree is an undirected graph that is connected and has no cycles.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"graphs\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/redundant-connection/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2021/05/02/reduntant1-1-graph.jpg\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2021/05/02/reduntant1-2-graph.jpg\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nIn this problem, a tree is an **undirected graph** that is connected and has no cycles.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYou are given a graph that started as a tree with n nodes labeled from 1 to n, with one additional edge added. The added edge has two **different** vertices chosen from 1 to n, and was not an edge that already existed. The graph is represented as an array edges of length n where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the graph.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nReturn an edge that can be removed so that the resulting graph is a tree of n nodes. If there are multiple answers, return the answer that occurs last in the input.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2021/05/02/reduntant1-1-graph.jpg)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: edges = [[1,2],[1,3],[2,3]]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: [2,3]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2021/05/02/reduntant1-2-graph.jpg)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: edges = [[1,2],[2,3],[3,4],[1,4],[1,5]]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: [1,4]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- n == edges.length\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 3 <= n <= 1000\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- edges[i].length == 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 1 <= ai < bi <= edges.length\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- ai != bi\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- There are no repeated edges.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- The given graph is connected.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"redundant-connection\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"regex-1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Regex 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"create a markdown that returns all 'hackerrank' matches\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"easy\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"regex\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://www.hackerrank.com/challenges/regex-1/problem\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nCreate a markdown that returns all 'hackerrank' matches\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput The hackerrank team is on a mission to flatten the world by restructuring the hackerrank DNA of every company on the planet. We rank programmers based on their coding skills, helping companies source great programmers and reduce the time to hire. As a result, we are revolutionizing the way companies discover and evaluate talented engineers. The hackerrank platform is the destination for the best engineers to hone their skills and companies to find top engineers. \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: ['hackerrank', 'hackerrank', 'hackerrank']\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"regex-1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"remove-from-nth\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Remove Nth Node From End of List\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Given the head of a linked list, remove the nth node from the end of the list and return its head.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"linked-list\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/remove-nth-node-from-end-of-list/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nGiven the head of a linked list, remove the nth node from the end of the list and return its head.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: head = [1,2,3,4,5], n = 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: [1,2,3,5]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: head = [1], n = 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: []\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 3\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: head = [1,2], n = 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: [1]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- The number of nodes in the list is sz. \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 1 <= sz <= 30 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 0 <= Node.val <= 100 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 1 <= n <= sz\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"remove-from-nth\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"reorder-list\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Reorder List\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"You are given the head of a singly linked-list. The list can be represented as\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"linked-list\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/reorder-list/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2021/03/04/reorder1linked-list.jpg\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2021/03/04/reorder2linked-list.jpg\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYou are given the head of a singly linked-list. The list can be represented as:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n`L0 â†’ L1 â†’ â€¦ â†’ Ln - 1 â†’ Ln`\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nReorder the list to be on the following form:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n`L0 â†’ Ln â†’ L1 â†’ Ln - 1 â†’ L2 â†’ Ln - 2 â†’ â€¦`\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYou may not modify the values in the list's nodes. Only nodes themselves may be changed.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2021/03/04/reorder1linked-list.jpg)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: head = [1,2,3,4]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: [1,4,2,3]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2021/03/04/reorder2linked-list.jpg)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: head = [1,2,3,4,5]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: [1,5,2,4,3]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- The number of nodes in the list is in the range [1, 5 * 104]. \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 1 <= Node.val <= 1000\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"reorder-list\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"reverse-linked-list\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Reverse Linked List\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Given the head of a singly linked list, reverse the list, and return the reversed list.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"easy\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"linked-list\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/reverse-linked-list/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nGovem the `head` of a singly linked list, reverse the list, and return the reversed list.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: head = [1,2,3,4,5]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: [5,4,3,2,1]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: head = [1,2]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: [2,1]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 3\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: head = []\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: []\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- The number of nodes in the list is the range [0, 5000].\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- -5000 <= Node.val <= 5000\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"reverse-linked-list\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"reverse-nodes-in-k-group\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Reverse Nodes in k-Group\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"hard\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"linked-list\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/reverse-nodes-in-k-group/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nGiven the `head` of a linked list, reverse the nodes of the list `k` at a time, and return the modified list.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n`k` is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of `k` then left-out nodes, in the end, should remain as it is.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYou may not alter the values in the list's nodes, only nodes themselves may be changed.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: head = [1,2,3,4,5], k = 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: [2,1,4,3,5]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: head = [1,2,3,4,5], k = 3\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: [3,2,1,4,5]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- The number of nodes in the list is n. \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 1 <= k <= n <= 5000 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 0 <= Node.val <= 1000\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"reverse-nodes-in-k-group\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"rotting-oranges\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Rotting Oranges\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"graphs\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/rotting-oranges/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2019/02/16/oranges.png\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYou are given an m x n grid where each cell can have one of three values:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 0 representing an empty cell,\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 1 representing a fresh orange, or\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 2 representing a rotten orange.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nEvery minute, any fresh orange that is **4-directionally** adjacent to a rotten orange becomes rotten.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nReturn the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2019/02/16/oranges.png)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: grid = [[2,1,1],[1,1,0],[0,1,1]]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: 4\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: grid = [[2,1,1],[0,1,1],[1,0,1]]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: -1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation: The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 3\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: grid = [[0,2]]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: 0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation: Since there are already no fresh oranges at minute 0, the answer is just 0.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- m == grid.length \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- n == grid[i].length\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 1 <= m, n <= 10 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- grid[i][j] is 0, 1, or 2.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"rotting-oranges\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"same-tree\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Same Tree\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Given the roots of two binary trees p and q, write a function to check if they are the same or not.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"easy\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"binary-tree\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/same-tree/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nGiven the roots of two binary trees p and q, write a function to check if they are the same or not.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: p = [1,2,3], q = [1,2,3]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: true\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: p = [1,2], q = [1,null,2]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: false\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 3\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: p = [1,2,1], q = [1,1,2]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: false\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- The number of nodes in both trees is in the range [0, 100]. \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- -10^4 <= Node.val <= 10^4\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"same-tree\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"sample\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Bellflower\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"author\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"guy\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"date\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"2012-07-23T00:00:00.000Z\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"template\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"article.jade\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"crab\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"rose\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bells\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"## Interesting\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nHow strange are those old recollections which haunt us without our being able to get rid of them! This one is so very old that I cannot understand how it has clung so vividly and tenaciously to my memory. Since then I have seen so many sinister things, either affecting or terrible, that I am astonished at not being able to pass a single day without the face of Mother Bellflower recurring to my mind's eye, just as I knew her formerly long, long ago, when I was ten or twelve years old. <span class=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"more\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"></span>\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nShe was an old seamstress who came to my parents' house once a week, every Thursday, to mend the linen. My parents lived in one of those country houses called chateaux, which are merely old houses with pointed roofs, to which are attached three or four adjacent farms.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nThe village, a large village, almost a small market town, was a few hundred yards off and nestled round the church, a red brick church, which had become black with age.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nWell, every Thursday Mother Bellflower came between half-past six and seven in the morning and went immediately into the linen room and began to work. She was a tall, thin, bearded or rather hairy woman, for she had a beard all over her face, a surprising, an unexpected beard, growing in improbable tufts, in curly bunches which looked as if they had been sown by a madman over that great face, the face of a gendarme in petticoats. She had them on her nose, under her nose, round her nose, on her chin, on her cheeks, and her eyebrows, which were extraordinarily thick and long and quite gray, bushy and bristling, looked exactly like a pair of mustaches stuck on there by mistake.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nShe limped, not like lame people generally do, but like a ship pitching. When she planted her great bony, vibrant body on her sound leg, she seemed to be preparing to mount some enormous wave, and then suddenly she dipped as if to disappear in an abyss and buried herself in the ground. Her walk reminded one of a ship in a storm, and her head, which was always covered with an enormous white cap, whose ribbons fluttered down her back, seemed to traverse the horizon from north to south and from south to north at each limp.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nI adored Mother Bellflower. As soon as I was up I used to go into the linen room, where I found her installed at work with a foot warmer under her feet. As soon as I arrived she made me take the foot warmer and sit upon it, so that I might not catch cold in that large chilly room under the roof.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"That draws the blood from your head,\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" she would say to me.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nShe told me stories while mending the linen with her long, crooked, nimble fingers; behind her magnifying spectacles, for age had impaired her sight, her eyes appeared enormous to me, strangely profound, double.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nAs far as I can remember from the things which she told me and by which my childish heart was moved, she had the large heart of a poor woman. She told me what had happened in the village, how a cow had escaped from the cow house and had been found the next morning in front of Prosper Malet's mill looking at the sails turning, or about a hen's egg which had been found in the church belfry without anyone being able to understand what creature had been there to lay it, or the queer story of Jean Pila's dog who had gone ten leagues to bring back his master's breeches which a tramp had stolen while they were hanging up to dry out of doors after he had been caught in the rain. She told me these simple adventures in such a manner that in my mind they assumed the proportions of never-to-be-forgotten dramas, of grand and mysterious poems; and the ingenious stories invented by the poets, which my mother told me in the evening, had none of the flavor, none of the fullness or of the vigor of the peasant woman's narratives.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nWell, one Thursday when I had spent all the morning in listening to Mother Clochette, I wanted to go upstairs to her again during the day after picking hazelnuts with the manservant in the wood behind the farm. I remember it all as clearly as what happened only yesterday.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOn opening the door of the linen room I saw the old seamstress lying on the floor by the side of her chair, her face turned down and her arms stretched out, but still holding her needle in one hand and one of my shirts in the other. One of her legs in a blue stocking, the longer one no doubt, was extended under her chair, and her spectacles glistened by the wall, where they had rolled away from her.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nI ran away uttering shrill cries. They all came running, and in a few minutes I was told that Mother Clochette was dead.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nI cannot describe the profound, poignant, terrible emotion which stirred my childish heart. I went slowly down into the drawing room and hid myself in a dark corner in the depths of a great old armchair, where I knelt and wept. I remained there for a long time, no doubt, for night came on. Suddenly someone came in with a lamp--without seeing me, however--and heard my father and mother talking with the medical man, whose voice recognized.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nHe had been sent for immediately, and he was explaining the cause of the accident, of which I understood nothing, however. Then he sat down and had a glass of liqueur and a biscuit.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nHe went on talking, and what he then said will remain engraved on my mind until I die. I think that I can give the exact words which he used.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Ah!\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" he said. \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"The poor woman! she broke her leg the day of my arrival here. I had not even had time to wash my hands after getting off the diligence before I was sent for in all haste, for it was a bad case, very bad.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"She was seventeen and a pretty girl, very pretty! Would anyone believe it? I have never told her story before; in fact, no one but myself and one other person, who is no longer living in this part of the country, ever knew it. Now that she is dead I may be less discreet.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A young assistant teacher had just come to live in the village; he was good looking and had the bearing of a soldier. All the girls ran after him, but he was disdainful. Besides that, he was very much afraid of his superior, the schoolmaster, old Grabu, who occasionally got out of bed the wrong foot first.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Old Grabu already employed pretty Hortense, who has just died here and who was afterward nicknamed Clochette. The assistant master singled out the pretty young girl who was no doubt flattered at being chosen by this disdainful conqueror; at any rate, she fell in love with him, and he succeeded in persuading her to give him a first meeting in the hayloft behind the school at night after she had done her day's sewing.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"She pretended to go home, but instead of going downstairs when she left the Grabus', she went upstairs and hid among the hay to wait for her lover. He soon joined her, and he was beginning to say pretty things to her, when the door of the hayloft opened and the schoolmaster appeared and asked: 'What are you doing up there, Sigisbert?' Feeling sure that he would be caught, the young schoolmaster lost his presence of mind and replied stupidly: 'I came up here to rest a little among the bundles of hay, Monsieur Grabu.'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"The loft was very large and absolutely dark. Sigisbert pushed the frightened girl to the farther end and said: 'Go, there and hide yourself. I shall lose my situation, so get away and hide yourself.'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"When the schoolmaster heard the whispering he continued: 'Why, you are not by yourself.'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"'Yes, I am, Monsieur Grabu!'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"'But you are not, for you are talking.'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"'I swear I am, Monsieur Grabu.'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"'I will soon find out,' the old man replied and, double-locking the door, he went down to get a light.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Then the young man, who was a coward such as one sometimes meets, lost his head, and he repeated, having grown furious all of a sudden: 'Hide yourself, so that he may not find you. You will deprive me of my bread for my whole life; you will ruin my whole career! Do hide yourself!'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"They could hear the key turning in the lock again, and Hortense ran to the window which looked out onto the street, opened it quickly and then in a low and determined voice said: 'You will come and pick me up when he is gone,' and she jumped out.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Old Grabu found nobody and went down again in great surprise! A quarter of an hour later Monsieur Sigisbert came to me and related his adventure. The girl had remained at the foot of the wall, unable to get up, as she had fallen from the second story, and I went with him to fetch her. It was raining in torrents, and I brought the unfortunate girl home with me, for the right leg was broken in three places, and the bones had come out through the flesh. She did not complain and merely said with admirable resignation: 'I am punished, well punished!'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"I sent for assistance and for the workgirl's friends and told them a made-up story of a runaway carriage which had knocked her down and lamed her outside my door. They believed me, and the gendarmes for a whole month tried in vain to find the author of this accident.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"That is all! Now I say that this woman was a heroine and had the fiber of those who accomplish the grandest deeds in history.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"That was her only love affair, and she died a virgin. She was a martyr, a noble soul, a sublimely devoted woman! And if I did not absolutely admire her I should not have told you this story, which I would never tell anyone during her life; you understand why.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nThe doctor ceased; Mamma cried, and Papa said some words which I did not catch; then they left the room, and I remained on my knees in the armchair and sobbed, while I heard a strange noise of heavy footsteps and something knocking against the side of the staircase.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nThey were carrying away Clochette's body.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"iso8601Date\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"2012-07-22T20:00:00-04:00\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"sample\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"search-matrix\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Search a 2D Matrix\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"You are given an m x n integer matrix matrix with the following two properties\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"binary-search\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/search-a-2d-matrix/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYou are given an `m x n` integer matrix `matrix` with the following two properties:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Each row is sorted in non-decreasing order.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    The first integer of each row is greater than the last integer of the previous row.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nGiven an integer target, return `true` if `target` is in `matrix` or `false` otherwise.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYou must write a solution in `O(log(m * n))` time complexity.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n![figure1](https://assets.leetcode.com/uploads/2020/10/05/mat.jpg)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: true\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n![figure2](https://assets.leetcode.com/uploads/2020/10/05/mat2.jpg)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: false\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- m == matrix.length\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- n == matrix[i].length\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 1 <= m, n <= 100\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- -104 <= matrix[i][j], target <= 104\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"search-matrix\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"search-rotated-array\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Search in Rotated Sorted Array\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"binary-search\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/search-in-rotated-sorted-array/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nThere is an integer array `nums` sorted in ascending order (with **distinct** values).\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nPrior to being passed to your function, nums is **possibly rotated** at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nGiven the array `nums` **after** the possible rotation and an integer target, return the index of `target` if it is in `nums`, or `-1` if it is not in `nums`.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYou must write an algorithm with O(log n) runtime complexity.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: nums = [4,5,6,7,0,1,2], target = 0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: 4\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: nums = [4,5,6,7,0,1,2], target = 3\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: -1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 3\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: nums = [1], target = 0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: -1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n-      1 <= nums.length <= 5000     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n-      -104 <= nums[i] <= 104     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n-      All values of nums are unique.     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n-      nums is an ascending array that is possibly rotated.     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n-      -104 <= target <= 104\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"search-rotated-array\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"serialize-and-deserialize-binary-tree\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Serialize and Deserialize Binary Tree\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"hard\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"binary-tree\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/serialize-and-deserialize-binary-tree/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nSerialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nDesign an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n**Clarification**: The input/output format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: root = [1,2,3,null,null,4,5]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: [1,2,3,null,null,4,5]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: root = []\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: []\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- The number of nodes in the tree is in the range [0, 10^4]. \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- -1000 <= Node.val <= 1000\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"serialize-and-deserialize-binary-tree\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"simple-division\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Simple Division\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A simple division example\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"sample\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"math\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"This is  a simple division example.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```js\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nimport { prompt } from 'dsa-cli';\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nconst a = prompt('Enter a number: ');\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nconst b = prompt('Enter another number: ');\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nconsole.log(a / b);\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n$ dsa run simple-division.js\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nEnter a number: 10\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"simple-division\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"simple-substraction\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Simple Substraction\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A simple substraction example\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"sample\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"math\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"This is  a simple substraction example.!\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```js\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nimport { prompt } from 'dsa-cli';\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nconst a = prompt('Enter a number: ');\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nconst b = prompt('Enter another number: ');\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nconsole.log(a - b);\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n$ dsa run simple-substraction.js\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nEnter a number: 11\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nEnter another number: 5\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"simple-substraction\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"simple-sum\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Simple Sum\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A simple sum example!\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"sample\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"math\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"This is  a simple sum example.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```js\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nimport { prompt } from 'dsa-cli';\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nconst a = prompt('Enter a number: ');\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nconst b = prompt('Enter another number: ');\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nconsole.log(a + b);\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n$ dsa run simple-sum.js\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nEnter a number: 10\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nEnter another number:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"simple-sum\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"subsets-ii\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Subsets II\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Given an integer array nums that may contain duplicates, return all possible subsets (the power set).\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"backtracking\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/subsets-ii/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nGiven an integer array `nums` that may contain duplicates, return all possible subsets (the power set).\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nThe solution set **must not** contain duplicate subsets. Return the solution in **any order**.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: nums = [1,2,2]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: [[],[1],[1,2],[1,2,2],[2],[2,2]]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: nums = [0]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: [[],[0]]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 1 <= nums.length <= 10\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- -10 <= nums[i] <= 10\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"subsets-ii\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"subsets\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"subsets\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"subtree-of-another-tree\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Subtree of Another Tree\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A subtree of a binary tree tree is a tree that consists of a node in tree and all of this node's descendants. The tree tree could also be considered as a subtree of itself.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"easy\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"binary-tree\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/subtree-of-another-tree/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2021/02/18/tree1.jpg\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2021/02/18/tree2.jpg\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nGiven the roots of two binary trees `root` and `subRoot`, return true if there is a subtree of root with the same structure and node values of `subRoot` and `false` otherwise.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nA subtree of a binary tree `tree` is a tree that consists of a node in tree and all of this node's descendants. The tree `tree` could also be considered as a subtree of itself.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2021/02/18/tree1.jpg)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: root = [3,4,5,1,2], subRoot = [4,1,2]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: true\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2021/02/18/tree2.jpg)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: false\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- The number of nodes in the root tree is in the range [1, 2000]. \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- The number of nodes in the subRoot tree is in the range [1, 1000]. \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- -10^4 <= root.val <= 10^4 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- -10^4 <= subRoot.val <= 10^4\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"subtree-of-another-tree\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"surrounded-regions\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Surrounded Regions\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Given an m x n matrix board containing 'X' and 'O', capture all regions that are 4-directionally surrounded by 'X'.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"graphs\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/surrounded-regions/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2021/02/19/xogrid.jpg\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nGiven an `m x n` matrix board containing 'X' and 'O', capture all regions that are 4-directionally surrounded by 'X'.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nA region is **captured** by flipping all 'O's into 'X's in that surrounded region.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2021/02/19/xogrid.jpg)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: board = [[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"O\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"O\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"O\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"O\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: [[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"O\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation: Notice that an 'O' should not be flipped if:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- It is on the border, or\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- It is adjacent to an 'O' that should not be flipped.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nThe bottom 'O' is on the border, so it is not flipped.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nThe other three 'O' form a surrounded region, so they are flipped.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: board = [[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: [[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- m == board.length\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- n == board[i].length\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 1 <= m, n <= 200\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- board[i][j] is 'X' or 'O'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"surrounded-regions\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"task-scheduler\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Task Scheduler\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Return the least number of units of times that the CPU will take to finish all the given tasks.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"heap\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/task-scheduler/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nGiven a characters array tasks, representing the tasks a CPU needs to do, where each letter represents a different task. Tasks could be done in any order. Each task is done in one unit of time. For each unit of time, the CPU could complete either one task or just be idle.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nHowever, there is a non-negative integer n that represents the cooldown period between two **same tasks** (the same letter in the array), that is that there must be at least n units of time between any two same tasks.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nReturn the least number of units of times that the CPU will take to finish all the given tasks.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: tasks = [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"B\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"B\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"B\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"], n = 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: 8\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nA -> B -> idle -> A -> B -> idle -> A -> B\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nThere is at least 2 units of time between any two same tasks.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: tasks = [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"B\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"B\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"B\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"], n = 0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: 6\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation: On this case any permutation of size 6 would work since n = 0.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"B\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"B\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"B\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"B\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"B\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"B\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"B\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"B\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"B\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n...\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nAnd so on.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 3\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: tasks = [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"B\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"D\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"E\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"F\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"G\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"], n = 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: 16\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOne possible solution is\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nA -> B -> C -> A -> D -> E -> A -> F -> G -> A -> idle -> idle -> A -> idle -> idle -> A\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 1 <= task.length <= 10^4 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- tasks[i] is upper-case English letter. \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- The integer n is in the range [0, 100].\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"task-scheduler\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"three-number-sum\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Three Number Sum\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A three number sum example\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"arrays\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"math\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"## Three Number Sum\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nGiven an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nNotice that the solution set must not contain duplicate triplets.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExample 1:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: nums = [-1,0,1,2,-1,-4]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: [[-1,-1,2],[-1,0,1]]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nThe distinct triplets are [-1,0,1] and [-1,-1,2].\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nNotice that the order of the output and the order of the triplets does not matter.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExample 2:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: nums = [0,1,1]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: []\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation: The only possible triplet does not sum up to 0.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExample 3:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: nums = [0,0,0]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: [[0,0,0]]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation: The only possible triplet sums up to 0.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"three-number-sum\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"trapping-rain-water\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Trapping Rain Water\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A trapping rain water example\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"hard\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"two-pointers\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Given `n` non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExample 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: height = [0,1,0,2,1,0,1,3,2,1,2,1]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: 6\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExample 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: height = [4,2,0,3,2,5]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: 9\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"trapping-rain-water\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"valid-parentheses\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Valid Parentheses\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"easy\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"stack\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/valid-parentheses/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nGiven a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nAn input string is valid if:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOpen brackets must be closed by the same type of brackets.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOpen brackets must be closed in the correct order.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nEvery close bracket has a corresponding open bracket of the same type.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: s = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"()\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: true\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: s = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"()[]{}\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: true\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 3\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: s = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"(]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: false\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n-      1 <= s.length <= 104     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n-      s consists of parentheses only '()[]{}'.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"valid-parentheses\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"validate-binary-search-tree\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Validate Binary Search Tree\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Given the root of a binary tree, determine if it is a valid binary search tree (BST).\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"binary-tree\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/validate-binary-search-tree/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nGiven the root of a binary tree, determine if it is a valid binary search tree (BST).\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nA valid BST is defined as follows:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- The left subtree of a node contains only nodes with keys less than the node's key.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- The right subtree of a node contains only nodes with keys greater than the node's key.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- Both the left and right subtrees must also be binary search trees.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: root = [2,1,3]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: true\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: root = [5,1,4,null,null,3,6]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: false\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation: The root node's value is 5 but its right child's value is 4.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- The number of nodes in the tree is in the range [1, 104].\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- -2^31 <= Node.val <= 2^31 - 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"validate-binary-search-tree\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"walls-and-gates\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Walls and Gates\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should be filled with INF.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"graphs\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://tenderleo.gitbooks.io/leetcode-solutions-/content/GoogleMedium/286.html\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYou are given a m x n 2D grid initialized with these three possible values.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n-1 - A wall or an obstacle. 0 - A gate. INF - Infinity means an empty room. We use the value 231 - 1 = 2147483647 to represent INF as you may assume that the distance to a gate is less than 2147483647. Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should be filled with INF.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nINF  -1  0  INF\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nINF INF INF  -1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nINF  -1 INF  -1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n  0  -1 INF INF\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nAfter running the function, the 2D grid should be:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n  3  -1   0   1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n  2   2   1  -1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n  1  -1   2  -1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n  0  -1   3   4\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- m == rooms.length\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- n == rooms[i].length\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"walls-and-gates\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"word-ladder\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Word Ladder\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Given two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"hard\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"graphs\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/word-ladder/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nA transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- Every adjacent pair of words differs by a single letter.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- sk == endWord\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nGiven two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: beginWord = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"hit\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", endWord = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"cog\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", wordList = [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"hot\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"dot\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"dog\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"lot\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"log\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"cog\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: 5\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation: One shortest transformation sequence is \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"hit\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" -> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"hot\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" -> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"dot\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" -> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"dog\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" -> cog\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", which is 5 words long.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: beginWord = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"hit\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", endWord = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"cog\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", wordList = [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"hot\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"dot\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"dog\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"lot\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"log\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: 0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nExplanation: The endWord \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"cog\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" is not in wordList, therefore there is no valid transformation sequence.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 1 <= beginWord.length <= 10\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- endWord.length == beginWord.length\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 1 <= wordList.length <= 5000\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- wordList[i].length == beginWord.length\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- beginWord, endWord, and wordList[i] consist of lowercase English letters.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- beginWord != endWord\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- All the words in wordList are unique.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"word-ladder\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"word-search-ii\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Word Search II\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Given an m x n board of characters and a list of strings words, return all words on the board.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"hard\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"trie\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/word-search-ii/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nGiven an m x n board of characters and a list of strings words, return all words on the board.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nEach word must be constructed from letters of sequentially adjacent cells, where **adjacent cells** are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/11/07/search1.jpg)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: board = [[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"o\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"a\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"a\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"e\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"t\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"a\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"e\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"i\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"h\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"k\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"i\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"f\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"l\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"v\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]], words = [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"oath\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"pea\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"eat\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"rain\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"eat\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"oath\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/11/07/search2.jpg)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: board = [[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"a\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"b\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"c\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"d\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]], words = [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"abcb\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: []\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- m == board.length\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- n == board[i].length\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 1 <= m, n <= 12\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- board[i][j] is a lowercase English letter.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 1 <= words.length <= 3 * 10^4\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 1 <= words[i].length <= 10\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- words[i] consists of lowercase English letters.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- All the strings of `words` are unique.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"word-search-ii\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"word-search\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Word Search\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Given an m x n grid of characters board and a string word, return true if word exists in the grid.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"https://leetcode.com/problems/word-search/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":[],\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nGiven an `m x n` grid of characters `board` and a string `word`, return `true` if word exists in the grid.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nThe word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/11/04/word2.jpg)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: board = [[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"B\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"E\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"S\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"F\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"S\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"D\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"E\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"E\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]], word = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"ABCCED\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: true\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: board = [[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"B\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"E\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"S\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"F\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"S\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"D\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"E\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"E\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]], word = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"SEE\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: true\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Example 3\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/10/15/word3.jpg)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nInput: board = [[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"B\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"E\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"S\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"F\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"S\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"D\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"E\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"E\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]], word = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"ABCB\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutput: false\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- m == board.length \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- n = board[i].length \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 1 <= m, n <= 6 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- 1 <= word.length <= 15 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- board and word consists of only lowercase and uppercase English letters.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"word-search\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"}}\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"prompt\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"redundant-connection\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Redundant Connection\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"In this problem, a tree is an undirected graph that is connected and has no cycles.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"graphs\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/redundant-connection/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2021/05/02/reduntant1-1-graph.jpg\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2021/05/02/reduntant1-2-graph.jpg\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nIn this problem, a tree is an **undirected graph** that is connected and has no cycles.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nYou are given a graph that started as a tree with n nodes labeled from 1 to n, with one additional edge added. The added edge has two **different** vertices chosen from 1 to n, and was not an edge that already existed. The graph is represented as an array edges of length n where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the graph.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nReturn an edge that can be removed so that the resulting graph is a tree of n nodes. If there are multiple answers, return the answer that occurs last in the input.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2021/05/02/reduntant1-1-graph.jpg)\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: edges = [[1,2],[1,3],[2,3]]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: [2,3]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2021/05/02/reduntant1-2-graph.jpg)\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: edges = [[1,2],[2,3],[3,4],[1,4],[1,5]]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: [1,4]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- n == edges.length\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 3 <= n <= 1000\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- edges[i].length == 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 1 <= ai < bi <= edges.length\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- ai != bi\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- There are no repeated edges.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- The given graph is connected.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"redundant-connection\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"regex-1\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Regex 1\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"create a markdown that returns all 'hackerrank' matches\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"easy\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"regex\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://www.hackerrank.com/challenges/regex-1/problem\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nCreate a markdown that returns all 'hackerrank' matches\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput The hackerrank team is on a mission to flatten the world by restructuring the hackerrank DNA of every company on the planet. We rank programmers based on their coding skills, helping companies source great programmers and reduce the time to hire. As a result, we are revolutionizing the way companies discover and evaluate talented engineers. The hackerrank platform is the destination for the best engineers to hone their skills and companies to find top engineers. \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: ['hackerrank', 'hackerrank', 'hackerrank']\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"regex-1\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"remove-from-nth\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Remove Nth Node From End of List\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Given the head of a linked list, remove the nth node from the end of the list and return its head.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"linked-list\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/remove-nth-node-from-end-of-list/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nGiven the head of a linked list, remove the nth node from the end of the list and return its head.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: head = [1,2,3,4,5], n = 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: [1,2,3,5]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: head = [1], n = 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: []\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 3\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: head = [1,2], n = 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: [1]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- The number of nodes in the list is sz. \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 1 <= sz <= 30 \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 0 <= Node.val <= 100 \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 1 <= n <= sz\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"remove-from-nth\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"reorder-list\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Reorder List\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"You are given the head of a singly linked-list. The list can be represented as\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"linked-list\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/reorder-list/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2021/03/04/reorder1linked-list.jpg\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2021/03/04/reorder2linked-list.jpg\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nYou are given the head of a singly linked-list. The list can be represented as:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n`L0 â†’ L1 â†’ â€¦ â†’ Ln - 1 â†’ Ln`\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nReorder the list to be on the following form:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n`L0 â†’ Ln â†’ L1 â†’ Ln - 1 â†’ L2 â†’ Ln - 2 â†’ â€¦`\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nYou may not modify the values in the list's nodes. Only nodes themselves may be changed.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2021/03/04/reorder1linked-list.jpg)\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: head = [1,2,3,4]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: [1,4,2,3]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2021/03/04/reorder2linked-list.jpg)\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: head = [1,2,3,4,5]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: [1,5,2,4,3]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- The number of nodes in the list is in the range [1, 5 * 104]. \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 1 <= Node.val <= 1000\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"reorder-list\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"reverse-linked-list\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Reverse Linked List\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Given the head of a singly linked list, reverse the list, and return the reversed list.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"easy\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"linked-list\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/reverse-linked-list/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nGovem the `head` of a singly linked list, reverse the list, and return the reversed list.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg)\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: head = [1,2,3,4,5]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: [5,4,3,2,1]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg)\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: head = [1,2]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: [2,1]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 3\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: head = []\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: []\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- The number of nodes in the list is the range [0, 5000].\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- -5000 <= Node.val <= 5000\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"reverse-linked-list\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"reverse-nodes-in-k-group\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Reverse Nodes in k-Group\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"hard\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"linked-list\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/reverse-nodes-in-k-group/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nGiven the `head` of a linked list, reverse the nodes of the list `k` at a time, and return the modified list.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n`k` is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of `k` then left-out nodes, in the end, should remain as it is.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nYou may not alter the values in the list's nodes, only nodes themselves may be changed.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: head = [1,2,3,4,5], k = 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: [2,1,4,3,5]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: head = [1,2,3,4,5], k = 3\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: [3,2,1,4,5]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- The number of nodes in the list is n. \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 1 <= k <= n <= 5000 \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 0 <= Node.val <= 1000\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"reverse-nodes-in-k-group\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"rotting-oranges\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Rotting Oranges\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"graphs\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/rotting-oranges/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2019/02/16/oranges.png\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nYou are given an m x n grid where each cell can have one of three values:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 0 representing an empty cell,\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 1 representing a fresh orange, or\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 2 representing a rotten orange.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nEvery minute, any fresh orange that is **4-directionally** adjacent to a rotten orange becomes rotten.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nReturn the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2019/02/16/oranges.png)\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: grid = [[2,1,1],[1,1,0],[0,1,1]]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: 4\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: grid = [[2,1,1],[0,1,1],[1,0,1]]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: -1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation: The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 3\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: grid = [[0,2]]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: 0\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation: Since there are already no fresh oranges at minute 0, the answer is just 0.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- m == grid.length \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- n == grid[i].length\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 1 <= m, n <= 10 \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- grid[i][j] is 0, 1, or 2.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"rotting-oranges\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"same-tree\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Same Tree\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Given the roots of two binary trees p and q, write a function to check if they are the same or not.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"easy\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"binary-tree\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/same-tree/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nGiven the roots of two binary trees p and q, write a function to check if they are the same or not.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg)\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: p = [1,2,3], q = [1,2,3]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: true\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg)\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: p = [1,2], q = [1,null,2]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: false\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 3\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg)\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: p = [1,2,1], q = [1,1,2]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: false\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- The number of nodes in both trees is in the range [0, 100]. \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- -10^4 <= Node.val <= 10^4\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"same-tree\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"sample\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Bellflower\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"author\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"guy\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"date\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"2012-07-23T00:00:00.000Z\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"template\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"article.jade\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"crab\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"rose\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"bells\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"## Interesting\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nHow strange are those old recollections which haunt us without our being able to get rid of them! This one is so very old that I cannot understand how it has clung so vividly and tenaciously to my memory. Since then I have seen so many sinister things, either affecting or terrible, that I am astonished at not being able to pass a single day without the face of Mother Bellflower recurring to my mind's eye, just as I knew her formerly long, long ago, when I was ten or twelve years old. <span class=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"more\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"></span>\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nShe was an old seamstress who came to my parents' house once a week, every Thursday, to mend the linen. My parents lived in one of those country houses called chateaux, which are merely old houses with pointed roofs, to which are attached three or four adjacent farms.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nThe village, a large village, almost a small market town, was a few hundred yards off and nestled round the church, a red brick church, which had become black with age.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nWell, every Thursday Mother Bellflower came between half-past six and seven in the morning and went immediately into the linen room and began to work. She was a tall, thin, bearded or rather hairy woman, for she had a beard all over her face, a surprising, an unexpected beard, growing in improbable tufts, in curly bunches which looked as if they had been sown by a madman over that great face, the face of a gendarme in petticoats. She had them on her nose, under her nose, round her nose, on her chin, on her cheeks, and her eyebrows, which were extraordinarily thick and long and quite gray, bushy and bristling, looked exactly like a pair of mustaches stuck on there by mistake.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nShe limped, not like lame people generally do, but like a ship pitching. When she planted her great bony, vibrant body on her sound leg, she seemed to be preparing to mount some enormous wave, and then suddenly she dipped as if to disappear in an abyss and buried herself in the ground. Her walk reminded one of a ship in a storm, and her head, which was always covered with an enormous white cap, whose ribbons fluttered down her back, seemed to traverse the horizon from north to south and from south to north at each limp.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nI adored Mother Bellflower. As soon as I was up I used to go into the linen room, where I found her installed at work with a foot warmer under her feet. As soon as I arrived she made me take the foot warmer and sit upon it, so that I might not catch cold in that large chilly room under the roof.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"That draws the blood from your head,\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" she would say to me.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nShe told me stories while mending the linen with her long, crooked, nimble fingers; behind her magnifying spectacles, for age had impaired her sight, her eyes appeared enormous to me, strangely profound, double.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nAs far as I can remember from the things which she told me and by which my childish heart was moved, she had the large heart of a poor woman. She told me what had happened in the village, how a cow had escaped from the cow house and had been found the next morning in front of Prosper Malet's mill looking at the sails turning, or about a hen's egg which had been found in the church belfry without anyone being able to understand what creature had been there to lay it, or the queer story of Jean Pila's dog who had gone ten leagues to bring back his master's breeches which a tramp had stolen while they were hanging up to dry out of doors after he had been caught in the rain. She told me these simple adventures in such a manner that in my mind they assumed the proportions of never-to-be-forgotten dramas, of grand and mysterious poems; and the ingenious stories invented by the poets, which my mother told me in the evening, had none of the flavor, none of the fullness or of the vigor of the peasant woman's narratives.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nWell, one Thursday when I had spent all the morning in listening to Mother Clochette, I wanted to go upstairs to her again during the day after picking hazelnuts with the manservant in the wood behind the farm. I remember it all as clearly as what happened only yesterday.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOn opening the door of the linen room I saw the old seamstress lying on the floor by the side of her chair, her face turned down and her arms stretched out, but still holding her needle in one hand and one of my shirts in the other. One of her legs in a blue stocking, the longer one no doubt, was extended under her chair, and her spectacles glistened by the wall, where they had rolled away from her.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nI ran away uttering shrill cries. They all came running, and in a few minutes I was told that Mother Clochette was dead.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nI cannot describe the profound, poignant, terrible emotion which stirred my childish heart. I went slowly down into the drawing room and hid myself in a dark corner in the depths of a great old armchair, where I knelt and wept. I remained there for a long time, no doubt, for night came on. Suddenly someone came in with a lamp--without seeing me, however--and heard my father and mother talking with the medical man, whose voice recognized.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nHe had been sent for immediately, and he was explaining the cause of the accident, of which I understood nothing, however. Then he sat down and had a glass of liqueur and a biscuit.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nHe went on talking, and what he then said will remain engraved on my mind until I die. I think that I can give the exact words which he used.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Ah!\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" he said. \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"The poor woman! she broke her leg the day of my arrival here. I had not even had time to wash my hands after getting off the diligence before I was sent for in all haste, for it was a bad case, very bad.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"She was seventeen and a pretty girl, very pretty! Would anyone believe it? I have never told her story before; in fact, no one but myself and one other person, who is no longer living in this part of the country, ever knew it. Now that she is dead I may be less discreet.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A young assistant teacher had just come to live in the village; he was good looking and had the bearing of a soldier. All the girls ran after him, but he was disdainful. Besides that, he was very much afraid of his superior, the schoolmaster, old Grabu, who occasionally got out of bed the wrong foot first.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Old Grabu already employed pretty Hortense, who has just died here and who was afterward nicknamed Clochette. The assistant master singled out the pretty young girl who was no doubt flattered at being chosen by this disdainful conqueror; at any rate, she fell in love with him, and he succeeded in persuading her to give him a first meeting in the hayloft behind the school at night after she had done her day's sewing.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"She pretended to go home, but instead of going downstairs when she left the Grabus', she went upstairs and hid among the hay to wait for her lover. He soon joined her, and he was beginning to say pretty things to her, when the door of the hayloft opened and the schoolmaster appeared and asked: 'What are you doing up there, Sigisbert?' Feeling sure that he would be caught, the young schoolmaster lost his presence of mind and replied stupidly: 'I came up here to rest a little among the bundles of hay, Monsieur Grabu.'\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"The loft was very large and absolutely dark. Sigisbert pushed the frightened girl to the farther end and said: 'Go, there and hide yourself. I shall lose my situation, so get away and hide yourself.'\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"When the schoolmaster heard the whispering he continued: 'Why, you are not by yourself.'\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"'Yes, I am, Monsieur Grabu!'\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"'But you are not, for you are talking.'\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"'I swear I am, Monsieur Grabu.'\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"'I will soon find out,' the old man replied and, double-locking the door, he went down to get a light.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Then the young man, who was a coward such as one sometimes meets, lost his head, and he repeated, having grown furious all of a sudden: 'Hide yourself, so that he may not find you. You will deprive me of my bread for my whole life; you will ruin my whole career! Do hide yourself!'\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"They could hear the key turning in the lock again, and Hortense ran to the window which looked out onto the street, opened it quickly and then in a low and determined voice said: 'You will come and pick me up when he is gone,' and she jumped out.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Old Grabu found nobody and went down again in great surprise! A quarter of an hour later Monsieur Sigisbert came to me and related his adventure. The girl had remained at the foot of the wall, unable to get up, as she had fallen from the second story, and I went with him to fetch her. It was raining in torrents, and I brought the unfortunate girl home with me, for the right leg was broken in three places, and the bones had come out through the flesh. She did not complain and merely said with admirable resignation: 'I am punished, well punished!'\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"I sent for assistance and for the workgirl's friends and told them a made-up story of a runaway carriage which had knocked her down and lamed her outside my door. They believed me, and the gendarmes for a whole month tried in vain to find the author of this accident.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"That is all! Now I say that this woman was a heroine and had the fiber of those who accomplish the grandest deeds in history.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"That was her only love affair, and she died a virgin. She was a martyr, a noble soul, a sublimely devoted woman! And if I did not absolutely admire her I should not have told you this story, which I would never tell anyone during her life; you understand why.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nThe doctor ceased; Mamma cried, and Papa said some words which I did not catch; then they left the room, and I remained on my knees in the armchair and sobbed, while I heard a strange noise of heavy footsteps and something knocking against the side of the staircase.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nThey were carrying away Clochette's body.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"iso8601Date\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"2012-07-22T20:00:00-04:00\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"sample\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"search-matrix\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Search a 2D Matrix\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"You are given an m x n integer matrix matrix with the following two properties\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"binary-search\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/search-a-2d-matrix/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nYou are given an `m x n` integer matrix `matrix` with the following two properties:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n    Each row is sorted in non-decreasing order.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n    The first integer of each row is greater than the last integer of the previous row.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nGiven an integer target, return `true` if `target` is in `matrix` or `false` otherwise.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nYou must write a solution in `O(log(m * n))` time complexity.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n![figure1](https://assets.leetcode.com/uploads/2020/10/05/mat.jpg)\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: true\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n![figure2](https://assets.leetcode.com/uploads/2020/10/05/mat2.jpg)\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: false\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- m == matrix.length\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- n == matrix[i].length\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 1 <= m, n <= 100\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- -104 <= matrix[i][j], target <= 104\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"search-matrix\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"search-rotated-array\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Search in Rotated Sorted Array\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"binary-search\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/search-in-rotated-sorted-array/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nThere is an integer array `nums` sorted in ascending order (with **distinct** values).\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nPrior to being passed to your function, nums is **possibly rotated** at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nGiven the array `nums` **after** the possible rotation and an integer target, return the index of `target` if it is in `nums`, or `-1` if it is not in `nums`.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nYou must write an algorithm with O(log n) runtime complexity.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: nums = [4,5,6,7,0,1,2], target = 0\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: 4\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: nums = [4,5,6,7,0,1,2], target = 3\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: -1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 3\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: nums = [1], target = 0\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: -1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n-      1 <= nums.length <= 5000     \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n-      -104 <= nums[i] <= 104     \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n-      All values of nums are unique.     \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n-      nums is an ascending array that is possibly rotated.     \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n-      -104 <= target <= 104\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"search-rotated-array\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"serialize-and-deserialize-binary-tree\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Serialize and Deserialize Binary Tree\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"hard\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"binary-tree\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/serialize-and-deserialize-binary-tree/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nSerialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nDesign an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n**Clarification**: The input/output format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg)\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: root = [1,2,3,null,null,4,5]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: [1,2,3,null,null,4,5]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: root = []\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: []\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- The number of nodes in the tree is in the range [0, 10^4]. \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- -1000 <= Node.val <= 1000\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"serialize-and-deserialize-binary-tree\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"simple-division\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Simple Division\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"A simple division example\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"sample\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"math\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"This is  a simple division example.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```js\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nimport { prompt } from 'dsa-cli';\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nconst a = prompt('Enter a number: ');\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nconst b = prompt('Enter another number: ');\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nconsole.log(a / b);\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n$ dsa run simple-division.js\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nEnter a number: 10\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"simple-division\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"simple-substraction\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Simple Substraction\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"A simple substraction example\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"sample\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"math\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"This is  a simple substraction example.!\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```js\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nimport { prompt } from 'dsa-cli';\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nconst a = prompt('Enter a number: ');\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nconst b = prompt('Enter another number: ');\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nconsole.log(a - b);\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n$ dsa run simple-substraction.js\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nEnter a number: 11\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nEnter another number: 5\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"simple-substraction\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"simple-sum\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Simple Sum\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"A simple sum example!\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"sample\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"math\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"This is  a simple sum example.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```js\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nimport { prompt } from 'dsa-cli';\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nconst a = prompt('Enter a number: ');\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nconst b = prompt('Enter another number: ');\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nconsole.log(a + b);\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n$ dsa run simple-sum.js\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nEnter a number: 10\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nEnter another number:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"simple-sum\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"subsets-ii\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Subsets II\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Given an integer array nums that may contain duplicates, return all possible subsets (the power set).\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"backtracking\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/subsets-ii/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\":[],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nGiven an integer array `nums` that may contain duplicates, return all possible subsets (the power set).\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nThe solution set **must not** contain duplicate subsets. Return the solution in **any order**.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: nums = [1,2,2]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: [[],[1],[1,2],[1,2,2],[2],[2,2]]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: nums = [0]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: [[],[0]]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 1 <= nums.length <= 10\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- -10 <= nums[i] <= 10\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"subsets-ii\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"subsets\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"subsets\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"subtree-of-another-tree\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Subtree of Another Tree\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"A subtree of a binary tree tree is a tree that consists of a node in tree and all of this node's descendants. The tree tree could also be considered as a subtree of itself.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"easy\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"binary-tree\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/subtree-of-another-tree/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2021/02/18/tree1.jpg\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2021/02/18/tree2.jpg\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nGiven the roots of two binary trees `root` and `subRoot`, return true if there is a subtree of root with the same structure and node values of `subRoot` and `false` otherwise.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nA subtree of a binary tree `tree` is a tree that consists of a node in tree and all of this node's descendants. The tree `tree` could also be considered as a subtree of itself.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2021/02/18/tree1.jpg)\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: root = [3,4,5,1,2], subRoot = [4,1,2]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: true\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2021/02/18/tree2.jpg)\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: false\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- The number of nodes in the root tree is in the range [1, 2000]. \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- The number of nodes in the subRoot tree is in the range [1, 1000]. \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- -10^4 <= root.val <= 10^4 \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- -10^4 <= subRoot.val <= 10^4\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"subtree-of-another-tree\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"surrounded-regions\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Surrounded Regions\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Given an m x n matrix board containing 'X' and 'O', capture all regions that are 4-directionally surrounded by 'X'.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"graphs\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/surrounded-regions/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2021/02/19/xogrid.jpg\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nGiven an `m x n` matrix board containing 'X' and 'O', capture all regions that are 4-directionally surrounded by 'X'.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nA region is **captured** by flipping all 'O's into 'X's in that surrounded region.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2021/02/19/xogrid.jpg)\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: board = [[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"O\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"O\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"O\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"O\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: [[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"O\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation: Notice that an 'O' should not be flipped if:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- It is on the border, or\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- It is adjacent to an 'O' that should not be flipped.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nThe bottom 'O' is on the border, so it is not flipped.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nThe other three 'O' form a surrounded region, so they are flipped.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: board = [[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: [[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- m == board.length\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- n == board[i].length\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 1 <= m, n <= 200\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- board[i][j] is 'X' or 'O'\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"surrounded-regions\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"task-scheduler\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Task Scheduler\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Return the least number of units of times that the CPU will take to finish all the given tasks.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"heap\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/task-scheduler/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\":[],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nGiven a characters array tasks, representing the tasks a CPU needs to do, where each letter represents a different task. Tasks could be done in any order. Each task is done in one unit of time. For each unit of time, the CPU could complete either one task or just be idle.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nHowever, there is a non-negative integer n that represents the cooldown period between two **same tasks** (the same letter in the array), that is that there must be at least n units of time between any two same tasks.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nReturn the least number of units of times that the CPU will take to finish all the given tasks.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: tasks = [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"B\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"B\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"B\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"], n = 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: 8\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation: \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nA -> B -> idle -> A -> B -> idle -> A -> B\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nThere is at least 2 units of time between any two same tasks.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: tasks = [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"B\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"B\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"B\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"], n = 0\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: 6\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation: On this case any permutation of size 6 would work since n = 0.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"B\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"B\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"B\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"B\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"B\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"B\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"B\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"B\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"B\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n...\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nAnd so on.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 3\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: tasks = [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"B\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"D\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"E\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"F\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"G\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"], n = 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: 16\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation: \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOne possible solution is\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nA -> B -> C -> A -> D -> E -> A -> F -> G -> A -> idle -> idle -> A -> idle -> idle -> A\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 1 <= task.length <= 10^4 \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- tasks[i] is upper-case English letter. \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- The integer n is in the range [0, 100].\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"task-scheduler\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"three-number-sum\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Three Number Sum\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"A three number sum example\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"arrays\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"math\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"## Three Number Sum\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nGiven an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nNotice that the solution set must not contain duplicate triplets.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExample 1:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: nums = [-1,0,1,2,-1,-4]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: [[-1,-1,2],[-1,0,1]]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation: \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nThe distinct triplets are [-1,0,1] and [-1,-1,2].\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nNotice that the order of the output and the order of the triplets does not matter.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExample 2:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: nums = [0,1,1]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: []\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation: The only possible triplet does not sum up to 0.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExample 3:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: nums = [0,0,0]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: [[0,0,0]]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation: The only possible triplet sums up to 0.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"three-number-sum\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"trapping-rain-water\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Trapping Rain Water\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"A trapping rain water example\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"hard\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"two-pointers\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Given `n` non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExample 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: height = [0,1,0,2,1,0,1,3,2,1,2,1]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: 6\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExample 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: height = [4,2,0,3,2,5]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: 9\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"trapping-rain-water\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"valid-parentheses\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Valid Parentheses\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"easy\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"stack\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/valid-parentheses/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nGiven a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nAn input string is valid if:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOpen brackets must be closed by the same type of brackets.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOpen brackets must be closed in the correct order.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nEvery close bracket has a corresponding open bracket of the same type.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: s = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"()\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: true\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: s = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"()[]{}\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: true\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 3\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: s = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"(]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: false\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n-      1 <= s.length <= 104     \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n-      s consists of parentheses only '()[]{}'.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"valid-parentheses\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"validate-binary-search-tree\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Validate Binary Search Tree\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Given the root of a binary tree, determine if it is a valid binary search tree (BST).\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"binary-tree\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/validate-binary-search-tree/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nGiven the root of a binary tree, determine if it is a valid binary search tree (BST).\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nA valid BST is defined as follows:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- The left subtree of a node contains only nodes with keys less than the node's key.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- The right subtree of a node contains only nodes with keys greater than the node's key.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- Both the left and right subtrees must also be binary search trees.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg)\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: root = [2,1,3]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: true\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg)\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: root = [5,1,4,null,null,3,6]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: false\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation: The root node's value is 5 but its right child's value is 4.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- The number of nodes in the tree is in the range [1, 104].\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- -2^31 <= Node.val <= 2^31 - 1\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"validate-binary-search-tree\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"walls-and-gates\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Walls and Gates\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should be filled with INF.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"medium\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"graphs\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://tenderleo.gitbooks.io/leetcode-solutions-/content/GoogleMedium/286.html\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\":[],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nYou are given a m x n 2D grid initialized with these three possible values.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n-1 - A wall or an obstacle. 0 - A gate. INF - Infinity means an empty room. We use the value 231 - 1 = 2147483647 to represent INF as you may assume that the distance to a gate is less than 2147483647. Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should be filled with INF.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nINF  -1  0  INF\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nINF INF INF  -1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nINF  -1 INF  -1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n  0  -1 INF INF\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nAfter running the function, the 2D grid should be:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n  3  -1   0   1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n  2   2   1  -1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n  1  -1   2  -1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n  0  -1   3   4\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- m == rooms.length\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- n == rooms[i].length\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"walls-and-gates\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"word-ladder\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Word Ladder\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Given two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"hard\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"graphs\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/word-ladder/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\":[],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nA transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- Every adjacent pair of words differs by a single letter.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- sk == endWord\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nGiven two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: beginWord = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"hit\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", endWord = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"cog\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", wordList = [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"hot\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"dot\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"dog\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"lot\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"log\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"cog\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: 5\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation: One shortest transformation sequence is \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"hit\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" -> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"hot\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" -> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"dot\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" -> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"dog\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" -> cog\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", which is 5 words long.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: beginWord = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"hit\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", endWord = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"cog\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", wordList = [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"hot\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"dot\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"dog\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"lot\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"log\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: 0\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nExplanation: The endWord \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"cog\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" is not in wordList, therefore there is no valid transformation sequence.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 1 <= beginWord.length <= 10\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- endWord.length == beginWord.length\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 1 <= wordList.length <= 5000\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- wordList[i].length == beginWord.length\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- beginWord, endWord, and wordList[i] consist of lowercase English letters.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- beginWord != endWord\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- All the words in wordList are unique.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"word-ladder\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"word-search-ii\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Word Search II\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Given an m x n board of characters and a list of strings words, return all words on the board.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[\\\\\\\\\\\\\\\"hard\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"trie\\\\\\\\\\\\\\\"],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/word-search-ii/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\":[],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nGiven an m x n board of characters and a list of strings words, return all words on the board.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nEach word must be constructed from letters of sequentially adjacent cells, where **adjacent cells** are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/11/07/search1.jpg)\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: board = [[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"o\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"a\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"a\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"e\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"t\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"a\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"e\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"i\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"h\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"k\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"i\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"f\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"l\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"v\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]], words = [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"oath\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"pea\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"eat\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"rain\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"eat\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"oath\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/11/07/search2.jpg)\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: board = [[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"a\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"b\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"c\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"d\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]], words = [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"abcb\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: []\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- m == board.length\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- n == board[i].length\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 1 <= m, n <= 12\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- board[i][j] is a lowercase English letter.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 1 <= words.length <= 3 * 10^4\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 1 <= words[i].length <= 10\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- words[i] consists of lowercase English letters.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- All the strings of `words` are unique.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"word-search-ii\\\\\\\\\\\\\\\"},\\\\\\\\\\\\\\\"word-search\\\\\\\\\\\\\\\":{\\\\\\\\\\\\\\\"title\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Word Search\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Given an m x n grid of characters board and a string word, return true if word exists in the grid.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"tags\\\\\\\\\\\\\\\":[],\\\\\\\\\\\\\\\"link\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"https://leetcode.com/problems/word-search/\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"images\\\\\\\\\\\\\\\":[],\\\\\\\\\\\\\\\"preview\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"### Description\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nGiven an `m x n` grid of characters `board` and a string `word`, return `true` if word exists in the grid.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nThe word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 1\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/11/04/word2.jpg)\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: board = [[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"B\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"E\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"S\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"F\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"S\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"D\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"E\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"E\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]], word = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"ABCCED\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: true\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 2\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg)\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: board = [[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"B\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"E\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"S\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"F\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"S\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"D\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"E\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"E\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]], word = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"SEE\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: true\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Example 3\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/10/15/word3.jpg)\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```bash\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nInput: board = [[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"B\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"E\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"S\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"F\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"S\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"D\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"E\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"E\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]], word = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"ABCB\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\nOutput: false\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n### Constraints:\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- m == board.length \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- n = board[i].length \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 1 <= m, n <= 6 \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- 1 <= word.length <= 15 \\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n- board and word consists of only lowercase and uppercase English letters.\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"basename\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"word-search\\\\\\\\\\\\\\\"}}\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"prompt\\\\\\\"},\\\\\\\"redundant-connection\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Redundant Connection\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"In this problem, a tree is an undirected graph that is connected and has no cycles.\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"medium\\\\\\\",\\\\\\\"graphs\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/redundant-connection/\\\\\\\",\\\\\\\"images\\\\\\\":[\\\\\\\"https://assets.leetcode.com/uploads/2021/05/02/reduntant1-1-graph.jpg\\\\\\\",\\\\\\\"https://assets.leetcode.com/uploads/2021/05/02/reduntant1-2-graph.jpg\\\\\\\"],\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nIn this problem, a tree is an **undirected graph** that is connected and has no cycles.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nYou are given a graph that started as a tree with n nodes labeled from 1 to n, with one additional edge added. The added edge has two **different** vertices chosen from 1 to n, and was not an edge that already existed. The graph is represented as an array edges of length n where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the graph.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nReturn an edge that can be removed so that the resulting graph is a tree of n nodes. If there are multiple answers, return the answer that occurs last in the input.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n![](https://assets.leetcode.com/uploads/2021/05/02/reduntant1-1-graph.jpg)\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: edges = [[1,2],[1,3],[2,3]]\\\\\\\\r\\\\\\\\nOutput: [2,3]\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n![](https://assets.leetcode.com/uploads/2021/05/02/reduntant1-2-graph.jpg)\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: edges = [[1,2],[2,3],[3,4],[1,4],[1,5]]\\\\\\\\r\\\\\\\\nOutput: [1,4]\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- n == edges.length\\\\\\\\r\\\\\\\\n- 3 <= n <= 1000\\\\\\\\r\\\\\\\\n- edges[i].length == 2\\\\\\\\r\\\\\\\\n- 1 <= ai < bi <= edges.length\\\\\\\\r\\\\\\\\n- ai != bi\\\\\\\\r\\\\\\\\n- There are no repeated edges.\\\\\\\\r\\\\\\\\n- The given graph is connected.\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"redundant-connection\\\\\\\"},\\\\\\\"regex-1\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Regex 1\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"create a markdown that returns all 'hackerrank' matches\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"easy\\\\\\\",\\\\\\\"regex\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://www.hackerrank.com/challenges/regex-1/problem\\\\\\\",\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nCreate a markdown that returns all 'hackerrank' matches\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput The hackerrank team is on a mission to flatten the world by restructuring the hackerrank DNA of every company on the planet. We rank programmers based on their coding skills, helping companies source great programmers and reduce the time to hire. As a result, we are revolutionizing the way companies discover and evaluate talented engineers. The hackerrank platform is the destination for the best engineers to hone their skills and companies to find top engineers. \\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nOutput: ['hackerrank', 'hackerrank', 'hackerrank']\\\\\\\\r\\\\\\\\n```\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"regex-1\\\\\\\"},\\\\\\\"remove-from-nth\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Remove Nth Node From End of List\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"Given the head of a linked list, remove the nth node from the end of the list and return its head.\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"medium\\\\\\\",\\\\\\\"linked-list\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/remove-nth-node-from-end-of-list/\\\\\\\",\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nGiven the head of a linked list, remove the nth node from the end of the list and return its head.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: head = [1,2,3,4,5], n = 2\\\\\\\\r\\\\\\\\nOutput: [1,2,3,5]\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: head = [1], n = 1\\\\\\\\r\\\\\\\\nOutput: []\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 3\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: head = [1,2], n = 1\\\\\\\\r\\\\\\\\nOutput: [1]\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- The number of nodes in the list is sz. \\\\\\\\r\\\\\\\\n- 1 <= sz <= 30 \\\\\\\\r\\\\\\\\n- 0 <= Node.val <= 100 \\\\\\\\r\\\\\\\\n- 1 <= n <= sz\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"remove-from-nth\\\\\\\"},\\\\\\\"reorder-list\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Reorder List\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"You are given the head of a singly linked-list. The list can be represented as\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"medium\\\\\\\",\\\\\\\"linked-list\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/reorder-list/\\\\\\\",\\\\\\\"images\\\\\\\":[\\\\\\\"https://assets.leetcode.com/uploads/2021/03/04/reorder1linked-list.jpg\\\\\\\",\\\\\\\"https://assets.leetcode.com/uploads/2021/03/04/reorder2linked-list.jpg\\\\\\\"],\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nYou are given the head of a singly linked-list. The list can be represented as:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n`L0 â†’ L1 â†’ â€¦ â†’ Ln - 1 â†’ Ln`\\\\\\\\r\\\\\\\\nReorder the list to be on the following form:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n`L0 â†’ Ln â†’ L1 â†’ Ln - 1 â†’ L2 â†’ Ln - 2 â†’ â€¦`\\\\\\\\r\\\\\\\\nYou may not modify the values in the list's nodes. Only nodes themselves may be changed.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n![](https://assets.leetcode.com/uploads/2021/03/04/reorder1linked-list.jpg)\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: head = [1,2,3,4]\\\\\\\\r\\\\\\\\nOutput: [1,4,2,3]\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n![](https://assets.leetcode.com/uploads/2021/03/04/reorder2linked-list.jpg)\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: head = [1,2,3,4,5]\\\\\\\\r\\\\\\\\nOutput: [1,5,2,4,3]\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- The number of nodes in the list is in the range [1, 5 * 104]. \\\\\\\\r\\\\\\\\n- 1 <= Node.val <= 1000\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"reorder-list\\\\\\\"},\\\\\\\"reverse-linked-list\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Reverse Linked List\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"Given the head of a singly linked list, reverse the list, and return the reversed list.\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"easy\\\\\\\",\\\\\\\"linked-list\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/reverse-linked-list/\\\\\\\",\\\\\\\"images\\\\\\\":[\\\\\\\"https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg\\\\\\\",\\\\\\\"https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg\\\\\\\"],\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nGovem the `head` of a singly linked list, reverse the list, and return the reversed list.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n![](https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg)\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: head = [1,2,3,4,5]\\\\\\\\r\\\\\\\\nOutput: [5,4,3,2,1]\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n![](https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg)\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: head = [1,2]\\\\\\\\r\\\\\\\\nOutput: [2,1]\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 3\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: head = []\\\\\\\\r\\\\\\\\nOutput: []\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- The number of nodes in the list is the range [0, 5000].\\\\\\\\r\\\\\\\\n- -5000 <= Node.val <= 5000\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"reverse-linked-list\\\\\\\"},\\\\\\\"reverse-nodes-in-k-group\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Reverse Nodes in k-Group\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"hard\\\\\\\",\\\\\\\"linked-list\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/reverse-nodes-in-k-group/\\\\\\\",\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nGiven the `head` of a linked list, reverse the nodes of the list `k` at a time, and return the modified list.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n`k` is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of `k` then left-out nodes, in the end, should remain as it is.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nYou may not alter the values in the list's nodes, only nodes themselves may be changed.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: head = [1,2,3,4,5], k = 2\\\\\\\\r\\\\\\\\nOutput: [2,1,4,3,5]\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: head = [1,2,3,4,5], k = 3\\\\\\\\r\\\\\\\\nOutput: [3,2,1,4,5]\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- The number of nodes in the list is n. \\\\\\\\r\\\\\\\\n- 1 <= k <= n <= 5000 \\\\\\\\r\\\\\\\\n- 0 <= Node.val <= 1000\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"reverse-nodes-in-k-group\\\\\\\"},\\\\\\\"rotting-oranges\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Rotting Oranges\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1.\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"medium\\\\\\\",\\\\\\\"graphs\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/rotting-oranges/\\\\\\\",\\\\\\\"images\\\\\\\":[\\\\\\\"https://assets.leetcode.com/uploads/2019/02/16/oranges.png\\\\\\\"],\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nYou are given an m x n grid where each cell can have one of three values:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- 0 representing an empty cell,\\\\\\\\r\\\\\\\\n- 1 representing a fresh orange, or\\\\\\\\r\\\\\\\\n- 2 representing a rotten orange.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nEvery minute, any fresh orange that is **4-directionally** adjacent to a rotten orange becomes rotten.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nReturn the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n![](https://assets.leetcode.com/uploads/2019/02/16/oranges.png)\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: grid = [[2,1,1],[1,1,0],[0,1,1]]\\\\\\\\r\\\\\\\\nOutput: 4\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: grid = [[2,1,1],[0,1,1],[1,0,1]]\\\\\\\\r\\\\\\\\nOutput: -1\\\\\\\\r\\\\\\\\nExplanation: The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally.\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 3\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: grid = [[0,2]]\\\\\\\\r\\\\\\\\nOutput: 0\\\\\\\\r\\\\\\\\nExplanation: Since there are already no fresh oranges at minute 0, the answer is just 0.\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- m == grid.length \\\\\\\\r\\\\\\\\n- n == grid[i].length\\\\\\\\r\\\\\\\\n- 1 <= m, n <= 10 \\\\\\\\r\\\\\\\\n- grid[i][j] is 0, 1, or 2.\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"rotting-oranges\\\\\\\"},\\\\\\\"same-tree\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Same Tree\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"Given the roots of two binary trees p and q, write a function to check if they are the same or not.\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"easy\\\\\\\",\\\\\\\"binary-tree\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/same-tree/\\\\\\\",\\\\\\\"images\\\\\\\":[\\\\\\\"https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg\\\\\\\",\\\\\\\"https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg\\\\\\\",\\\\\\\"https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg\\\\\\\"],\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nGiven the roots of two binary trees p and q, write a function to check if they are the same or not.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg)\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: p = [1,2,3], q = [1,2,3]\\\\\\\\r\\\\\\\\nOutput: true\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg)\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: p = [1,2], q = [1,null,2]\\\\\\\\r\\\\\\\\nOutput: false\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 3\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg)\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: p = [1,2,1], q = [1,1,2]\\\\\\\\r\\\\\\\\nOutput: false\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- The number of nodes in both trees is in the range [0, 100]. \\\\\\\\r\\\\\\\\n- -10^4 <= Node.val <= 10^4\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"same-tree\\\\\\\"},\\\\\\\"sample\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Bellflower\\\\\\\",\\\\\\\"author\\\\\\\":\\\\\\\"guy\\\\\\\",\\\\\\\"date\\\\\\\":\\\\\\\"2012-07-23T00:00:00.000Z\\\\\\\",\\\\\\\"template\\\\\\\":\\\\\\\"article.jade\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"crab\\\\\\\",\\\\\\\"rose\\\\\\\",\\\\\\\"bells\\\\\\\"],\\\\\\\"preview\\\\\\\":\\\\\\\"## Interesting\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nHow strange are those old recollections which haunt us without our being able to get rid of them! This one is so very old that I cannot understand how it has clung so vividly and tenaciously to my memory. Since then I have seen so many sinister things, either affecting or terrible, that I am astonished at not being able to pass a single day without the face of Mother Bellflower recurring to my mind's eye, just as I knew her formerly long, long ago, when I was ten or twelve years old. <span class=\\\\\\\\\\\\\\\"more\\\\\\\\\\\\\\\"></span>\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nShe was an old seamstress who came to my parents' house once a week, every Thursday, to mend the linen. My parents lived in one of those country houses called chateaux, which are merely old houses with pointed roofs, to which are attached three or four adjacent farms.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nThe village, a large village, almost a small market town, was a few hundred yards off and nestled round the church, a red brick church, which had become black with age.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nWell, every Thursday Mother Bellflower came between half-past six and seven in the morning and went immediately into the linen room and began to work. She was a tall, thin, bearded or rather hairy woman, for she had a beard all over her face, a surprising, an unexpected beard, growing in improbable tufts, in curly bunches which looked as if they had been sown by a madman over that great face, the face of a gendarme in petticoats. She had them on her nose, under her nose, round her nose, on her chin, on her cheeks, and her eyebrows, which were extraordinarily thick and long and quite gray, bushy and bristling, looked exactly like a pair of mustaches stuck on there by mistake.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nShe limped, not like lame people generally do, but like a ship pitching. When she planted her great bony, vibrant body on her sound leg, she seemed to be preparing to mount some enormous wave, and then suddenly she dipped as if to disappear in an abyss and buried herself in the ground. Her walk reminded one of a ship in a storm, and her head, which was always covered with an enormous white cap, whose ribbons fluttered down her back, seemed to traverse the horizon from north to south and from south to north at each limp.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nI adored Mother Bellflower. As soon as I was up I used to go into the linen room, where I found her installed at work with a foot warmer under her feet. As soon as I arrived she made me take the foot warmer and sit upon it, so that I might not catch cold in that large chilly room under the roof.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n\\\\\\\\\\\\\\\"That draws the blood from your head,\\\\\\\\\\\\\\\" she would say to me.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nShe told me stories while mending the linen with her long, crooked, nimble fingers; behind her magnifying spectacles, for age had impaired her sight, her eyes appeared enormous to me, strangely profound, double.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nAs far as I can remember from the things which she told me and by which my childish heart was moved, she had the large heart of a poor woman. She told me what had happened in the village, how a cow had escaped from the cow house and had been found the next morning in front of Prosper Malet's mill looking at the sails turning, or about a hen's egg which had been found in the church belfry without anyone being able to understand what creature had been there to lay it, or the queer story of Jean Pila's dog who had gone ten leagues to bring back his master's breeches which a tramp had stolen while they were hanging up to dry out of doors after he had been caught in the rain. She told me these simple adventures in such a manner that in my mind they assumed the proportions of never-to-be-forgotten dramas, of grand and mysterious poems; and the ingenious stories invented by the poets, which my mother told me in the evening, had none of the flavor, none of the fullness or of the vigor of the peasant woman's narratives.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nWell, one Thursday when I had spent all the morning in listening to Mother Clochette, I wanted to go upstairs to her again during the day after picking hazelnuts with the manservant in the wood behind the farm. I remember it all as clearly as what happened only yesterday.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nOn opening the door of the linen room I saw the old seamstress lying on the floor by the side of her chair, her face turned down and her arms stretched out, but still holding her needle in one hand and one of my shirts in the other. One of her legs in a blue stocking, the longer one no doubt, was extended under her chair, and her spectacles glistened by the wall, where they had rolled away from her.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nI ran away uttering shrill cries. They all came running, and in a few minutes I was told that Mother Clochette was dead.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nI cannot describe the profound, poignant, terrible emotion which stirred my childish heart. I went slowly down into the drawing room and hid myself in a dark corner in the depths of a great old armchair, where I knelt and wept. I remained there for a long time, no doubt, for night came on. Suddenly someone came in with a lamp--without seeing me, however--and heard my father and mother talking with the medical man, whose voice recognized.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nHe had been sent for immediately, and he was explaining the cause of the accident, of which I understood nothing, however. Then he sat down and had a glass of liqueur and a biscuit.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nHe went on talking, and what he then said will remain engraved on my mind until I die. I think that I can give the exact words which he used.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n\\\\\\\\\\\\\\\"Ah!\\\\\\\\\\\\\\\" he said. \\\\\\\\\\\\\\\"The poor woman! she broke her leg the day of my arrival here. I had not even had time to wash my hands after getting off the diligence before I was sent for in all haste, for it was a bad case, very bad.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n\\\\\\\\\\\\\\\"She was seventeen and a pretty girl, very pretty! Would anyone believe it? I have never told her story before; in fact, no one but myself and one other person, who is no longer living in this part of the country, ever knew it. Now that she is dead I may be less discreet.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n\\\\\\\\\\\\\\\"A young assistant teacher had just come to live in the village; he was good looking and had the bearing of a soldier. All the girls ran after him, but he was disdainful. Besides that, he was very much afraid of his superior, the schoolmaster, old Grabu, who occasionally got out of bed the wrong foot first.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n\\\\\\\\\\\\\\\"Old Grabu already employed pretty Hortense, who has just died here and who was afterward nicknamed Clochette. The assistant master singled out the pretty young girl who was no doubt flattered at being chosen by this disdainful conqueror; at any rate, she fell in love with him, and he succeeded in persuading her to give him a first meeting in the hayloft behind the school at night after she had done her day's sewing.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n\\\\\\\\\\\\\\\"She pretended to go home, but instead of going downstairs when she left the Grabus', she went upstairs and hid among the hay to wait for her lover. He soon joined her, and he was beginning to say pretty things to her, when the door of the hayloft opened and the schoolmaster appeared and asked: 'What are you doing up there, Sigisbert?' Feeling sure that he would be caught, the young schoolmaster lost his presence of mind and replied stupidly: 'I came up here to rest a little among the bundles of hay, Monsieur Grabu.'\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n\\\\\\\\\\\\\\\"The loft was very large and absolutely dark. Sigisbert pushed the frightened girl to the farther end and said: 'Go, there and hide yourself. I shall lose my situation, so get away and hide yourself.'\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n\\\\\\\\\\\\\\\"When the schoolmaster heard the whispering he continued: 'Why, you are not by yourself.'\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n\\\\\\\\\\\\\\\"'Yes, I am, Monsieur Grabu!'\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n\\\\\\\\\\\\\\\"'But you are not, for you are talking.'\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n\\\\\\\\\\\\\\\"'I swear I am, Monsieur Grabu.'\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n\\\\\\\\\\\\\\\"'I will soon find out,' the old man replied and, double-locking the door, he went down to get a light.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n\\\\\\\\\\\\\\\"Then the young man, who was a coward such as one sometimes meets, lost his head, and he repeated, having grown furious all of a sudden: 'Hide yourself, so that he may not find you. You will deprive me of my bread for my whole life; you will ruin my whole career! Do hide yourself!'\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n\\\\\\\\\\\\\\\"They could hear the key turning in the lock again, and Hortense ran to the window which looked out onto the street, opened it quickly and then in a low and determined voice said: 'You will come and pick me up when he is gone,' and she jumped out.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n\\\\\\\\\\\\\\\"Old Grabu found nobody and went down again in great surprise! A quarter of an hour later Monsieur Sigisbert came to me and related his adventure. The girl had remained at the foot of the wall, unable to get up, as she had fallen from the second story, and I went with him to fetch her. It was raining in torrents, and I brought the unfortunate girl home with me, for the right leg was broken in three places, and the bones had come out through the flesh. She did not complain and merely said with admirable resignation: 'I am punished, well punished!'\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n\\\\\\\\\\\\\\\"I sent for assistance and for the workgirl's friends and told them a made-up story of a runaway carriage which had knocked her down and lamed her outside my door. They believed me, and the gendarmes for a whole month tried in vain to find the author of this accident.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n\\\\\\\\\\\\\\\"That is all! Now I say that this woman was a heroine and had the fiber of those who accomplish the grandest deeds in history.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n\\\\\\\\\\\\\\\"That was her only love affair, and she died a virgin. She was a martyr, a noble soul, a sublimely devoted woman! And if I did not absolutely admire her I should not have told you this story, which I would never tell anyone during her life; you understand why.\\\\\\\\\\\\\\\"\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nThe doctor ceased; Mamma cried, and Papa said some words which I did not catch; then they left the room, and I remained on my knees in the armchair and sobbed, while I heard a strange noise of heavy footsteps and something knocking against the side of the staircase.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nThey were carrying away Clochette's body.\\\\\\\",\\\\\\\"iso8601Date\\\\\\\":\\\\\\\"2012-07-22T20:00:00-04:00\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"sample\\\\\\\"},\\\\\\\"search-matrix\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Search a 2D Matrix\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"You are given an m x n integer matrix matrix with the following two properties\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"medium\\\\\\\",\\\\\\\"binary-search\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/search-a-2d-matrix/\\\\\\\",\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nYou are given an `m x n` integer matrix `matrix` with the following two properties:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n    Each row is sorted in non-decreasing order.\\\\\\\\r\\\\\\\\n    The first integer of each row is greater than the last integer of the previous row.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nGiven an integer target, return `true` if `target` is in `matrix` or `false` otherwise.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nYou must write a solution in `O(log(m * n))` time complexity.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n![figure1](https://assets.leetcode.com/uploads/2020/10/05/mat.jpg)\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\\\\\\\\r\\\\\\\\nOutput: true\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n![figure2](https://assets.leetcode.com/uploads/2020/10/05/mat2.jpg)\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13\\\\\\\\r\\\\\\\\nOutput: false\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- m == matrix.length\\\\\\\\r\\\\\\\\n- n == matrix[i].length\\\\\\\\r\\\\\\\\n- 1 <= m, n <= 100\\\\\\\\r\\\\\\\\n- -104 <= matrix[i][j], target <= 104\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"search-matrix\\\\\\\"},\\\\\\\"search-rotated-array\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Search in Rotated Sorted Array\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"medium\\\\\\\",\\\\\\\"binary-search\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/search-in-rotated-sorted-array/\\\\\\\",\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nThere is an integer array `nums` sorted in ascending order (with **distinct** values).\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nPrior to being passed to your function, nums is **possibly rotated** at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nGiven the array `nums` **after** the possible rotation and an integer target, return the index of `target` if it is in `nums`, or `-1` if it is not in `nums`.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nYou must write an algorithm with O(log n) runtime complexity.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: nums = [4,5,6,7,0,1,2], target = 0\\\\\\\\r\\\\\\\\nOutput: 4\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: nums = [4,5,6,7,0,1,2], target = 3\\\\\\\\r\\\\\\\\nOutput: -1\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 3\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: nums = [1], target = 0\\\\\\\\r\\\\\\\\nOutput: -1\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n-      1 <= nums.length <= 5000     \\\\\\\\r\\\\\\\\n-      -104 <= nums[i] <= 104     \\\\\\\\r\\\\\\\\n-      All values of nums are unique.     \\\\\\\\r\\\\\\\\n-      nums is an ascending array that is possibly rotated.     \\\\\\\\r\\\\\\\\n-      -104 <= target <= 104\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"search-rotated-array\\\\\\\"},\\\\\\\"serialize-and-deserialize-binary-tree\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Serialize and Deserialize Binary Tree\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"hard\\\\\\\",\\\\\\\"binary-tree\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/serialize-and-deserialize-binary-tree/\\\\\\\",\\\\\\\"images\\\\\\\":[\\\\\\\"https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg\\\\\\\"],\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nSerialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nDesign an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n**Clarification**: The input/output format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg)\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: root = [1,2,3,null,null,4,5]\\\\\\\\r\\\\\\\\nOutput: [1,2,3,null,null,4,5]\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: root = []\\\\\\\\r\\\\\\\\nOutput: []\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- The number of nodes in the tree is in the range [0, 10^4]. \\\\\\\\r\\\\\\\\n- -1000 <= Node.val <= 1000\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"serialize-and-deserialize-binary-tree\\\\\\\"},\\\\\\\"simple-division\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Simple Division\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"A simple division example\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"sample\\\\\\\",\\\\\\\"math\\\\\\\"],\\\\\\\"preview\\\\\\\":\\\\\\\"This is  a simple division example.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```js\\\\\\\\r\\\\\\\\nimport { prompt } from 'dsa-cli';\\\\\\\\r\\\\\\\\nconst a = prompt('Enter a number: ');\\\\\\\\r\\\\\\\\nconst b = prompt('Enter another number: ');\\\\\\\\r\\\\\\\\nconsole.log(a / b);\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\n$ dsa run simple-division.js\\\\\\\\r\\\\\\\\nEnter a number: 10\\\\\\\\r\\\\\\\\n```\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"simple-division\\\\\\\"},\\\\\\\"simple-substraction\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Simple Substraction\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"A simple substraction example\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"sample\\\\\\\",\\\\\\\"math\\\\\\\"],\\\\\\\"preview\\\\\\\":\\\\\\\"This is  a simple substraction example.!\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```js\\\\\\\\r\\\\\\\\nimport { prompt } from 'dsa-cli';\\\\\\\\r\\\\\\\\nconst a = prompt('Enter a number: ');\\\\\\\\r\\\\\\\\nconst b = prompt('Enter another number: ');\\\\\\\\r\\\\\\\\nconsole.log(a - b);\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\n$ dsa run simple-substraction.js\\\\\\\\r\\\\\\\\nEnter a number: 11\\\\\\\\r\\\\\\\\nEnter another number: 5\\\\\\\\r\\\\\\\\n```\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"simple-substraction\\\\\\\"},\\\\\\\"simple-sum\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Simple Sum\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"A simple sum example!\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"sample\\\\\\\",\\\\\\\"math\\\\\\\"],\\\\\\\"preview\\\\\\\":\\\\\\\"This is  a simple sum example.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```js\\\\\\\\r\\\\\\\\nimport { prompt } from 'dsa-cli';\\\\\\\\r\\\\\\\\nconst a = prompt('Enter a number: ');\\\\\\\\r\\\\\\\\nconst b = prompt('Enter another number: ');\\\\\\\\r\\\\\\\\nconsole.log(a + b);\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\n$ dsa run simple-sum.js\\\\\\\\r\\\\\\\\nEnter a number: 10\\\\\\\\r\\\\\\\\nEnter another number:\\\\\\\\r\\\\\\\\n```\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"simple-sum\\\\\\\"},\\\\\\\"subsets-ii\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Subsets II\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"Given an integer array nums that may contain duplicates, return all possible subsets (the power set).\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"medium\\\\\\\",\\\\\\\"backtracking\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/subsets-ii/\\\\\\\",\\\\\\\"images\\\\\\\":[],\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nGiven an integer array `nums` that may contain duplicates, return all possible subsets (the power set).\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nThe solution set **must not** contain duplicate subsets. Return the solution in **any order**.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: nums = [1,2,2]\\\\\\\\r\\\\\\\\nOutput: [[],[1],[1,2],[1,2,2],[2],[2,2]]\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: nums = [0]\\\\\\\\r\\\\\\\\nOutput: [[],[0]]\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- 1 <= nums.length <= 10\\\\\\\\r\\\\\\\\n- -10 <= nums[i] <= 10\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"subsets-ii\\\\\\\"},\\\\\\\"subsets\\\\\\\":{\\\\\\\"preview\\\\\\\":\\\\\\\"\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"subsets\\\\\\\"},\\\\\\\"subtree-of-another-tree\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Subtree of Another Tree\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"A subtree of a binary tree tree is a tree that consists of a node in tree and all of this node's descendants. The tree tree could also be considered as a subtree of itself.\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"easy\\\\\\\",\\\\\\\"binary-tree\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/subtree-of-another-tree/\\\\\\\",\\\\\\\"images\\\\\\\":[\\\\\\\"https://assets.leetcode.com/uploads/2021/02/18/tree1.jpg\\\\\\\",\\\\\\\"https://assets.leetcode.com/uploads/2021/02/18/tree2.jpg\\\\\\\"],\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nGiven the roots of two binary trees `root` and `subRoot`, return true if there is a subtree of root with the same structure and node values of `subRoot` and `false` otherwise.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nA subtree of a binary tree `tree` is a tree that consists of a node in tree and all of this node's descendants. The tree `tree` could also be considered as a subtree of itself.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n![](https://assets.leetcode.com/uploads/2021/02/18/tree1.jpg)\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: root = [3,4,5,1,2], subRoot = [4,1,2]\\\\\\\\r\\\\\\\\nOutput: true\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n![](https://assets.leetcode.com/uploads/2021/02/18/tree2.jpg)\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]\\\\\\\\r\\\\\\\\nOutput: false\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- The number of nodes in the root tree is in the range [1, 2000]. \\\\\\\\r\\\\\\\\n- The number of nodes in the subRoot tree is in the range [1, 1000]. \\\\\\\\r\\\\\\\\n- -10^4 <= root.val <= 10^4 \\\\\\\\r\\\\\\\\n- -10^4 <= subRoot.val <= 10^4\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"subtree-of-another-tree\\\\\\\"},\\\\\\\"surrounded-regions\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Surrounded Regions\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"Given an m x n matrix board containing 'X' and 'O', capture all regions that are 4-directionally surrounded by 'X'.\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"medium\\\\\\\",\\\\\\\"graphs\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/surrounded-regions/\\\\\\\",\\\\\\\"images\\\\\\\":[\\\\\\\"https://assets.leetcode.com/uploads/2021/02/19/xogrid.jpg\\\\\\\"],\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nGiven an `m x n` matrix board containing 'X' and 'O', capture all regions that are 4-directionally surrounded by 'X'.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nA region is **captured** by flipping all 'O's into 'X's in that surrounded region.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n![](https://assets.leetcode.com/uploads/2021/02/19/xogrid.jpg)\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: board = [[\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"O\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"O\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"O\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"O\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\"]]\\\\\\\\r\\\\\\\\nOutput: [[\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"O\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\"]]\\\\\\\\r\\\\\\\\nExplanation: Notice that an 'O' should not be flipped if:\\\\\\\\r\\\\\\\\n- It is on the border, or\\\\\\\\r\\\\\\\\n- It is adjacent to an 'O' that should not be flipped.\\\\\\\\r\\\\\\\\nThe bottom 'O' is on the border, so it is not flipped.\\\\\\\\r\\\\\\\\nThe other three 'O' form a surrounded region, so they are flipped.\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: board = [[\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\"]]\\\\\\\\r\\\\\\\\nOutput: [[\\\\\\\\\\\\\\\"X\\\\\\\\\\\\\\\"]]\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- m == board.length\\\\\\\\r\\\\\\\\n- n == board[i].length\\\\\\\\r\\\\\\\\n- 1 <= m, n <= 200\\\\\\\\r\\\\\\\\n- board[i][j] is 'X' or 'O'\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"surrounded-regions\\\\\\\"},\\\\\\\"task-scheduler\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Task Scheduler\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"Return the least number of units of times that the CPU will take to finish all the given tasks.\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"medium\\\\\\\",\\\\\\\"heap\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/task-scheduler/\\\\\\\",\\\\\\\"images\\\\\\\":[],\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nGiven a characters array tasks, representing the tasks a CPU needs to do, where each letter represents a different task. Tasks could be done in any order. Each task is done in one unit of time. For each unit of time, the CPU could complete either one task or just be idle.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nHowever, there is a non-negative integer n that represents the cooldown period between two **same tasks** (the same letter in the array), that is that there must be at least n units of time between any two same tasks.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nReturn the least number of units of times that the CPU will take to finish all the given tasks.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: tasks = [\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"B\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"B\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"B\\\\\\\\\\\\\\\"], n = 2\\\\\\\\r\\\\\\\\nOutput: 8\\\\\\\\r\\\\\\\\nExplanation: \\\\\\\\r\\\\\\\\nA -> B -> idle -> A -> B -> idle -> A -> B\\\\\\\\r\\\\\\\\nThere is at least 2 units of time between any two same tasks.\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: tasks = [\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"B\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"B\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"B\\\\\\\\\\\\\\\"], n = 0\\\\\\\\r\\\\\\\\nOutput: 6\\\\\\\\r\\\\\\\\nExplanation: On this case any permutation of size 6 would work since n = 0.\\\\\\\\r\\\\\\\\n[\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"B\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"B\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"B\\\\\\\\\\\\\\\"]\\\\\\\\r\\\\\\\\n[\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"B\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"B\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"B\\\\\\\\\\\\\\\"]\\\\\\\\r\\\\\\\\n[\\\\\\\\\\\\\\\"B\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"B\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"B\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\"]\\\\\\\\r\\\\\\\\n...\\\\\\\\r\\\\\\\\nAnd so on.\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 3\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: tasks = [\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"B\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"D\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"E\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"F\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"G\\\\\\\\\\\\\\\"], n = 2\\\\\\\\r\\\\\\\\nOutput: 16\\\\\\\\r\\\\\\\\nExplanation: \\\\\\\\r\\\\\\\\nOne possible solution is\\\\\\\\r\\\\\\\\nA -> B -> C -> A -> D -> E -> A -> F -> G -> A -> idle -> idle -> A -> idle -> idle -> A\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- 1 <= task.length <= 10^4 \\\\\\\\r\\\\\\\\n- tasks[i] is upper-case English letter. \\\\\\\\r\\\\\\\\n- The integer n is in the range [0, 100].\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"task-scheduler\\\\\\\"},\\\\\\\"three-number-sum\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Three Number Sum\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"A three number sum example\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"arrays\\\\\\\",\\\\\\\"math\\\\\\\"],\\\\\\\"preview\\\\\\\":\\\\\\\"## Three Number Sum\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nGiven an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nNotice that the solution set must not contain duplicate triplets.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n \\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nExample 1:\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\nInput: nums = [-1,0,1,2,-1,-4]\\\\\\\\r\\\\\\\\nOutput: [[-1,-1,2],[-1,0,1]]\\\\\\\\r\\\\\\\\nExplanation: \\\\\\\\r\\\\\\\\nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\\\\\\\\r\\\\\\\\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\\\\\\\\r\\\\\\\\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\\\\\\\\r\\\\\\\\nThe distinct triplets are [-1,0,1] and [-1,-1,2].\\\\\\\\r\\\\\\\\nNotice that the order of the output and the order of the triplets does not matter.\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nExample 2:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\nInput: nums = [0,1,1]\\\\\\\\r\\\\\\\\nOutput: []\\\\\\\\r\\\\\\\\nExplanation: The only possible triplet does not sum up to 0.\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nExample 3:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\nInput: nums = [0,0,0]\\\\\\\\r\\\\\\\\nOutput: [[0,0,0]]\\\\\\\\r\\\\\\\\nExplanation: The only possible triplet sums up to 0.\\\\\\\\r\\\\\\\\n```\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"three-number-sum\\\\\\\"},\\\\\\\"trapping-rain-water\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Trapping Rain Water\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"A trapping rain water example\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"hard\\\\\\\",\\\\\\\"two-pointers\\\\\\\"],\\\\\\\"preview\\\\\\\":\\\\\\\"Given `n` non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nExample 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\nInput: height = [0,1,0,2,1,0,1,3,2,1,2,1]\\\\\\\\r\\\\\\\\nOutput: 6\\\\\\\\r\\\\\\\\nExplanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nExample 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\nInput: height = [4,2,0,3,2,5]\\\\\\\\r\\\\\\\\nOutput: 9\\\\\\\\r\\\\\\\\n```\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"trapping-rain-water\\\\\\\"},\\\\\\\"valid-parentheses\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Valid Parentheses\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"easy\\\\\\\",\\\\\\\"stack\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/valid-parentheses/\\\\\\\",\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nGiven a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nAn input string is valid if:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nOpen brackets must be closed by the same type of brackets.\\\\\\\\r\\\\\\\\nOpen brackets must be closed in the correct order.\\\\\\\\r\\\\\\\\nEvery close bracket has a corresponding open bracket of the same type.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: s = \\\\\\\\\\\\\\\"()\\\\\\\\\\\\\\\"\\\\\\\\r\\\\\\\\nOutput: true\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: s = \\\\\\\\\\\\\\\"()[]{}\\\\\\\\\\\\\\\"\\\\\\\\r\\\\\\\\nOutput: true\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 3\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: s = \\\\\\\\\\\\\\\"(]\\\\\\\\\\\\\\\"\\\\\\\\r\\\\\\\\nOutput: false\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n-      1 <= s.length <= 104     \\\\\\\\r\\\\\\\\n-      s consists of parentheses only '()[]{}'.\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"valid-parentheses\\\\\\\"},\\\\\\\"validate-binary-search-tree\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Validate Binary Search Tree\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"Given the root of a binary tree, determine if it is a valid binary search tree (BST).\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"medium\\\\\\\",\\\\\\\"binary-tree\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/validate-binary-search-tree/\\\\\\\",\\\\\\\"images\\\\\\\":[\\\\\\\"https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg\\\\\\\",\\\\\\\"https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg\\\\\\\"],\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nGiven the root of a binary tree, determine if it is a valid binary search tree (BST).\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nA valid BST is defined as follows:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- The left subtree of a node contains only nodes with keys less than the node's key.\\\\\\\\r\\\\\\\\n- The right subtree of a node contains only nodes with keys greater than the node's key.\\\\\\\\r\\\\\\\\n- Both the left and right subtrees must also be binary search trees.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg)\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: root = [2,1,3]\\\\\\\\r\\\\\\\\nOutput: true\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg)\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: root = [5,1,4,null,null,3,6]\\\\\\\\r\\\\\\\\nOutput: false\\\\\\\\r\\\\\\\\nExplanation: The root node's value is 5 but its right child's value is 4.\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- The number of nodes in the tree is in the range [1, 104].\\\\\\\\r\\\\\\\\n- -2^31 <= Node.val <= 2^31 - 1\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"validate-binary-search-tree\\\\\\\"},\\\\\\\"walls-and-gates\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Walls and Gates\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should be filled with INF.\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"medium\\\\\\\",\\\\\\\"graphs\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://tenderleo.gitbooks.io/leetcode-solutions-/content/GoogleMedium/286.html\\\\\\\",\\\\\\\"images\\\\\\\":[],\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nYou are given a m x n 2D grid initialized with these three possible values.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n-1 - A wall or an obstacle. 0 - A gate. INF - Infinity means an empty room. We use the value 231 - 1 = 2147483647 to represent INF as you may assume that the distance to a gate is less than 2147483647. Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should be filled with INF.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nINF  -1  0  INF\\\\\\\\r\\\\\\\\nINF INF INF  -1\\\\\\\\r\\\\\\\\nINF  -1 INF  -1\\\\\\\\r\\\\\\\\n  0  -1 INF INF\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\nAfter running the function, the 2D grid should be:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\n  3  -1   0   1\\\\\\\\r\\\\\\\\n  2   2   1  -1\\\\\\\\r\\\\\\\\n  1  -1   2  -1\\\\\\\\r\\\\\\\\n  0  -1   3   4\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- m == rooms.length\\\\\\\\r\\\\\\\\n- n == rooms[i].length\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"walls-and-gates\\\\\\\"},\\\\\\\"word-ladder\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Word Ladder\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"Given two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"hard\\\\\\\",\\\\\\\"graphs\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/word-ladder/\\\\\\\",\\\\\\\"images\\\\\\\":[],\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nA transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- Every adjacent pair of words differs by a single letter.\\\\\\\\r\\\\\\\\n- Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList.\\\\\\\\r\\\\\\\\n- sk == endWord\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nGiven two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n \\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: beginWord = \\\\\\\\\\\\\\\"hit\\\\\\\\\\\\\\\", endWord = \\\\\\\\\\\\\\\"cog\\\\\\\\\\\\\\\", wordList = [\\\\\\\\\\\\\\\"hot\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"dot\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"dog\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"lot\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"log\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"cog\\\\\\\\\\\\\\\"]\\\\\\\\r\\\\\\\\nOutput: 5\\\\\\\\r\\\\\\\\nExplanation: One shortest transformation sequence is \\\\\\\\\\\\\\\"hit\\\\\\\\\\\\\\\" -> \\\\\\\\\\\\\\\"hot\\\\\\\\\\\\\\\" -> \\\\\\\\\\\\\\\"dot\\\\\\\\\\\\\\\" -> \\\\\\\\\\\\\\\"dog\\\\\\\\\\\\\\\" -> cog\\\\\\\\\\\\\\\", which is 5 words long.\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: beginWord = \\\\\\\\\\\\\\\"hit\\\\\\\\\\\\\\\", endWord = \\\\\\\\\\\\\\\"cog\\\\\\\\\\\\\\\", wordList = [\\\\\\\\\\\\\\\"hot\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"dot\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"dog\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"lot\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"log\\\\\\\\\\\\\\\"]\\\\\\\\r\\\\\\\\nOutput: 0\\\\\\\\r\\\\\\\\nExplanation: The endWord \\\\\\\\\\\\\\\"cog\\\\\\\\\\\\\\\" is not in wordList, therefore there is no valid transformation sequence.\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- 1 <= beginWord.length <= 10\\\\\\\\r\\\\\\\\n- endWord.length == beginWord.length\\\\\\\\r\\\\\\\\n- 1 <= wordList.length <= 5000\\\\\\\\r\\\\\\\\n- wordList[i].length == beginWord.length\\\\\\\\r\\\\\\\\n- beginWord, endWord, and wordList[i] consist of lowercase English letters.\\\\\\\\r\\\\\\\\n- beginWord != endWord\\\\\\\\r\\\\\\\\n- All the words in wordList are unique.\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"word-ladder\\\\\\\"},\\\\\\\"word-search-ii\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Word Search II\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"Given an m x n board of characters and a list of strings words, return all words on the board.\\\\\\\",\\\\\\\"tags\\\\\\\":[\\\\\\\"hard\\\\\\\",\\\\\\\"trie\\\\\\\"],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/word-search-ii/\\\\\\\",\\\\\\\"images\\\\\\\":[],\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nGiven an m x n board of characters and a list of strings words, return all words on the board.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nEach word must be constructed from letters of sequentially adjacent cells, where **adjacent cells** are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/11/07/search1.jpg)\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: board = [[\\\\\\\\\\\\\\\"o\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"a\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"a\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"n\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\"e\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"t\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"a\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"e\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\"i\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"h\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"k\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"r\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\"i\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"f\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"l\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"v\\\\\\\\\\\\\\\"]], words = [\\\\\\\\\\\\\\\"oath\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"pea\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"eat\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"rain\\\\\\\\\\\\\\\"]\\\\\\\\r\\\\\\\\nOutput: [\\\\\\\\\\\\\\\"eat\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"oath\\\\\\\\\\\\\\\"]\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/11/07/search2.jpg)\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: board = [[\\\\\\\\\\\\\\\"a\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"b\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\"c\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"d\\\\\\\\\\\\\\\"]], words = [\\\\\\\\\\\\\\\"abcb\\\\\\\\\\\\\\\"]\\\\\\\\r\\\\\\\\nOutput: []\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- m == board.length\\\\\\\\r\\\\\\\\n- n == board[i].length\\\\\\\\r\\\\\\\\n- 1 <= m, n <= 12\\\\\\\\r\\\\\\\\n- board[i][j] is a lowercase English letter.\\\\\\\\r\\\\\\\\n- 1 <= words.length <= 3 * 10^4\\\\\\\\r\\\\\\\\n- 1 <= words[i].length <= 10\\\\\\\\r\\\\\\\\n- words[i] consists of lowercase English letters.\\\\\\\\r\\\\\\\\n- All the strings of `words` are unique.\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"word-search-ii\\\\\\\"},\\\\\\\"word-search\\\\\\\":{\\\\\\\"title\\\\\\\":\\\\\\\"Word Search\\\\\\\",\\\\\\\"description\\\\\\\":\\\\\\\"Given an m x n grid of characters board and a string word, return true if word exists in the grid.\\\\\\\",\\\\\\\"tags\\\\\\\":[],\\\\\\\"link\\\\\\\":\\\\\\\"https://leetcode.com/problems/word-search/\\\\\\\",\\\\\\\"images\\\\\\\":[],\\\\\\\"preview\\\\\\\":\\\\\\\"### Description\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\nGiven an `m x n` grid of characters `board` and a string `word`, return `true` if word exists in the grid.\\\\\\\\r\\\\\\\\nThe word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 1\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/11/04/word2.jpg)\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: board = [[\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"B\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"E\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\"S\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"F\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"S\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"D\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"E\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"E\\\\\\\\\\\\\\\"]], word = \\\\\\\\\\\\\\\"ABCCED\\\\\\\\\\\\\\\"\\\\\\\\r\\\\\\\\nOutput: true\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 2\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg)\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: board = [[\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"B\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"E\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\"S\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"F\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"S\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"D\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"E\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"E\\\\\\\\\\\\\\\"]], word = \\\\\\\\\\\\\\\"SEE\\\\\\\\\\\\\\\"\\\\\\\\r\\\\\\\\nOutput: true\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Example 3\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n![](https://assets.leetcode.com/uploads/2020/10/15/word3.jpg)\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n```bash\\\\\\\\r\\\\\\\\nInput: board = [[\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"B\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"E\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\"S\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"F\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"S\\\\\\\\\\\\\\\"],[\\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"D\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"E\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\"E\\\\\\\\\\\\\\\"]], word = \\\\\\\\\\\\\\\"ABCB\\\\\\\\\\\\\\\"\\\\\\\\r\\\\\\\\nOutput: false\\\\\\\\r\\\\\\\\n```\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n### Constraints:\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n- m == board.length \\\\\\\\r\\\\\\\\n- n = board[i].length \\\\\\\\r\\\\\\\\n- 1 <= m, n <= 6 \\\\\\\\r\\\\\\\\n- 1 <= word.length <= 15 \\\\\\\\r\\\\\\\\n- board and word consists of only lowercase and uppercase English letters.\\\\\\\",\\\\\\\"basename\\\\\\\":\\\\\\\"word-search\\\\\\\"}}\\\",\\\"basename\\\":\\\"prompt\\\"},\\\"redundant-connection\\\":{\\\"title\\\":\\\"Redundant Connection\\\",\\\"description\\\":\\\"In this problem, a tree is an undirected graph that is connected and has no cycles.\\\",\\\"tags\\\":[\\\"medium\\\",\\\"graphs\\\"],\\\"link\\\":\\\"https://leetcode.com/problems/redundant-connection/\\\",\\\"images\\\":[\\\"https://assets.leetcode.com/uploads/2021/05/02/reduntant1-1-graph.jpg\\\",\\\"https://assets.leetcode.com/uploads/2021/05/02/reduntant1-2-graph.jpg\\\"],\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nIn this problem, a tree is an **undirected graph** that is connected and has no cycles.\\\\r\\\\n\\\\r\\\\nYou are given a graph that started as a tree with n nodes labeled from 1 to n, with one additional edge added. The added edge has two **different** vertices chosen from 1 to n, and was not an edge that already existed. The graph is represented as an array edges of length n where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the graph.\\\\r\\\\n\\\\r\\\\nReturn an edge that can be removed so that the resulting graph is a tree of n nodes. If there are multiple answers, return the answer that occurs last in the input.\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n![](https://assets.leetcode.com/uploads/2021/05/02/reduntant1-1-graph.jpg)\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: edges = [[1,2],[1,3],[2,3]]\\\\r\\\\nOutput: [2,3]\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n\\\\r\\\\n![](https://assets.leetcode.com/uploads/2021/05/02/reduntant1-2-graph.jpg)\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: edges = [[1,2],[2,3],[3,4],[1,4],[1,5]]\\\\r\\\\nOutput: [1,4]\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n- n == edges.length\\\\r\\\\n- 3 <= n <= 1000\\\\r\\\\n- edges[i].length == 2\\\\r\\\\n- 1 <= ai < bi <= edges.length\\\\r\\\\n- ai != bi\\\\r\\\\n- There are no repeated edges.\\\\r\\\\n- The given graph is connected.\\\",\\\"basename\\\":\\\"redundant-connection\\\"},\\\"regex-1\\\":{\\\"title\\\":\\\"Regex 1\\\",\\\"description\\\":\\\"create a markdown that returns all 'hackerrank' matches\\\",\\\"tags\\\":[\\\"easy\\\",\\\"regex\\\"],\\\"link\\\":\\\"https://www.hackerrank.com/challenges/regex-1/problem\\\",\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nCreate a markdown that returns all 'hackerrank' matches\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput The hackerrank team is on a mission to flatten the world by restructuring the hackerrank DNA of every company on the planet. We rank programmers based on their coding skills, helping companies source great programmers and reduce the time to hire. As a result, we are revolutionizing the way companies discover and evaluate talented engineers. The hackerrank platform is the destination for the best engineers to hone their skills and companies to find top engineers. \\\\r\\\\n\\\\r\\\\nOutput: ['hackerrank', 'hackerrank', 'hackerrank']\\\\r\\\\n```\\\",\\\"basename\\\":\\\"regex-1\\\"},\\\"remove-from-nth\\\":{\\\"title\\\":\\\"Remove Nth Node From End of List\\\",\\\"description\\\":\\\"Given the head of a linked list, remove the nth node from the end of the list and return its head.\\\",\\\"tags\\\":[\\\"medium\\\",\\\"linked-list\\\"],\\\"link\\\":\\\"https://leetcode.com/problems/remove-nth-node-from-end-of-list/\\\",\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nGiven the head of a linked list, remove the nth node from the end of the list and return its head.\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: head = [1,2,3,4,5], n = 2\\\\r\\\\nOutput: [1,2,3,5]\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: head = [1], n = 1\\\\r\\\\nOutput: []\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 3\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: head = [1,2], n = 1\\\\r\\\\nOutput: [1]\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n- The number of nodes in the list is sz. \\\\r\\\\n- 1 <= sz <= 30 \\\\r\\\\n- 0 <= Node.val <= 100 \\\\r\\\\n- 1 <= n <= sz\\\",\\\"basename\\\":\\\"remove-from-nth\\\"},\\\"reorder-list\\\":{\\\"title\\\":\\\"Reorder List\\\",\\\"description\\\":\\\"You are given the head of a singly linked-list. The list can be represented as\\\",\\\"tags\\\":[\\\"medium\\\",\\\"linked-list\\\"],\\\"link\\\":\\\"https://leetcode.com/problems/reorder-list/\\\",\\\"images\\\":[\\\"https://assets.leetcode.com/uploads/2021/03/04/reorder1linked-list.jpg\\\",\\\"https://assets.leetcode.com/uploads/2021/03/04/reorder2linked-list.jpg\\\"],\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nYou are given the head of a singly linked-list. The list can be represented as:\\\\r\\\\n\\\\r\\\\n`L0 â†’ L1 â†’ â€¦ â†’ Ln - 1 â†’ Ln`\\\\r\\\\nReorder the list to be on the following form:\\\\r\\\\n\\\\r\\\\n`L0 â†’ Ln â†’ L1 â†’ Ln - 1 â†’ L2 â†’ Ln - 2 â†’ â€¦`\\\\r\\\\nYou may not modify the values in the list's nodes. Only nodes themselves may be changed.\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n![](https://assets.leetcode.com/uploads/2021/03/04/reorder1linked-list.jpg)\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: head = [1,2,3,4]\\\\r\\\\nOutput: [1,4,2,3]\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n\\\\r\\\\n![](https://assets.leetcode.com/uploads/2021/03/04/reorder2linked-list.jpg)\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: head = [1,2,3,4,5]\\\\r\\\\nOutput: [1,5,2,4,3]\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n- The number of nodes in the list is in the range [1, 5 * 104]. \\\\r\\\\n- 1 <= Node.val <= 1000\\\",\\\"basename\\\":\\\"reorder-list\\\"},\\\"reverse-linked-list\\\":{\\\"title\\\":\\\"Reverse Linked List\\\",\\\"description\\\":\\\"Given the head of a singly linked list, reverse the list, and return the reversed list.\\\",\\\"tags\\\":[\\\"easy\\\",\\\"linked-list\\\"],\\\"link\\\":\\\"https://leetcode.com/problems/reverse-linked-list/\\\",\\\"images\\\":[\\\"https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg\\\",\\\"https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg\\\"],\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nGovem the `head` of a singly linked list, reverse the list, and return the reversed list.\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n![](https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg)\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: head = [1,2,3,4,5]\\\\r\\\\nOutput: [5,4,3,2,1]\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n\\\\r\\\\n![](https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg)\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: head = [1,2]\\\\r\\\\nOutput: [2,1]\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 3\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: head = []\\\\r\\\\nOutput: []\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n- The number of nodes in the list is the range [0, 5000].\\\\r\\\\n- -5000 <= Node.val <= 5000\\\",\\\"basename\\\":\\\"reverse-linked-list\\\"},\\\"reverse-nodes-in-k-group\\\":{\\\"title\\\":\\\"Reverse Nodes in k-Group\\\",\\\"description\\\":\\\"Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.\\\",\\\"tags\\\":[\\\"hard\\\",\\\"linked-list\\\"],\\\"link\\\":\\\"https://leetcode.com/problems/reverse-nodes-in-k-group/\\\",\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nGiven the `head` of a linked list, reverse the nodes of the list `k` at a time, and return the modified list.\\\\r\\\\n\\\\r\\\\n`k` is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of `k` then left-out nodes, in the end, should remain as it is.\\\\r\\\\n\\\\r\\\\nYou may not alter the values in the list's nodes, only nodes themselves may be changed.\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: head = [1,2,3,4,5], k = 2\\\\r\\\\nOutput: [2,1,4,3,5]\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: head = [1,2,3,4,5], k = 3\\\\r\\\\nOutput: [3,2,1,4,5]\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n- The number of nodes in the list is n. \\\\r\\\\n- 1 <= k <= n <= 5000 \\\\r\\\\n- 0 <= Node.val <= 1000\\\",\\\"basename\\\":\\\"reverse-nodes-in-k-group\\\"},\\\"rotting-oranges\\\":{\\\"title\\\":\\\"Rotting Oranges\\\",\\\"description\\\":\\\"Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1.\\\",\\\"tags\\\":[\\\"medium\\\",\\\"graphs\\\"],\\\"link\\\":\\\"https://leetcode.com/problems/rotting-oranges/\\\",\\\"images\\\":[\\\"https://assets.leetcode.com/uploads/2019/02/16/oranges.png\\\"],\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nYou are given an m x n grid where each cell can have one of three values:\\\\r\\\\n\\\\r\\\\n- 0 representing an empty cell,\\\\r\\\\n- 1 representing a fresh orange, or\\\\r\\\\n- 2 representing a rotten orange.\\\\r\\\\n\\\\r\\\\nEvery minute, any fresh orange that is **4-directionally** adjacent to a rotten orange becomes rotten.\\\\r\\\\n\\\\r\\\\nReturn the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1.\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n![](https://assets.leetcode.com/uploads/2019/02/16/oranges.png)\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: grid = [[2,1,1],[1,1,0],[0,1,1]]\\\\r\\\\nOutput: 4\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: grid = [[2,1,1],[0,1,1],[1,0,1]]\\\\r\\\\nOutput: -1\\\\r\\\\nExplanation: The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally.\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 3\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: grid = [[0,2]]\\\\r\\\\nOutput: 0\\\\r\\\\nExplanation: Since there are already no fresh oranges at minute 0, the answer is just 0.\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n- m == grid.length \\\\r\\\\n- n == grid[i].length\\\\r\\\\n- 1 <= m, n <= 10 \\\\r\\\\n- grid[i][j] is 0, 1, or 2.\\\",\\\"basename\\\":\\\"rotting-oranges\\\"},\\\"same-tree\\\":{\\\"title\\\":\\\"Same Tree\\\",\\\"description\\\":\\\"Given the roots of two binary trees p and q, write a function to check if they are the same or not.\\\",\\\"tags\\\":[\\\"easy\\\",\\\"binary-tree\\\"],\\\"link\\\":\\\"https://leetcode.com/problems/same-tree/\\\",\\\"images\\\":[\\\"https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg\\\",\\\"https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg\\\",\\\"https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg\\\"],\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nGiven the roots of two binary trees p and q, write a function to check if they are the same or not.\\\\r\\\\n\\\\r\\\\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n![](https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg)\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: p = [1,2,3], q = [1,2,3]\\\\r\\\\nOutput: true\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n\\\\r\\\\n![](https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg)\\\\r\\\\n\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: p = [1,2], q = [1,null,2]\\\\r\\\\nOutput: false\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 3\\\\r\\\\n\\\\r\\\\n![](https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg)\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: p = [1,2,1], q = [1,1,2]\\\\r\\\\nOutput: false\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n- The number of nodes in both trees is in the range [0, 100]. \\\\r\\\\n- -10^4 <= Node.val <= 10^4\\\",\\\"basename\\\":\\\"same-tree\\\"},\\\"sample\\\":{\\\"title\\\":\\\"Bellflower\\\",\\\"author\\\":\\\"guy\\\",\\\"date\\\":\\\"2012-07-23T00:00:00.000Z\\\",\\\"template\\\":\\\"article.jade\\\",\\\"tags\\\":[\\\"crab\\\",\\\"rose\\\",\\\"bells\\\"],\\\"preview\\\":\\\"## Interesting\\\\r\\\\n\\\\r\\\\nHow strange are those old recollections which haunt us without our being able to get rid of them! This one is so very old that I cannot understand how it has clung so vividly and tenaciously to my memory. Since then I have seen so many sinister things, either affecting or terrible, that I am astonished at not being able to pass a single day without the face of Mother Bellflower recurring to my mind's eye, just as I knew her formerly long, long ago, when I was ten or twelve years old. <span class=\\\\\\\"more\\\\\\\"></span>\\\\r\\\\n\\\\r\\\\nShe was an old seamstress who came to my parents' house once a week, every Thursday, to mend the linen. My parents lived in one of those country houses called chateaux, which are merely old houses with pointed roofs, to which are attached three or four adjacent farms.\\\\r\\\\n\\\\r\\\\nThe village, a large village, almost a small market town, was a few hundred yards off and nestled round the church, a red brick church, which had become black with age.\\\\r\\\\n\\\\r\\\\nWell, every Thursday Mother Bellflower came between half-past six and seven in the morning and went immediately into the linen room and began to work. She was a tall, thin, bearded or rather hairy woman, for she had a beard all over her face, a surprising, an unexpected beard, growing in improbable tufts, in curly bunches which looked as if they had been sown by a madman over that great face, the face of a gendarme in petticoats. She had them on her nose, under her nose, round her nose, on her chin, on her cheeks, and her eyebrows, which were extraordinarily thick and long and quite gray, bushy and bristling, looked exactly like a pair of mustaches stuck on there by mistake.\\\\r\\\\n\\\\r\\\\nShe limped, not like lame people generally do, but like a ship pitching. When she planted her great bony, vibrant body on her sound leg, she seemed to be preparing to mount some enormous wave, and then suddenly she dipped as if to disappear in an abyss and buried herself in the ground. Her walk reminded one of a ship in a storm, and her head, which was always covered with an enormous white cap, whose ribbons fluttered down her back, seemed to traverse the horizon from north to south and from south to north at each limp.\\\\r\\\\n\\\\r\\\\nI adored Mother Bellflower. As soon as I was up I used to go into the linen room, where I found her installed at work with a foot warmer under her feet. As soon as I arrived she made me take the foot warmer and sit upon it, so that I might not catch cold in that large chilly room under the roof.\\\\r\\\\n\\\\r\\\\n\\\\\\\"That draws the blood from your head,\\\\\\\" she would say to me.\\\\r\\\\n\\\\r\\\\nShe told me stories while mending the linen with her long, crooked, nimble fingers; behind her magnifying spectacles, for age had impaired her sight, her eyes appeared enormous to me, strangely profound, double.\\\\r\\\\n\\\\r\\\\nAs far as I can remember from the things which she told me and by which my childish heart was moved, she had the large heart of a poor woman. She told me what had happened in the village, how a cow had escaped from the cow house and had been found the next morning in front of Prosper Malet's mill looking at the sails turning, or about a hen's egg which had been found in the church belfry without anyone being able to understand what creature had been there to lay it, or the queer story of Jean Pila's dog who had gone ten leagues to bring back his master's breeches which a tramp had stolen while they were hanging up to dry out of doors after he had been caught in the rain. She told me these simple adventures in such a manner that in my mind they assumed the proportions of never-to-be-forgotten dramas, of grand and mysterious poems; and the ingenious stories invented by the poets, which my mother told me in the evening, had none of the flavor, none of the fullness or of the vigor of the peasant woman's narratives.\\\\r\\\\n\\\\r\\\\nWell, one Thursday when I had spent all the morning in listening to Mother Clochette, I wanted to go upstairs to her again during the day after picking hazelnuts with the manservant in the wood behind the farm. I remember it all as clearly as what happened only yesterday.\\\\r\\\\n\\\\r\\\\nOn opening the door of the linen room I saw the old seamstress lying on the floor by the side of her chair, her face turned down and her arms stretched out, but still holding her needle in one hand and one of my shirts in the other. One of her legs in a blue stocking, the longer one no doubt, was extended under her chair, and her spectacles glistened by the wall, where they had rolled away from her.\\\\r\\\\n\\\\r\\\\nI ran away uttering shrill cries. They all came running, and in a few minutes I was told that Mother Clochette was dead.\\\\r\\\\n\\\\r\\\\nI cannot describe the profound, poignant, terrible emotion which stirred my childish heart. I went slowly down into the drawing room and hid myself in a dark corner in the depths of a great old armchair, where I knelt and wept. I remained there for a long time, no doubt, for night came on. Suddenly someone came in with a lamp--without seeing me, however--and heard my father and mother talking with the medical man, whose voice recognized.\\\\r\\\\n\\\\r\\\\nHe had been sent for immediately, and he was explaining the cause of the accident, of which I understood nothing, however. Then he sat down and had a glass of liqueur and a biscuit.\\\\r\\\\n\\\\r\\\\nHe went on talking, and what he then said will remain engraved on my mind until I die. I think that I can give the exact words which he used.\\\\r\\\\n\\\\r\\\\n\\\\\\\"Ah!\\\\\\\" he said. \\\\\\\"The poor woman! she broke her leg the day of my arrival here. I had not even had time to wash my hands after getting off the diligence before I was sent for in all haste, for it was a bad case, very bad.\\\\r\\\\n\\\\r\\\\n\\\\\\\"She was seventeen and a pretty girl, very pretty! Would anyone believe it? I have never told her story before; in fact, no one but myself and one other person, who is no longer living in this part of the country, ever knew it. Now that she is dead I may be less discreet.\\\\r\\\\n\\\\r\\\\n\\\\\\\"A young assistant teacher had just come to live in the village; he was good looking and had the bearing of a soldier. All the girls ran after him, but he was disdainful. Besides that, he was very much afraid of his superior, the schoolmaster, old Grabu, who occasionally got out of bed the wrong foot first.\\\\r\\\\n\\\\r\\\\n\\\\\\\"Old Grabu already employed pretty Hortense, who has just died here and who was afterward nicknamed Clochette. The assistant master singled out the pretty young girl who was no doubt flattered at being chosen by this disdainful conqueror; at any rate, she fell in love with him, and he succeeded in persuading her to give him a first meeting in the hayloft behind the school at night after she had done her day's sewing.\\\\r\\\\n\\\\r\\\\n\\\\\\\"She pretended to go home, but instead of going downstairs when she left the Grabus', she went upstairs and hid among the hay to wait for her lover. He soon joined her, and he was beginning to say pretty things to her, when the door of the hayloft opened and the schoolmaster appeared and asked: 'What are you doing up there, Sigisbert?' Feeling sure that he would be caught, the young schoolmaster lost his presence of mind and replied stupidly: 'I came up here to rest a little among the bundles of hay, Monsieur Grabu.'\\\\r\\\\n\\\\r\\\\n\\\\\\\"The loft was very large and absolutely dark. Sigisbert pushed the frightened girl to the farther end and said: 'Go, there and hide yourself. I shall lose my situation, so get away and hide yourself.'\\\\r\\\\n\\\\r\\\\n\\\\\\\"When the schoolmaster heard the whispering he continued: 'Why, you are not by yourself.'\\\\r\\\\n\\\\r\\\\n\\\\\\\"'Yes, I am, Monsieur Grabu!'\\\\r\\\\n\\\\r\\\\n\\\\\\\"'But you are not, for you are talking.'\\\\r\\\\n\\\\r\\\\n\\\\\\\"'I swear I am, Monsieur Grabu.'\\\\r\\\\n\\\\r\\\\n\\\\\\\"'I will soon find out,' the old man replied and, double-locking the door, he went down to get a light.\\\\r\\\\n\\\\r\\\\n\\\\\\\"Then the young man, who was a coward such as one sometimes meets, lost his head, and he repeated, having grown furious all of a sudden: 'Hide yourself, so that he may not find you. You will deprive me of my bread for my whole life; you will ruin my whole career! Do hide yourself!'\\\\r\\\\n\\\\r\\\\n\\\\\\\"They could hear the key turning in the lock again, and Hortense ran to the window which looked out onto the street, opened it quickly and then in a low and determined voice said: 'You will come and pick me up when he is gone,' and she jumped out.\\\\r\\\\n\\\\r\\\\n\\\\\\\"Old Grabu found nobody and went down again in great surprise! A quarter of an hour later Monsieur Sigisbert came to me and related his adventure. The girl had remained at the foot of the wall, unable to get up, as she had fallen from the second story, and I went with him to fetch her. It was raining in torrents, and I brought the unfortunate girl home with me, for the right leg was broken in three places, and the bones had come out through the flesh. She did not complain and merely said with admirable resignation: 'I am punished, well punished!'\\\\r\\\\n\\\\r\\\\n\\\\\\\"I sent for assistance and for the workgirl's friends and told them a made-up story of a runaway carriage which had knocked her down and lamed her outside my door. They believed me, and the gendarmes for a whole month tried in vain to find the author of this accident.\\\\r\\\\n\\\\r\\\\n\\\\\\\"That is all! Now I say that this woman was a heroine and had the fiber of those who accomplish the grandest deeds in history.\\\\r\\\\n\\\\r\\\\n\\\\\\\"That was her only love affair, and she died a virgin. She was a martyr, a noble soul, a sublimely devoted woman! And if I did not absolutely admire her I should not have told you this story, which I would never tell anyone during her life; you understand why.\\\\\\\"\\\\r\\\\n\\\\r\\\\nThe doctor ceased; Mamma cried, and Papa said some words which I did not catch; then they left the room, and I remained on my knees in the armchair and sobbed, while I heard a strange noise of heavy footsteps and something knocking against the side of the staircase.\\\\r\\\\n\\\\r\\\\nThey were carrying away Clochette's body.\\\",\\\"iso8601Date\\\":\\\"2012-07-22T20:00:00-04:00\\\",\\\"basename\\\":\\\"sample\\\"},\\\"search-matrix\\\":{\\\"title\\\":\\\"Search a 2D Matrix\\\",\\\"description\\\":\\\"You are given an m x n integer matrix matrix with the following two properties\\\",\\\"tags\\\":[\\\"medium\\\",\\\"binary-search\\\"],\\\"link\\\":\\\"https://leetcode.com/problems/search-a-2d-matrix/\\\",\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nYou are given an `m x n` integer matrix `matrix` with the following two properties:\\\\r\\\\n\\\\r\\\\n    Each row is sorted in non-decreasing order.\\\\r\\\\n    The first integer of each row is greater than the last integer of the previous row.\\\\r\\\\n\\\\r\\\\nGiven an integer target, return `true` if `target` is in `matrix` or `false` otherwise.\\\\r\\\\n\\\\r\\\\nYou must write a solution in `O(log(m * n))` time complexity.\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n![figure1](https://assets.leetcode.com/uploads/2020/10/05/mat.jpg)\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\\\\r\\\\nOutput: true\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n\\\\r\\\\n![figure2](https://assets.leetcode.com/uploads/2020/10/05/mat2.jpg)\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13\\\\r\\\\nOutput: false\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n- m == matrix.length\\\\r\\\\n- n == matrix[i].length\\\\r\\\\n- 1 <= m, n <= 100\\\\r\\\\n- -104 <= matrix[i][j], target <= 104\\\",\\\"basename\\\":\\\"search-matrix\\\"},\\\"search-rotated-array\\\":{\\\"title\\\":\\\"Search in Rotated Sorted Array\\\",\\\"description\\\":\\\"Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.\\\",\\\"tags\\\":[\\\"medium\\\",\\\"binary-search\\\"],\\\"link\\\":\\\"https://leetcode.com/problems/search-in-rotated-sorted-array/\\\",\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nThere is an integer array `nums` sorted in ascending order (with **distinct** values).\\\\r\\\\n\\\\r\\\\nPrior to being passed to your function, nums is **possibly rotated** at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].\\\\r\\\\n\\\\r\\\\nGiven the array `nums` **after** the possible rotation and an integer target, return the index of `target` if it is in `nums`, or `-1` if it is not in `nums`.\\\\r\\\\n\\\\r\\\\nYou must write an algorithm with O(log n) runtime complexity.\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: nums = [4,5,6,7,0,1,2], target = 0\\\\r\\\\nOutput: 4\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: nums = [4,5,6,7,0,1,2], target = 3\\\\r\\\\nOutput: -1\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n\\\\r\\\\n### Example 3\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: nums = [1], target = 0\\\\r\\\\nOutput: -1\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n-      1 <= nums.length <= 5000     \\\\r\\\\n-      -104 <= nums[i] <= 104     \\\\r\\\\n-      All values of nums are unique.     \\\\r\\\\n-      nums is an ascending array that is possibly rotated.     \\\\r\\\\n-      -104 <= target <= 104\\\",\\\"basename\\\":\\\"search-rotated-array\\\"},\\\"serialize-and-deserialize-binary-tree\\\":{\\\"title\\\":\\\"Serialize and Deserialize Binary Tree\\\",\\\"description\\\":\\\"Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\\\",\\\"tags\\\":[\\\"hard\\\",\\\"binary-tree\\\"],\\\"link\\\":\\\"https://leetcode.com/problems/serialize-and-deserialize-binary-tree/\\\",\\\"images\\\":[\\\"https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg\\\"],\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nSerialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\\\\r\\\\n\\\\r\\\\nDesign an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.\\\\r\\\\n\\\\r\\\\n**Clarification**: The input/output format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n![](https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg)\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: root = [1,2,3,null,null,4,5]\\\\r\\\\nOutput: [1,2,3,null,null,4,5]\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: root = []\\\\r\\\\nOutput: []\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n- The number of nodes in the tree is in the range [0, 10^4]. \\\\r\\\\n- -1000 <= Node.val <= 1000\\\",\\\"basename\\\":\\\"serialize-and-deserialize-binary-tree\\\"},\\\"simple-division\\\":{\\\"title\\\":\\\"Simple Division\\\",\\\"description\\\":\\\"A simple division example\\\",\\\"tags\\\":[\\\"sample\\\",\\\"math\\\"],\\\"preview\\\":\\\"This is  a simple division example.\\\\r\\\\n\\\\r\\\\n```js\\\\r\\\\nimport { prompt } from 'dsa-cli';\\\\r\\\\nconst a = prompt('Enter a number: ');\\\\r\\\\nconst b = prompt('Enter another number: ');\\\\r\\\\nconsole.log(a / b);\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\n$ dsa run simple-division.js\\\\r\\\\nEnter a number: 10\\\\r\\\\n```\\\",\\\"basename\\\":\\\"simple-division\\\"},\\\"simple-substraction\\\":{\\\"title\\\":\\\"Simple Substraction\\\",\\\"description\\\":\\\"A simple substraction example\\\",\\\"tags\\\":[\\\"sample\\\",\\\"math\\\"],\\\"preview\\\":\\\"This is  a simple substraction example.!\\\\r\\\\n\\\\r\\\\n```js\\\\r\\\\nimport { prompt } from 'dsa-cli';\\\\r\\\\nconst a = prompt('Enter a number: ');\\\\r\\\\nconst b = prompt('Enter another number: ');\\\\r\\\\nconsole.log(a - b);\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\n$ dsa run simple-substraction.js\\\\r\\\\nEnter a number: 11\\\\r\\\\nEnter another number: 5\\\\r\\\\n```\\\",\\\"basename\\\":\\\"simple-substraction\\\"},\\\"simple-sum\\\":{\\\"title\\\":\\\"Simple Sum\\\",\\\"description\\\":\\\"A simple sum example!\\\",\\\"tags\\\":[\\\"sample\\\",\\\"math\\\"],\\\"preview\\\":\\\"This is  a simple sum example.\\\\r\\\\n\\\\r\\\\n```js\\\\r\\\\nimport { prompt } from 'dsa-cli';\\\\r\\\\nconst a = prompt('Enter a number: ');\\\\r\\\\nconst b = prompt('Enter another number: ');\\\\r\\\\nconsole.log(a + b);\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\n$ dsa run simple-sum.js\\\\r\\\\nEnter a number: 10\\\\r\\\\nEnter another number:\\\\r\\\\n```\\\",\\\"basename\\\":\\\"simple-sum\\\"},\\\"subsets-ii\\\":{\\\"title\\\":\\\"Subsets II\\\",\\\"description\\\":\\\"Given an integer array nums that may contain duplicates, return all possible subsets (the power set).\\\",\\\"tags\\\":[\\\"medium\\\",\\\"backtracking\\\"],\\\"link\\\":\\\"https://leetcode.com/problems/subsets-ii/\\\",\\\"images\\\":[],\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nGiven an integer array `nums` that may contain duplicates, return all possible subsets (the power set).\\\\r\\\\n\\\\r\\\\nThe solution set **must not** contain duplicate subsets. Return the solution in **any order**.\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: nums = [1,2,2]\\\\r\\\\nOutput: [[],[1],[1,2],[1,2,2],[2],[2,2]]\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: nums = [0]\\\\r\\\\nOutput: [[],[0]]\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n- 1 <= nums.length <= 10\\\\r\\\\n- -10 <= nums[i] <= 10\\\",\\\"basename\\\":\\\"subsets-ii\\\"},\\\"subsets\\\":{\\\"preview\\\":\\\"\\\",\\\"basename\\\":\\\"subsets\\\"},\\\"subtree-of-another-tree\\\":{\\\"title\\\":\\\"Subtree of Another Tree\\\",\\\"description\\\":\\\"A subtree of a binary tree tree is a tree that consists of a node in tree and all of this node's descendants. The tree tree could also be considered as a subtree of itself.\\\",\\\"tags\\\":[\\\"easy\\\",\\\"binary-tree\\\"],\\\"link\\\":\\\"https://leetcode.com/problems/subtree-of-another-tree/\\\",\\\"images\\\":[\\\"https://assets.leetcode.com/uploads/2021/02/18/tree1.jpg\\\",\\\"https://assets.leetcode.com/uploads/2021/02/18/tree2.jpg\\\"],\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nGiven the roots of two binary trees `root` and `subRoot`, return true if there is a subtree of root with the same structure and node values of `subRoot` and `false` otherwise.\\\\r\\\\n\\\\r\\\\nA subtree of a binary tree `tree` is a tree that consists of a node in tree and all of this node's descendants. The tree `tree` could also be considered as a subtree of itself.\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n![](https://assets.leetcode.com/uploads/2021/02/18/tree1.jpg)\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: root = [3,4,5,1,2], subRoot = [4,1,2]\\\\r\\\\nOutput: true\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n\\\\r\\\\n![](https://assets.leetcode.com/uploads/2021/02/18/tree2.jpg)\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]\\\\r\\\\nOutput: false\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n- The number of nodes in the root tree is in the range [1, 2000]. \\\\r\\\\n- The number of nodes in the subRoot tree is in the range [1, 1000]. \\\\r\\\\n- -10^4 <= root.val <= 10^4 \\\\r\\\\n- -10^4 <= subRoot.val <= 10^4\\\",\\\"basename\\\":\\\"subtree-of-another-tree\\\"},\\\"surrounded-regions\\\":{\\\"title\\\":\\\"Surrounded Regions\\\",\\\"description\\\":\\\"Given an m x n matrix board containing 'X' and 'O', capture all regions that are 4-directionally surrounded by 'X'.\\\",\\\"tags\\\":[\\\"medium\\\",\\\"graphs\\\"],\\\"link\\\":\\\"https://leetcode.com/problems/surrounded-regions/\\\",\\\"images\\\":[\\\"https://assets.leetcode.com/uploads/2021/02/19/xogrid.jpg\\\"],\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nGiven an `m x n` matrix board containing 'X' and 'O', capture all regions that are 4-directionally surrounded by 'X'.\\\\r\\\\n\\\\r\\\\nA region is **captured** by flipping all 'O's into 'X's in that surrounded region.\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n![](https://assets.leetcode.com/uploads/2021/02/19/xogrid.jpg)\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: board = [[\\\\\\\"X\\\\\\\",\\\\\\\"X\\\\\\\",\\\\\\\"X\\\\\\\",\\\\\\\"X\\\\\\\"],[\\\\\\\"X\\\\\\\",\\\\\\\"O\\\\\\\",\\\\\\\"O\\\\\\\",\\\\\\\"X\\\\\\\"],[\\\\\\\"X\\\\\\\",\\\\\\\"X\\\\\\\",\\\\\\\"O\\\\\\\",\\\\\\\"X\\\\\\\"],[\\\\\\\"X\\\\\\\",\\\\\\\"O\\\\\\\",\\\\\\\"X\\\\\\\",\\\\\\\"X\\\\\\\"]]\\\\r\\\\nOutput: [[\\\\\\\"X\\\\\\\",\\\\\\\"X\\\\\\\",\\\\\\\"X\\\\\\\",\\\\\\\"X\\\\\\\"],[\\\\\\\"X\\\\\\\",\\\\\\\"X\\\\\\\",\\\\\\\"X\\\\\\\",\\\\\\\"X\\\\\\\"],[\\\\\\\"X\\\\\\\",\\\\\\\"X\\\\\\\",\\\\\\\"X\\\\\\\",\\\\\\\"X\\\\\\\"],[\\\\\\\"X\\\\\\\",\\\\\\\"O\\\\\\\",\\\\\\\"X\\\\\\\",\\\\\\\"X\\\\\\\"]]\\\\r\\\\nExplanation: Notice that an 'O' should not be flipped if:\\\\r\\\\n- It is on the border, or\\\\r\\\\n- It is adjacent to an 'O' that should not be flipped.\\\\r\\\\nThe bottom 'O' is on the border, so it is not flipped.\\\\r\\\\nThe other three 'O' form a surrounded region, so they are flipped.\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: board = [[\\\\\\\"X\\\\\\\"]]\\\\r\\\\nOutput: [[\\\\\\\"X\\\\\\\"]]\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n- m == board.length\\\\r\\\\n- n == board[i].length\\\\r\\\\n- 1 <= m, n <= 200\\\\r\\\\n- board[i][j] is 'X' or 'O'\\\",\\\"basename\\\":\\\"surrounded-regions\\\"},\\\"task-scheduler\\\":{\\\"title\\\":\\\"Task Scheduler\\\",\\\"description\\\":\\\"Return the least number of units of times that the CPU will take to finish all the given tasks.\\\",\\\"tags\\\":[\\\"medium\\\",\\\"heap\\\"],\\\"link\\\":\\\"https://leetcode.com/problems/task-scheduler/\\\",\\\"images\\\":[],\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nGiven a characters array tasks, representing the tasks a CPU needs to do, where each letter represents a different task. Tasks could be done in any order. Each task is done in one unit of time. For each unit of time, the CPU could complete either one task or just be idle.\\\\r\\\\n\\\\r\\\\nHowever, there is a non-negative integer n that represents the cooldown period between two **same tasks** (the same letter in the array), that is that there must be at least n units of time between any two same tasks.\\\\r\\\\n\\\\r\\\\nReturn the least number of units of times that the CPU will take to finish all the given tasks.\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: tasks = [\\\\\\\"A\\\\\\\",\\\\\\\"A\\\\\\\",\\\\\\\"A\\\\\\\",\\\\\\\"B\\\\\\\",\\\\\\\"B\\\\\\\",\\\\\\\"B\\\\\\\"], n = 2\\\\r\\\\nOutput: 8\\\\r\\\\nExplanation: \\\\r\\\\nA -> B -> idle -> A -> B -> idle -> A -> B\\\\r\\\\nThere is at least 2 units of time between any two same tasks.\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: tasks = [\\\\\\\"A\\\\\\\",\\\\\\\"A\\\\\\\",\\\\\\\"A\\\\\\\",\\\\\\\"B\\\\\\\",\\\\\\\"B\\\\\\\",\\\\\\\"B\\\\\\\"], n = 0\\\\r\\\\nOutput: 6\\\\r\\\\nExplanation: On this case any permutation of size 6 would work since n = 0.\\\\r\\\\n[\\\\\\\"A\\\\\\\",\\\\\\\"A\\\\\\\",\\\\\\\"A\\\\\\\",\\\\\\\"B\\\\\\\",\\\\\\\"B\\\\\\\",\\\\\\\"B\\\\\\\"]\\\\r\\\\n[\\\\\\\"A\\\\\\\",\\\\\\\"B\\\\\\\",\\\\\\\"A\\\\\\\",\\\\\\\"B\\\\\\\",\\\\\\\"A\\\\\\\",\\\\\\\"B\\\\\\\"]\\\\r\\\\n[\\\\\\\"B\\\\\\\",\\\\\\\"B\\\\\\\",\\\\\\\"B\\\\\\\",\\\\\\\"A\\\\\\\",\\\\\\\"A\\\\\\\",\\\\\\\"A\\\\\\\"]\\\\r\\\\n...\\\\r\\\\nAnd so on.\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 3\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: tasks = [\\\\\\\"A\\\\\\\",\\\\\\\"A\\\\\\\",\\\\\\\"A\\\\\\\",\\\\\\\"A\\\\\\\",\\\\\\\"A\\\\\\\",\\\\\\\"A\\\\\\\",\\\\\\\"B\\\\\\\",\\\\\\\"C\\\\\\\",\\\\\\\"D\\\\\\\",\\\\\\\"E\\\\\\\",\\\\\\\"F\\\\\\\",\\\\\\\"G\\\\\\\"], n = 2\\\\r\\\\nOutput: 16\\\\r\\\\nExplanation: \\\\r\\\\nOne possible solution is\\\\r\\\\nA -> B -> C -> A -> D -> E -> A -> F -> G -> A -> idle -> idle -> A -> idle -> idle -> A\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n- 1 <= task.length <= 10^4 \\\\r\\\\n- tasks[i] is upper-case English letter. \\\\r\\\\n- The integer n is in the range [0, 100].\\\",\\\"basename\\\":\\\"task-scheduler\\\"},\\\"three-number-sum\\\":{\\\"title\\\":\\\"Three Number Sum\\\",\\\"description\\\":\\\"A three number sum example\\\",\\\"tags\\\":[\\\"arrays\\\",\\\"math\\\"],\\\"preview\\\":\\\"## Three Number Sum\\\\r\\\\n\\\\r\\\\nGiven an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\\\\r\\\\n\\\\r\\\\nNotice that the solution set must not contain duplicate triplets.\\\\r\\\\n\\\\r\\\\n \\\\r\\\\n\\\\r\\\\nExample 1:\\\\r\\\\n```\\\\r\\\\nInput: nums = [-1,0,1,2,-1,-4]\\\\r\\\\nOutput: [[-1,-1,2],[-1,0,1]]\\\\r\\\\nExplanation: \\\\r\\\\nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\\\\r\\\\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\\\\r\\\\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\\\\r\\\\nThe distinct triplets are [-1,0,1] and [-1,-1,2].\\\\r\\\\nNotice that the order of the output and the order of the triplets does not matter.\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\nExample 2:\\\\r\\\\n\\\\r\\\\n```\\\\r\\\\nInput: nums = [0,1,1]\\\\r\\\\nOutput: []\\\\r\\\\nExplanation: The only possible triplet does not sum up to 0.\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\nExample 3:\\\\r\\\\n\\\\r\\\\n```\\\\r\\\\nInput: nums = [0,0,0]\\\\r\\\\nOutput: [[0,0,0]]\\\\r\\\\nExplanation: The only possible triplet sums up to 0.\\\\r\\\\n```\\\",\\\"basename\\\":\\\"three-number-sum\\\"},\\\"trapping-rain-water\\\":{\\\"title\\\":\\\"Trapping Rain Water\\\",\\\"description\\\":\\\"A trapping rain water example\\\",\\\"tags\\\":[\\\"hard\\\",\\\"two-pointers\\\"],\\\"preview\\\":\\\"Given `n` non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\\\\r\\\\n\\\\r\\\\nExample 1\\\\r\\\\n\\\\r\\\\n```\\\\r\\\\nInput: height = [0,1,0,2,1,0,1,3,2,1,2,1]\\\\r\\\\nOutput: 6\\\\r\\\\nExplanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\nExample 2\\\\r\\\\n\\\\r\\\\n```\\\\r\\\\nInput: height = [4,2,0,3,2,5]\\\\r\\\\nOutput: 9\\\\r\\\\n```\\\",\\\"basename\\\":\\\"trapping-rain-water\\\"},\\\"valid-parentheses\\\":{\\\"title\\\":\\\"Valid Parentheses\\\",\\\"description\\\":\\\"Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\\\",\\\"tags\\\":[\\\"easy\\\",\\\"stack\\\"],\\\"link\\\":\\\"https://leetcode.com/problems/valid-parentheses/\\\",\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nGiven a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\\\\r\\\\n\\\\r\\\\nAn input string is valid if:\\\\r\\\\n\\\\r\\\\nOpen brackets must be closed by the same type of brackets.\\\\r\\\\nOpen brackets must be closed in the correct order.\\\\r\\\\nEvery close bracket has a corresponding open bracket of the same type.\\\\r\\\\n\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n```bash\\\\r\\\\nInput: s = \\\\\\\"()\\\\\\\"\\\\r\\\\nOutput: true\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n```bash\\\\r\\\\nInput: s = \\\\\\\"()[]{}\\\\\\\"\\\\r\\\\nOutput: true\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 3\\\\r\\\\n```bash\\\\r\\\\nInput: s = \\\\\\\"(]\\\\\\\"\\\\r\\\\nOutput: false\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n-      1 <= s.length <= 104     \\\\r\\\\n-      s consists of parentheses only '()[]{}'.\\\",\\\"basename\\\":\\\"valid-parentheses\\\"},\\\"validate-binary-search-tree\\\":{\\\"title\\\":\\\"Validate Binary Search Tree\\\",\\\"description\\\":\\\"Given the root of a binary tree, determine if it is a valid binary search tree (BST).\\\",\\\"tags\\\":[\\\"medium\\\",\\\"binary-tree\\\"],\\\"link\\\":\\\"https://leetcode.com/problems/validate-binary-search-tree/\\\",\\\"images\\\":[\\\"https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg\\\",\\\"https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg\\\"],\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nGiven the root of a binary tree, determine if it is a valid binary search tree (BST).\\\\r\\\\n\\\\r\\\\nA valid BST is defined as follows:\\\\r\\\\n\\\\r\\\\n- The left subtree of a node contains only nodes with keys less than the node's key.\\\\r\\\\n- The right subtree of a node contains only nodes with keys greater than the node's key.\\\\r\\\\n- Both the left and right subtrees must also be binary search trees.\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n![](https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg)\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: root = [2,1,3]\\\\r\\\\nOutput: true\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n\\\\r\\\\n![](https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg)\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: root = [5,1,4,null,null,3,6]\\\\r\\\\nOutput: false\\\\r\\\\nExplanation: The root node's value is 5 but its right child's value is 4.\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n- The number of nodes in the tree is in the range [1, 104].\\\\r\\\\n- -2^31 <= Node.val <= 2^31 - 1\\\",\\\"basename\\\":\\\"validate-binary-search-tree\\\"},\\\"walls-and-gates\\\":{\\\"title\\\":\\\"Walls and Gates\\\",\\\"description\\\":\\\"Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should be filled with INF.\\\",\\\"tags\\\":[\\\"medium\\\",\\\"graphs\\\"],\\\"link\\\":\\\"https://tenderleo.gitbooks.io/leetcode-solutions-/content/GoogleMedium/286.html\\\",\\\"images\\\":[],\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nYou are given a m x n 2D grid initialized with these three possible values.\\\\r\\\\n\\\\r\\\\n-1 - A wall or an obstacle. 0 - A gate. INF - Infinity means an empty room. We use the value 231 - 1 = 2147483647 to represent INF as you may assume that the distance to a gate is less than 2147483647. Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should be filled with INF.\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nINF  -1  0  INF\\\\r\\\\nINF INF INF  -1\\\\r\\\\nINF  -1 INF  -1\\\\r\\\\n  0  -1 INF INF\\\\r\\\\n```\\\\r\\\\nAfter running the function, the 2D grid should be:\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\n  3  -1   0   1\\\\r\\\\n  2   2   1  -1\\\\r\\\\n  1  -1   2  -1\\\\r\\\\n  0  -1   3   4\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n- m == rooms.length\\\\r\\\\n- n == rooms[i].length\\\",\\\"basename\\\":\\\"walls-and-gates\\\"},\\\"word-ladder\\\":{\\\"title\\\":\\\"Word Ladder\\\",\\\"description\\\":\\\"Given two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.\\\",\\\"tags\\\":[\\\"hard\\\",\\\"graphs\\\"],\\\"link\\\":\\\"https://leetcode.com/problems/word-ladder/\\\",\\\"images\\\":[],\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nA transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\\\\r\\\\n\\\\r\\\\n- Every adjacent pair of words differs by a single letter.\\\\r\\\\n- Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList.\\\\r\\\\n- sk == endWord\\\\r\\\\n\\\\r\\\\n\\\\r\\\\nGiven two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.\\\\r\\\\n\\\\r\\\\n \\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: beginWord = \\\\\\\"hit\\\\\\\", endWord = \\\\\\\"cog\\\\\\\", wordList = [\\\\\\\"hot\\\\\\\",\\\\\\\"dot\\\\\\\",\\\\\\\"dog\\\\\\\",\\\\\\\"lot\\\\\\\",\\\\\\\"log\\\\\\\",\\\\\\\"cog\\\\\\\"]\\\\r\\\\nOutput: 5\\\\r\\\\nExplanation: One shortest transformation sequence is \\\\\\\"hit\\\\\\\" -> \\\\\\\"hot\\\\\\\" -> \\\\\\\"dot\\\\\\\" -> \\\\\\\"dog\\\\\\\" -> cog\\\\\\\", which is 5 words long.\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: beginWord = \\\\\\\"hit\\\\\\\", endWord = \\\\\\\"cog\\\\\\\", wordList = [\\\\\\\"hot\\\\\\\",\\\\\\\"dot\\\\\\\",\\\\\\\"dog\\\\\\\",\\\\\\\"lot\\\\\\\",\\\\\\\"log\\\\\\\"]\\\\r\\\\nOutput: 0\\\\r\\\\nExplanation: The endWord \\\\\\\"cog\\\\\\\" is not in wordList, therefore there is no valid transformation sequence.\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n- 1 <= beginWord.length <= 10\\\\r\\\\n- endWord.length == beginWord.length\\\\r\\\\n- 1 <= wordList.length <= 5000\\\\r\\\\n- wordList[i].length == beginWord.length\\\\r\\\\n- beginWord, endWord, and wordList[i] consist of lowercase English letters.\\\\r\\\\n- beginWord != endWord\\\\r\\\\n- All the words in wordList are unique.\\\",\\\"basename\\\":\\\"word-ladder\\\"},\\\"word-search-ii\\\":{\\\"title\\\":\\\"Word Search II\\\",\\\"description\\\":\\\"Given an m x n board of characters and a list of strings words, return all words on the board.\\\",\\\"tags\\\":[\\\"hard\\\",\\\"trie\\\"],\\\"link\\\":\\\"https://leetcode.com/problems/word-search-ii/\\\",\\\"images\\\":[],\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nGiven an m x n board of characters and a list of strings words, return all words on the board.\\\\r\\\\n\\\\r\\\\nEach word must be constructed from letters of sequentially adjacent cells, where **adjacent cells** are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n![](https://assets.leetcode.com/uploads/2020/11/07/search1.jpg)\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: board = [[\\\\\\\"o\\\\\\\",\\\\\\\"a\\\\\\\",\\\\\\\"a\\\\\\\",\\\\\\\"n\\\\\\\"],[\\\\\\\"e\\\\\\\",\\\\\\\"t\\\\\\\",\\\\\\\"a\\\\\\\",\\\\\\\"e\\\\\\\"],[\\\\\\\"i\\\\\\\",\\\\\\\"h\\\\\\\",\\\\\\\"k\\\\\\\",\\\\\\\"r\\\\\\\"],[\\\\\\\"i\\\\\\\",\\\\\\\"f\\\\\\\",\\\\\\\"l\\\\\\\",\\\\\\\"v\\\\\\\"]], words = [\\\\\\\"oath\\\\\\\",\\\\\\\"pea\\\\\\\",\\\\\\\"eat\\\\\\\",\\\\\\\"rain\\\\\\\"]\\\\r\\\\nOutput: [\\\\\\\"eat\\\\\\\",\\\\\\\"oath\\\\\\\"]\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n\\\\r\\\\n![](https://assets.leetcode.com/uploads/2020/11/07/search2.jpg)\\\\r\\\\n\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: board = [[\\\\\\\"a\\\\\\\",\\\\\\\"b\\\\\\\"],[\\\\\\\"c\\\\\\\",\\\\\\\"d\\\\\\\"]], words = [\\\\\\\"abcb\\\\\\\"]\\\\r\\\\nOutput: []\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n- m == board.length\\\\r\\\\n- n == board[i].length\\\\r\\\\n- 1 <= m, n <= 12\\\\r\\\\n- board[i][j] is a lowercase English letter.\\\\r\\\\n- 1 <= words.length <= 3 * 10^4\\\\r\\\\n- 1 <= words[i].length <= 10\\\\r\\\\n- words[i] consists of lowercase English letters.\\\\r\\\\n- All the strings of `words` are unique.\\\",\\\"basename\\\":\\\"word-search-ii\\\"},\\\"word-search\\\":{\\\"title\\\":\\\"Word Search\\\",\\\"description\\\":\\\"Given an m x n grid of characters board and a string word, return true if word exists in the grid.\\\",\\\"tags\\\":[],\\\"link\\\":\\\"https://leetcode.com/problems/word-search/\\\",\\\"images\\\":[],\\\"preview\\\":\\\"### Description\\\\r\\\\n\\\\r\\\\nGiven an `m x n` grid of characters `board` and a string `word`, return `true` if word exists in the grid.\\\\r\\\\nThe word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.\\\\r\\\\n\\\\r\\\\n### Example 1\\\\r\\\\n\\\\r\\\\n![](https://assets.leetcode.com/uploads/2020/11/04/word2.jpg)\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: board = [[\\\\\\\"A\\\\\\\",\\\\\\\"B\\\\\\\",\\\\\\\"C\\\\\\\",\\\\\\\"E\\\\\\\"],[\\\\\\\"S\\\\\\\",\\\\\\\"F\\\\\\\",\\\\\\\"C\\\\\\\",\\\\\\\"S\\\\\\\"],[\\\\\\\"A\\\\\\\",\\\\\\\"D\\\\\\\",\\\\\\\"E\\\\\\\",\\\\\\\"E\\\\\\\"]], word = \\\\\\\"ABCCED\\\\\\\"\\\\r\\\\nOutput: true\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 2\\\\r\\\\n\\\\r\\\\n![](https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg)\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: board = [[\\\\\\\"A\\\\\\\",\\\\\\\"B\\\\\\\",\\\\\\\"C\\\\\\\",\\\\\\\"E\\\\\\\"],[\\\\\\\"S\\\\\\\",\\\\\\\"F\\\\\\\",\\\\\\\"C\\\\\\\",\\\\\\\"S\\\\\\\"],[\\\\\\\"A\\\\\\\",\\\\\\\"D\\\\\\\",\\\\\\\"E\\\\\\\",\\\\\\\"E\\\\\\\"]], word = \\\\\\\"SEE\\\\\\\"\\\\r\\\\nOutput: true\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Example 3\\\\r\\\\n\\\\r\\\\n![](https://assets.leetcode.com/uploads/2020/10/15/word3.jpg)\\\\r\\\\n\\\\r\\\\n```bash\\\\r\\\\nInput: board = [[\\\\\\\"A\\\\\\\",\\\\\\\"B\\\\\\\",\\\\\\\"C\\\\\\\",\\\\\\\"E\\\\\\\"],[\\\\\\\"S\\\\\\\",\\\\\\\"F\\\\\\\",\\\\\\\"C\\\\\\\",\\\\\\\"S\\\\\\\"],[\\\\\\\"A\\\\\\\",\\\\\\\"D\\\\\\\",\\\\\\\"E\\\\\\\",\\\\\\\"E\\\\\\\"]], word = \\\\\\\"ABCB\\\\\\\"\\\\r\\\\nOutput: false\\\\r\\\\n```\\\\r\\\\n\\\\r\\\\n### Constraints:\\\\r\\\\n\\\\r\\\\n- m == board.length \\\\r\\\\n- n = board[i].length \\\\r\\\\n- 1 <= m, n <= 6 \\\\r\\\\n- 1 <= word.length <= 15 \\\\r\\\\n- board and word consists of only lowercase and uppercase English letters.\\\",\\\"basename\\\":\\\"word-search\\\"}}\",\"basename\":\"prompt\"},\"redundant-connection\":{\"title\":\"Redundant Connection\",\"description\":\"In this problem, a tree is an undirected graph that is connected and has no cycles.\",\"tags\":[\"medium\",\"graphs\"],\"link\":\"https://leetcode.com/problems/redundant-connection/\",\"images\":[\"https://assets.leetcode.com/uploads/2021/05/02/reduntant1-1-graph.jpg\",\"https://assets.leetcode.com/uploads/2021/05/02/reduntant1-2-graph.jpg\"],\"preview\":\"### Description\\r\\n\\r\\nIn this problem, a tree is an **undirected graph** that is connected and has no cycles.\\r\\n\\r\\nYou are given a graph that started as a tree with n nodes labeled from 1 to n, with one additional edge added. The added edge has two **different** vertices chosen from 1 to n, and was not an edge that already existed. The graph is represented as an array edges of length n where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the graph.\\r\\n\\r\\nReturn an edge that can be removed so that the resulting graph is a tree of n nodes. If there are multiple answers, return the answer that occurs last in the input.\\r\\n\\r\\n### Example 1\\r\\n\\r\\n![](https://assets.leetcode.com/uploads/2021/05/02/reduntant1-1-graph.jpg)\\r\\n\\r\\n```bash\\r\\nInput: edges = [[1,2],[1,3],[2,3]]\\r\\nOutput: [2,3]\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n\\r\\n![](https://assets.leetcode.com/uploads/2021/05/02/reduntant1-2-graph.jpg)\\r\\n\\r\\n```bash\\r\\nInput: edges = [[1,2],[2,3],[3,4],[1,4],[1,5]]\\r\\nOutput: [1,4]\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n- n == edges.length\\r\\n- 3 <= n <= 1000\\r\\n- edges[i].length == 2\\r\\n- 1 <= ai < bi <= edges.length\\r\\n- ai != bi\\r\\n- There are no repeated edges.\\r\\n- The given graph is connected.\",\"basename\":\"redundant-connection\"},\"regex-1\":{\"title\":\"Regex 1\",\"description\":\"create a markdown that returns all 'hackerrank' matches\",\"tags\":[\"easy\",\"regex\"],\"link\":\"https://www.hackerrank.com/challenges/regex-1/problem\",\"preview\":\"### Description\\r\\n\\r\\nCreate a markdown that returns all 'hackerrank' matches\\r\\n\\r\\n### Example 1\\r\\n\\r\\n```bash\\r\\nInput The hackerrank team is on a mission to flatten the world by restructuring the hackerrank DNA of every company on the planet. We rank programmers based on their coding skills, helping companies source great programmers and reduce the time to hire. As a result, we are revolutionizing the way companies discover and evaluate talented engineers. The hackerrank platform is the destination for the best engineers to hone their skills and companies to find top engineers. \\r\\n\\r\\nOutput: ['hackerrank', 'hackerrank', 'hackerrank']\\r\\n```\",\"basename\":\"regex-1\"},\"remove-from-nth\":{\"title\":\"Remove Nth Node From End of List\",\"description\":\"Given the head of a linked list, remove the nth node from the end of the list and return its head.\",\"tags\":[\"medium\",\"linked-list\"],\"link\":\"https://leetcode.com/problems/remove-nth-node-from-end-of-list/\",\"preview\":\"### Description\\r\\n\\r\\nGiven the head of a linked list, remove the nth node from the end of the list and return its head.\\r\\n\\r\\n### Example 1\\r\\n\\r\\n```bash\\r\\nInput: head = [1,2,3,4,5], n = 2\\r\\nOutput: [1,2,3,5]\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n\\r\\n```bash\\r\\nInput: head = [1], n = 1\\r\\nOutput: []\\r\\n```\\r\\n\\r\\n### Example 3\\r\\n\\r\\n```bash\\r\\nInput: head = [1,2], n = 1\\r\\nOutput: [1]\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n- The number of nodes in the list is sz. \\r\\n- 1 <= sz <= 30 \\r\\n- 0 <= Node.val <= 100 \\r\\n- 1 <= n <= sz\",\"basename\":\"remove-from-nth\"},\"reorder-list\":{\"title\":\"Reorder List\",\"description\":\"You are given the head of a singly linked-list. The list can be represented as\",\"tags\":[\"medium\",\"linked-list\"],\"link\":\"https://leetcode.com/problems/reorder-list/\",\"images\":[\"https://assets.leetcode.com/uploads/2021/03/04/reorder1linked-list.jpg\",\"https://assets.leetcode.com/uploads/2021/03/04/reorder2linked-list.jpg\"],\"preview\":\"### Description\\r\\n\\r\\nYou are given the head of a singly linked-list. The list can be represented as:\\r\\n\\r\\n`L0 â†’ L1 â†’ â€¦ â†’ Ln - 1 â†’ Ln`\\r\\nReorder the list to be on the following form:\\r\\n\\r\\n`L0 â†’ Ln â†’ L1 â†’ Ln - 1 â†’ L2 â†’ Ln - 2 â†’ â€¦`\\r\\nYou may not modify the values in the list's nodes. Only nodes themselves may be changed.\\r\\n\\r\\n### Example 1\\r\\n\\r\\n![](https://assets.leetcode.com/uploads/2021/03/04/reorder1linked-list.jpg)\\r\\n\\r\\n```bash\\r\\nInput: head = [1,2,3,4]\\r\\nOutput: [1,4,2,3]\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n\\r\\n![](https://assets.leetcode.com/uploads/2021/03/04/reorder2linked-list.jpg)\\r\\n\\r\\n```bash\\r\\nInput: head = [1,2,3,4,5]\\r\\nOutput: [1,5,2,4,3]\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n- The number of nodes in the list is in the range [1, 5 * 104]. \\r\\n- 1 <= Node.val <= 1000\",\"basename\":\"reorder-list\"},\"reverse-linked-list\":{\"title\":\"Reverse Linked List\",\"description\":\"Given the head of a singly linked list, reverse the list, and return the reversed list.\",\"tags\":[\"easy\",\"linked-list\"],\"link\":\"https://leetcode.com/problems/reverse-linked-list/\",\"images\":[\"https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg\",\"https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg\"],\"preview\":\"### Description\\r\\n\\r\\nGovem the `head` of a singly linked list, reverse the list, and return the reversed list.\\r\\n\\r\\n### Example 1\\r\\n\\r\\n![](https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg)\\r\\n\\r\\n```bash\\r\\nInput: head = [1,2,3,4,5]\\r\\nOutput: [5,4,3,2,1]\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n\\r\\n![](https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg)\\r\\n\\r\\n```bash\\r\\nInput: head = [1,2]\\r\\nOutput: [2,1]\\r\\n```\\r\\n\\r\\n### Example 3\\r\\n\\r\\n```bash\\r\\nInput: head = []\\r\\nOutput: []\\r\\n```\\r\\n\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n- The number of nodes in the list is the range [0, 5000].\\r\\n- -5000 <= Node.val <= 5000\",\"basename\":\"reverse-linked-list\"},\"reverse-nodes-in-k-group\":{\"title\":\"Reverse Nodes in k-Group\",\"description\":\"Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.\",\"tags\":[\"hard\",\"linked-list\"],\"link\":\"https://leetcode.com/problems/reverse-nodes-in-k-group/\",\"preview\":\"### Description\\r\\n\\r\\nGiven the `head` of a linked list, reverse the nodes of the list `k` at a time, and return the modified list.\\r\\n\\r\\n`k` is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of `k` then left-out nodes, in the end, should remain as it is.\\r\\n\\r\\nYou may not alter the values in the list's nodes, only nodes themselves may be changed.\\r\\n\\r\\n### Example 1\\r\\n\\r\\n```bash\\r\\nInput: head = [1,2,3,4,5], k = 2\\r\\nOutput: [2,1,4,3,5]\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n\\r\\n```bash\\r\\nInput: head = [1,2,3,4,5], k = 3\\r\\nOutput: [3,2,1,4,5]\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n- The number of nodes in the list is n. \\r\\n- 1 <= k <= n <= 5000 \\r\\n- 0 <= Node.val <= 1000\",\"basename\":\"reverse-nodes-in-k-group\"},\"rotting-oranges\":{\"title\":\"Rotting Oranges\",\"description\":\"Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1.\",\"tags\":[\"medium\",\"graphs\"],\"link\":\"https://leetcode.com/problems/rotting-oranges/\",\"images\":[\"https://assets.leetcode.com/uploads/2019/02/16/oranges.png\"],\"preview\":\"### Description\\r\\n\\r\\nYou are given an m x n grid where each cell can have one of three values:\\r\\n\\r\\n- 0 representing an empty cell,\\r\\n- 1 representing a fresh orange, or\\r\\n- 2 representing a rotten orange.\\r\\n\\r\\nEvery minute, any fresh orange that is **4-directionally** adjacent to a rotten orange becomes rotten.\\r\\n\\r\\nReturn the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1.\\r\\n\\r\\n### Example 1\\r\\n\\r\\n![](https://assets.leetcode.com/uploads/2019/02/16/oranges.png)\\r\\n\\r\\n```bash\\r\\nInput: grid = [[2,1,1],[1,1,0],[0,1,1]]\\r\\nOutput: 4\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n\\r\\n```bash\\r\\nInput: grid = [[2,1,1],[0,1,1],[1,0,1]]\\r\\nOutput: -1\\r\\nExplanation: The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally.\\r\\n```\\r\\n\\r\\n### Example 3\\r\\n\\r\\n```bash\\r\\nInput: grid = [[0,2]]\\r\\nOutput: 0\\r\\nExplanation: Since there are already no fresh oranges at minute 0, the answer is just 0.\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n- m == grid.length \\r\\n- n == grid[i].length\\r\\n- 1 <= m, n <= 10 \\r\\n- grid[i][j] is 0, 1, or 2.\",\"basename\":\"rotting-oranges\"},\"same-tree\":{\"title\":\"Same Tree\",\"description\":\"Given the roots of two binary trees p and q, write a function to check if they are the same or not.\",\"tags\":[\"easy\",\"binary-tree\"],\"link\":\"https://leetcode.com/problems/same-tree/\",\"images\":[\"https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg\",\"https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg\",\"https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg\"],\"preview\":\"### Description\\r\\n\\r\\nGiven the roots of two binary trees p and q, write a function to check if they are the same or not.\\r\\n\\r\\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.\\r\\n\\r\\n### Example 1\\r\\n\\r\\n![](https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg)\\r\\n\\r\\n```bash\\r\\nInput: p = [1,2,3], q = [1,2,3]\\r\\nOutput: true\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n\\r\\n![](https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg)\\r\\n\\r\\n\\r\\n```bash\\r\\nInput: p = [1,2], q = [1,null,2]\\r\\nOutput: false\\r\\n```\\r\\n\\r\\n### Example 3\\r\\n\\r\\n![](https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg)\\r\\n\\r\\n```bash\\r\\nInput: p = [1,2,1], q = [1,1,2]\\r\\nOutput: false\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n- The number of nodes in both trees is in the range [0, 100]. \\r\\n- -10^4 <= Node.val <= 10^4\",\"basename\":\"same-tree\"},\"sample\":{\"title\":\"Bellflower\",\"author\":\"guy\",\"date\":\"2012-07-23T00:00:00.000Z\",\"template\":\"article.jade\",\"tags\":[\"crab\",\"rose\",\"bells\"],\"preview\":\"## Interesting\\r\\n\\r\\nHow strange are those old recollections which haunt us without our being able to get rid of them! This one is so very old that I cannot understand how it has clung so vividly and tenaciously to my memory. Since then I have seen so many sinister things, either affecting or terrible, that I am astonished at not being able to pass a single day without the face of Mother Bellflower recurring to my mind's eye, just as I knew her formerly long, long ago, when I was ten or twelve years old. <span class=\\\"more\\\"></span>\\r\\n\\r\\nShe was an old seamstress who came to my parents' house once a week, every Thursday, to mend the linen. My parents lived in one of those country houses called chateaux, which are merely old houses with pointed roofs, to which are attached three or four adjacent farms.\\r\\n\\r\\nThe village, a large village, almost a small market town, was a few hundred yards off and nestled round the church, a red brick church, which had become black with age.\\r\\n\\r\\nWell, every Thursday Mother Bellflower came between half-past six and seven in the morning and went immediately into the linen room and began to work. She was a tall, thin, bearded or rather hairy woman, for she had a beard all over her face, a surprising, an unexpected beard, growing in improbable tufts, in curly bunches which looked as if they had been sown by a madman over that great face, the face of a gendarme in petticoats. She had them on her nose, under her nose, round her nose, on her chin, on her cheeks, and her eyebrows, which were extraordinarily thick and long and quite gray, bushy and bristling, looked exactly like a pair of mustaches stuck on there by mistake.\\r\\n\\r\\nShe limped, not like lame people generally do, but like a ship pitching. When she planted her great bony, vibrant body on her sound leg, she seemed to be preparing to mount some enormous wave, and then suddenly she dipped as if to disappear in an abyss and buried herself in the ground. Her walk reminded one of a ship in a storm, and her head, which was always covered with an enormous white cap, whose ribbons fluttered down her back, seemed to traverse the horizon from north to south and from south to north at each limp.\\r\\n\\r\\nI adored Mother Bellflower. As soon as I was up I used to go into the linen room, where I found her installed at work with a foot warmer under her feet. As soon as I arrived she made me take the foot warmer and sit upon it, so that I might not catch cold in that large chilly room under the roof.\\r\\n\\r\\n\\\"That draws the blood from your head,\\\" she would say to me.\\r\\n\\r\\nShe told me stories while mending the linen with her long, crooked, nimble fingers; behind her magnifying spectacles, for age had impaired her sight, her eyes appeared enormous to me, strangely profound, double.\\r\\n\\r\\nAs far as I can remember from the things which she told me and by which my childish heart was moved, she had the large heart of a poor woman. She told me what had happened in the village, how a cow had escaped from the cow house and had been found the next morning in front of Prosper Malet's mill looking at the sails turning, or about a hen's egg which had been found in the church belfry without anyone being able to understand what creature had been there to lay it, or the queer story of Jean Pila's dog who had gone ten leagues to bring back his master's breeches which a tramp had stolen while they were hanging up to dry out of doors after he had been caught in the rain. She told me these simple adventures in such a manner that in my mind they assumed the proportions of never-to-be-forgotten dramas, of grand and mysterious poems; and the ingenious stories invented by the poets, which my mother told me in the evening, had none of the flavor, none of the fullness or of the vigor of the peasant woman's narratives.\\r\\n\\r\\nWell, one Thursday when I had spent all the morning in listening to Mother Clochette, I wanted to go upstairs to her again during the day after picking hazelnuts with the manservant in the wood behind the farm. I remember it all as clearly as what happened only yesterday.\\r\\n\\r\\nOn opening the door of the linen room I saw the old seamstress lying on the floor by the side of her chair, her face turned down and her arms stretched out, but still holding her needle in one hand and one of my shirts in the other. One of her legs in a blue stocking, the longer one no doubt, was extended under her chair, and her spectacles glistened by the wall, where they had rolled away from her.\\r\\n\\r\\nI ran away uttering shrill cries. They all came running, and in a few minutes I was told that Mother Clochette was dead.\\r\\n\\r\\nI cannot describe the profound, poignant, terrible emotion which stirred my childish heart. I went slowly down into the drawing room and hid myself in a dark corner in the depths of a great old armchair, where I knelt and wept. I remained there for a long time, no doubt, for night came on. Suddenly someone came in with a lamp--without seeing me, however--and heard my father and mother talking with the medical man, whose voice recognized.\\r\\n\\r\\nHe had been sent for immediately, and he was explaining the cause of the accident, of which I understood nothing, however. Then he sat down and had a glass of liqueur and a biscuit.\\r\\n\\r\\nHe went on talking, and what he then said will remain engraved on my mind until I die. I think that I can give the exact words which he used.\\r\\n\\r\\n\\\"Ah!\\\" he said. \\\"The poor woman! she broke her leg the day of my arrival here. I had not even had time to wash my hands after getting off the diligence before I was sent for in all haste, for it was a bad case, very bad.\\r\\n\\r\\n\\\"She was seventeen and a pretty girl, very pretty! Would anyone believe it? I have never told her story before; in fact, no one but myself and one other person, who is no longer living in this part of the country, ever knew it. Now that she is dead I may be less discreet.\\r\\n\\r\\n\\\"A young assistant teacher had just come to live in the village; he was good looking and had the bearing of a soldier. All the girls ran after him, but he was disdainful. Besides that, he was very much afraid of his superior, the schoolmaster, old Grabu, who occasionally got out of bed the wrong foot first.\\r\\n\\r\\n\\\"Old Grabu already employed pretty Hortense, who has just died here and who was afterward nicknamed Clochette. The assistant master singled out the pretty young girl who was no doubt flattered at being chosen by this disdainful conqueror; at any rate, she fell in love with him, and he succeeded in persuading her to give him a first meeting in the hayloft behind the school at night after she had done her day's sewing.\\r\\n\\r\\n\\\"She pretended to go home, but instead of going downstairs when she left the Grabus', she went upstairs and hid among the hay to wait for her lover. He soon joined her, and he was beginning to say pretty things to her, when the door of the hayloft opened and the schoolmaster appeared and asked: 'What are you doing up there, Sigisbert?' Feeling sure that he would be caught, the young schoolmaster lost his presence of mind and replied stupidly: 'I came up here to rest a little among the bundles of hay, Monsieur Grabu.'\\r\\n\\r\\n\\\"The loft was very large and absolutely dark. Sigisbert pushed the frightened girl to the farther end and said: 'Go, there and hide yourself. I shall lose my situation, so get away and hide yourself.'\\r\\n\\r\\n\\\"When the schoolmaster heard the whispering he continued: 'Why, you are not by yourself.'\\r\\n\\r\\n\\\"'Yes, I am, Monsieur Grabu!'\\r\\n\\r\\n\\\"'But you are not, for you are talking.'\\r\\n\\r\\n\\\"'I swear I am, Monsieur Grabu.'\\r\\n\\r\\n\\\"'I will soon find out,' the old man replied and, double-locking the door, he went down to get a light.\\r\\n\\r\\n\\\"Then the young man, who was a coward such as one sometimes meets, lost his head, and he repeated, having grown furious all of a sudden: 'Hide yourself, so that he may not find you. You will deprive me of my bread for my whole life; you will ruin my whole career! Do hide yourself!'\\r\\n\\r\\n\\\"They could hear the key turning in the lock again, and Hortense ran to the window which looked out onto the street, opened it quickly and then in a low and determined voice said: 'You will come and pick me up when he is gone,' and she jumped out.\\r\\n\\r\\n\\\"Old Grabu found nobody and went down again in great surprise! A quarter of an hour later Monsieur Sigisbert came to me and related his adventure. The girl had remained at the foot of the wall, unable to get up, as she had fallen from the second story, and I went with him to fetch her. It was raining in torrents, and I brought the unfortunate girl home with me, for the right leg was broken in three places, and the bones had come out through the flesh. She did not complain and merely said with admirable resignation: 'I am punished, well punished!'\\r\\n\\r\\n\\\"I sent for assistance and for the workgirl's friends and told them a made-up story of a runaway carriage which had knocked her down and lamed her outside my door. They believed me, and the gendarmes for a whole month tried in vain to find the author of this accident.\\r\\n\\r\\n\\\"That is all! Now I say that this woman was a heroine and had the fiber of those who accomplish the grandest deeds in history.\\r\\n\\r\\n\\\"That was her only love affair, and she died a virgin. She was a martyr, a noble soul, a sublimely devoted woman! And if I did not absolutely admire her I should not have told you this story, which I would never tell anyone during her life; you understand why.\\\"\\r\\n\\r\\nThe doctor ceased; Mamma cried, and Papa said some words which I did not catch; then they left the room, and I remained on my knees in the armchair and sobbed, while I heard a strange noise of heavy footsteps and something knocking against the side of the staircase.\\r\\n\\r\\nThey were carrying away Clochette's body.\",\"iso8601Date\":\"2012-07-22T20:00:00-04:00\",\"basename\":\"sample\"},\"search-matrix\":{\"title\":\"Search a 2D Matrix\",\"description\":\"You are given an m x n integer matrix matrix with the following two properties\",\"tags\":[\"medium\",\"binary-search\"],\"link\":\"https://leetcode.com/problems/search-a-2d-matrix/\",\"preview\":\"### Description\\r\\n\\r\\nYou are given an `m x n` integer matrix `matrix` with the following two properties:\\r\\n\\r\\n    Each row is sorted in non-decreasing order.\\r\\n    The first integer of each row is greater than the last integer of the previous row.\\r\\n\\r\\nGiven an integer target, return `true` if `target` is in `matrix` or `false` otherwise.\\r\\n\\r\\nYou must write a solution in `O(log(m * n))` time complexity.\\r\\n\\r\\n### Example 1\\r\\n\\r\\n![figure1](https://assets.leetcode.com/uploads/2020/10/05/mat.jpg)\\r\\n\\r\\n```bash\\r\\nInput: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\\r\\nOutput: true\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n\\r\\n![figure2](https://assets.leetcode.com/uploads/2020/10/05/mat2.jpg)\\r\\n\\r\\n```bash\\r\\nInput: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13\\r\\nOutput: false\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n- m == matrix.length\\r\\n- n == matrix[i].length\\r\\n- 1 <= m, n <= 100\\r\\n- -104 <= matrix[i][j], target <= 104\",\"basename\":\"search-matrix\"},\"search-rotated-array\":{\"title\":\"Search in Rotated Sorted Array\",\"description\":\"Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.\",\"tags\":[\"medium\",\"binary-search\"],\"link\":\"https://leetcode.com/problems/search-in-rotated-sorted-array/\",\"preview\":\"### Description\\r\\n\\r\\nThere is an integer array `nums` sorted in ascending order (with **distinct** values).\\r\\n\\r\\nPrior to being passed to your function, nums is **possibly rotated** at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].\\r\\n\\r\\nGiven the array `nums` **after** the possible rotation and an integer target, return the index of `target` if it is in `nums`, or `-1` if it is not in `nums`.\\r\\n\\r\\nYou must write an algorithm with O(log n) runtime complexity.\\r\\n\\r\\n### Example 1\\r\\n\\r\\n```bash\\r\\nInput: nums = [4,5,6,7,0,1,2], target = 0\\r\\nOutput: 4\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n\\r\\n```bash\\r\\nInput: nums = [4,5,6,7,0,1,2], target = 3\\r\\nOutput: -1\\r\\n```\\r\\n\\r\\n\\r\\n### Example 3\\r\\n\\r\\n```bash\\r\\nInput: nums = [1], target = 0\\r\\nOutput: -1\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n-      1 <= nums.length <= 5000     \\r\\n-      -104 <= nums[i] <= 104     \\r\\n-      All values of nums are unique.     \\r\\n-      nums is an ascending array that is possibly rotated.     \\r\\n-      -104 <= target <= 104\",\"basename\":\"search-rotated-array\"},\"serialize-and-deserialize-binary-tree\":{\"title\":\"Serialize and Deserialize Binary Tree\",\"description\":\"Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\",\"tags\":[\"hard\",\"binary-tree\"],\"link\":\"https://leetcode.com/problems/serialize-and-deserialize-binary-tree/\",\"images\":[\"https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg\"],\"preview\":\"### Description\\r\\n\\r\\nSerialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\\r\\n\\r\\nDesign an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.\\r\\n\\r\\n**Clarification**: The input/output format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.\\r\\n\\r\\n### Example 1\\r\\n\\r\\n![](https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg)\\r\\n\\r\\n```bash\\r\\nInput: root = [1,2,3,null,null,4,5]\\r\\nOutput: [1,2,3,null,null,4,5]\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n\\r\\n```bash\\r\\nInput: root = []\\r\\nOutput: []\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n- The number of nodes in the tree is in the range [0, 10^4]. \\r\\n- -1000 <= Node.val <= 1000\",\"basename\":\"serialize-and-deserialize-binary-tree\"},\"simple-division\":{\"title\":\"Simple Division\",\"description\":\"A simple division example\",\"tags\":[\"sample\",\"math\"],\"preview\":\"This is  a simple division example.\\r\\n\\r\\n```js\\r\\nimport { prompt } from 'dsa-cli';\\r\\nconst a = prompt('Enter a number: ');\\r\\nconst b = prompt('Enter another number: ');\\r\\nconsole.log(a / b);\\r\\n```\\r\\n\\r\\n```bash\\r\\n$ dsa run simple-division.js\\r\\nEnter a number: 10\\r\\n```\",\"basename\":\"simple-division\"},\"simple-substraction\":{\"title\":\"Simple Substraction\",\"description\":\"A simple substraction example\",\"tags\":[\"sample\",\"math\"],\"preview\":\"This is  a simple substraction example.!\\r\\n\\r\\n```js\\r\\nimport { prompt } from 'dsa-cli';\\r\\nconst a = prompt('Enter a number: ');\\r\\nconst b = prompt('Enter another number: ');\\r\\nconsole.log(a - b);\\r\\n```\\r\\n\\r\\n```bash\\r\\n$ dsa run simple-substraction.js\\r\\nEnter a number: 11\\r\\nEnter another number: 5\\r\\n```\",\"basename\":\"simple-substraction\"},\"simple-sum\":{\"title\":\"Simple Sum\",\"description\":\"A simple sum example!\",\"tags\":[\"sample\",\"math\"],\"preview\":\"This is  a simple sum example.\\r\\n\\r\\n```js\\r\\nimport { prompt } from 'dsa-cli';\\r\\nconst a = prompt('Enter a number: ');\\r\\nconst b = prompt('Enter another number: ');\\r\\nconsole.log(a + b);\\r\\n```\\r\\n\\r\\n```bash\\r\\n$ dsa run simple-sum.js\\r\\nEnter a number: 10\\r\\nEnter another number:\\r\\n```\",\"basename\":\"simple-sum\"},\"subsets-ii\":{\"title\":\"Subsets II\",\"description\":\"Given an integer array nums that may contain duplicates, return all possible subsets (the power set).\",\"tags\":[\"medium\",\"backtracking\"],\"link\":\"https://leetcode.com/problems/subsets-ii/\",\"images\":[],\"preview\":\"### Description\\r\\n\\r\\nGiven an integer array `nums` that may contain duplicates, return all possible subsets (the power set).\\r\\n\\r\\nThe solution set **must not** contain duplicate subsets. Return the solution in **any order**.\\r\\n\\r\\n### Example 1\\r\\n\\r\\n```bash\\r\\nInput: nums = [1,2,2]\\r\\nOutput: [[],[1],[1,2],[1,2,2],[2],[2,2]]\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n\\r\\n```bash\\r\\nInput: nums = [0]\\r\\nOutput: [[],[0]]\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n- 1 <= nums.length <= 10\\r\\n- -10 <= nums[i] <= 10\",\"basename\":\"subsets-ii\"},\"subsets\":{\"preview\":\"\",\"basename\":\"subsets\"},\"subtree-of-another-tree\":{\"title\":\"Subtree of Another Tree\",\"description\":\"A subtree of a binary tree tree is a tree that consists of a node in tree and all of this node's descendants. The tree tree could also be considered as a subtree of itself.\",\"tags\":[\"easy\",\"binary-tree\"],\"link\":\"https://leetcode.com/problems/subtree-of-another-tree/\",\"images\":[\"https://assets.leetcode.com/uploads/2021/02/18/tree1.jpg\",\"https://assets.leetcode.com/uploads/2021/02/18/tree2.jpg\"],\"preview\":\"### Description\\r\\n\\r\\nGiven the roots of two binary trees `root` and `subRoot`, return true if there is a subtree of root with the same structure and node values of `subRoot` and `false` otherwise.\\r\\n\\r\\nA subtree of a binary tree `tree` is a tree that consists of a node in tree and all of this node's descendants. The tree `tree` could also be considered as a subtree of itself.\\r\\n\\r\\n### Example 1\\r\\n\\r\\n![](https://assets.leetcode.com/uploads/2021/02/18/tree1.jpg)\\r\\n\\r\\n```bash\\r\\nInput: root = [3,4,5,1,2], subRoot = [4,1,2]\\r\\nOutput: true\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n\\r\\n![](https://assets.leetcode.com/uploads/2021/02/18/tree2.jpg)\\r\\n\\r\\n```bash\\r\\nInput: root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]\\r\\nOutput: false\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n- The number of nodes in the root tree is in the range [1, 2000]. \\r\\n- The number of nodes in the subRoot tree is in the range [1, 1000]. \\r\\n- -10^4 <= root.val <= 10^4 \\r\\n- -10^4 <= subRoot.val <= 10^4\",\"basename\":\"subtree-of-another-tree\"},\"surrounded-regions\":{\"title\":\"Surrounded Regions\",\"description\":\"Given an m x n matrix board containing 'X' and 'O', capture all regions that are 4-directionally surrounded by 'X'.\",\"tags\":[\"medium\",\"graphs\"],\"link\":\"https://leetcode.com/problems/surrounded-regions/\",\"images\":[\"https://assets.leetcode.com/uploads/2021/02/19/xogrid.jpg\"],\"preview\":\"### Description\\r\\n\\r\\nGiven an `m x n` matrix board containing 'X' and 'O', capture all regions that are 4-directionally surrounded by 'X'.\\r\\n\\r\\nA region is **captured** by flipping all 'O's into 'X's in that surrounded region.\\r\\n\\r\\n### Example 1\\r\\n\\r\\n![](https://assets.leetcode.com/uploads/2021/02/19/xogrid.jpg)\\r\\n\\r\\n```bash\\r\\nInput: board = [[\\\"X\\\",\\\"X\\\",\\\"X\\\",\\\"X\\\"],[\\\"X\\\",\\\"O\\\",\\\"O\\\",\\\"X\\\"],[\\\"X\\\",\\\"X\\\",\\\"O\\\",\\\"X\\\"],[\\\"X\\\",\\\"O\\\",\\\"X\\\",\\\"X\\\"]]\\r\\nOutput: [[\\\"X\\\",\\\"X\\\",\\\"X\\\",\\\"X\\\"],[\\\"X\\\",\\\"X\\\",\\\"X\\\",\\\"X\\\"],[\\\"X\\\",\\\"X\\\",\\\"X\\\",\\\"X\\\"],[\\\"X\\\",\\\"O\\\",\\\"X\\\",\\\"X\\\"]]\\r\\nExplanation: Notice that an 'O' should not be flipped if:\\r\\n- It is on the border, or\\r\\n- It is adjacent to an 'O' that should not be flipped.\\r\\nThe bottom 'O' is on the border, so it is not flipped.\\r\\nThe other three 'O' form a surrounded region, so they are flipped.\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n\\r\\n```bash\\r\\nInput: board = [[\\\"X\\\"]]\\r\\nOutput: [[\\\"X\\\"]]\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n- m == board.length\\r\\n- n == board[i].length\\r\\n- 1 <= m, n <= 200\\r\\n- board[i][j] is 'X' or 'O'\",\"basename\":\"surrounded-regions\"},\"task-scheduler\":{\"title\":\"Task Scheduler\",\"description\":\"Return the least number of units of times that the CPU will take to finish all the given tasks.\",\"tags\":[\"medium\",\"heap\"],\"link\":\"https://leetcode.com/problems/task-scheduler/\",\"images\":[],\"preview\":\"### Description\\r\\n\\r\\nGiven a characters array tasks, representing the tasks a CPU needs to do, where each letter represents a different task. Tasks could be done in any order. Each task is done in one unit of time. For each unit of time, the CPU could complete either one task or just be idle.\\r\\n\\r\\nHowever, there is a non-negative integer n that represents the cooldown period between two **same tasks** (the same letter in the array), that is that there must be at least n units of time between any two same tasks.\\r\\n\\r\\nReturn the least number of units of times that the CPU will take to finish all the given tasks.\\r\\n\\r\\n### Example 1\\r\\n\\r\\n```bash\\r\\nInput: tasks = [\\\"A\\\",\\\"A\\\",\\\"A\\\",\\\"B\\\",\\\"B\\\",\\\"B\\\"], n = 2\\r\\nOutput: 8\\r\\nExplanation: \\r\\nA -> B -> idle -> A -> B -> idle -> A -> B\\r\\nThere is at least 2 units of time between any two same tasks.\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n\\r\\n```bash\\r\\nInput: tasks = [\\\"A\\\",\\\"A\\\",\\\"A\\\",\\\"B\\\",\\\"B\\\",\\\"B\\\"], n = 0\\r\\nOutput: 6\\r\\nExplanation: On this case any permutation of size 6 would work since n = 0.\\r\\n[\\\"A\\\",\\\"A\\\",\\\"A\\\",\\\"B\\\",\\\"B\\\",\\\"B\\\"]\\r\\n[\\\"A\\\",\\\"B\\\",\\\"A\\\",\\\"B\\\",\\\"A\\\",\\\"B\\\"]\\r\\n[\\\"B\\\",\\\"B\\\",\\\"B\\\",\\\"A\\\",\\\"A\\\",\\\"A\\\"]\\r\\n...\\r\\nAnd so on.\\r\\n```\\r\\n\\r\\n### Example 3\\r\\n\\r\\n```bash\\r\\nInput: tasks = [\\\"A\\\",\\\"A\\\",\\\"A\\\",\\\"A\\\",\\\"A\\\",\\\"A\\\",\\\"B\\\",\\\"C\\\",\\\"D\\\",\\\"E\\\",\\\"F\\\",\\\"G\\\"], n = 2\\r\\nOutput: 16\\r\\nExplanation: \\r\\nOne possible solution is\\r\\nA -> B -> C -> A -> D -> E -> A -> F -> G -> A -> idle -> idle -> A -> idle -> idle -> A\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n- 1 <= task.length <= 10^4 \\r\\n- tasks[i] is upper-case English letter. \\r\\n- The integer n is in the range [0, 100].\",\"basename\":\"task-scheduler\"},\"three-number-sum\":{\"title\":\"Three Number Sum\",\"description\":\"A three number sum example\",\"tags\":[\"arrays\",\"math\"],\"preview\":\"## Three Number Sum\\r\\n\\r\\nGiven an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\\r\\n\\r\\nNotice that the solution set must not contain duplicate triplets.\\r\\n\\r\\n \\r\\n\\r\\nExample 1:\\r\\n```\\r\\nInput: nums = [-1,0,1,2,-1,-4]\\r\\nOutput: [[-1,-1,2],[-1,0,1]]\\r\\nExplanation: \\r\\nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\\r\\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\\r\\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\\r\\nThe distinct triplets are [-1,0,1] and [-1,-1,2].\\r\\nNotice that the order of the output and the order of the triplets does not matter.\\r\\n```\\r\\n\\r\\nExample 2:\\r\\n\\r\\n```\\r\\nInput: nums = [0,1,1]\\r\\nOutput: []\\r\\nExplanation: The only possible triplet does not sum up to 0.\\r\\n```\\r\\n\\r\\nExample 3:\\r\\n\\r\\n```\\r\\nInput: nums = [0,0,0]\\r\\nOutput: [[0,0,0]]\\r\\nExplanation: The only possible triplet sums up to 0.\\r\\n```\",\"basename\":\"three-number-sum\"},\"trapping-rain-water\":{\"title\":\"Trapping Rain Water\",\"description\":\"A trapping rain water example\",\"tags\":[\"hard\",\"two-pointers\"],\"preview\":\"Given `n` non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\\r\\n\\r\\nExample 1\\r\\n\\r\\n```\\r\\nInput: height = [0,1,0,2,1,0,1,3,2,1,2,1]\\r\\nOutput: 6\\r\\nExplanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\\r\\n```\\r\\n\\r\\nExample 2\\r\\n\\r\\n```\\r\\nInput: height = [4,2,0,3,2,5]\\r\\nOutput: 9\\r\\n```\",\"basename\":\"trapping-rain-water\"},\"valid-parentheses\":{\"title\":\"Valid Parentheses\",\"description\":\"Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\",\"tags\":[\"easy\",\"stack\"],\"link\":\"https://leetcode.com/problems/valid-parentheses/\",\"preview\":\"### Description\\r\\n\\r\\nGiven a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\\r\\n\\r\\nAn input string is valid if:\\r\\n\\r\\nOpen brackets must be closed by the same type of brackets.\\r\\nOpen brackets must be closed in the correct order.\\r\\nEvery close bracket has a corresponding open bracket of the same type.\\r\\n\\r\\n\\r\\n### Example 1\\r\\n```bash\\r\\nInput: s = \\\"()\\\"\\r\\nOutput: true\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n```bash\\r\\nInput: s = \\\"()[]{}\\\"\\r\\nOutput: true\\r\\n```\\r\\n\\r\\n### Example 3\\r\\n```bash\\r\\nInput: s = \\\"(]\\\"\\r\\nOutput: false\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n-      1 <= s.length <= 104     \\r\\n-      s consists of parentheses only '()[]{}'.\",\"basename\":\"valid-parentheses\"},\"validate-binary-search-tree\":{\"title\":\"Validate Binary Search Tree\",\"description\":\"Given the root of a binary tree, determine if it is a valid binary search tree (BST).\",\"tags\":[\"medium\",\"binary-tree\"],\"link\":\"https://leetcode.com/problems/validate-binary-search-tree/\",\"images\":[\"https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg\",\"https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg\"],\"preview\":\"### Description\\r\\n\\r\\nGiven the root of a binary tree, determine if it is a valid binary search tree (BST).\\r\\n\\r\\nA valid BST is defined as follows:\\r\\n\\r\\n- The left subtree of a node contains only nodes with keys less than the node's key.\\r\\n- The right subtree of a node contains only nodes with keys greater than the node's key.\\r\\n- Both the left and right subtrees must also be binary search trees.\\r\\n\\r\\n### Example 1\\r\\n\\r\\n![](https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg)\\r\\n\\r\\n```bash\\r\\nInput: root = [2,1,3]\\r\\nOutput: true\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n\\r\\n![](https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg)\\r\\n\\r\\n```bash\\r\\nInput: root = [5,1,4,null,null,3,6]\\r\\nOutput: false\\r\\nExplanation: The root node's value is 5 but its right child's value is 4.\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n- The number of nodes in the tree is in the range [1, 104].\\r\\n- -2^31 <= Node.val <= 2^31 - 1\",\"basename\":\"validate-binary-search-tree\"},\"walls-and-gates\":{\"title\":\"Walls and Gates\",\"description\":\"Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should be filled with INF.\",\"tags\":[\"medium\",\"graphs\"],\"link\":\"https://tenderleo.gitbooks.io/leetcode-solutions-/content/GoogleMedium/286.html\",\"images\":[],\"preview\":\"### Description\\r\\n\\r\\nYou are given a m x n 2D grid initialized with these three possible values.\\r\\n\\r\\n-1 - A wall or an obstacle. 0 - A gate. INF - Infinity means an empty room. We use the value 231 - 1 = 2147483647 to represent INF as you may assume that the distance to a gate is less than 2147483647. Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should be filled with INF.\\r\\n\\r\\n### Example 1\\r\\n\\r\\n```bash\\r\\nINF  -1  0  INF\\r\\nINF INF INF  -1\\r\\nINF  -1 INF  -1\\r\\n  0  -1 INF INF\\r\\n```\\r\\nAfter running the function, the 2D grid should be:\\r\\n\\r\\n```bash\\r\\n  3  -1   0   1\\r\\n  2   2   1  -1\\r\\n  1  -1   2  -1\\r\\n  0  -1   3   4\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n- m == rooms.length\\r\\n- n == rooms[i].length\",\"basename\":\"walls-and-gates\"},\"word-ladder\":{\"title\":\"Word Ladder\",\"description\":\"Given two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.\",\"tags\":[\"hard\",\"graphs\"],\"link\":\"https://leetcode.com/problems/word-ladder/\",\"images\":[],\"preview\":\"### Description\\r\\n\\r\\nA transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\\r\\n\\r\\n- Every adjacent pair of words differs by a single letter.\\r\\n- Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList.\\r\\n- sk == endWord\\r\\n\\r\\n\\r\\nGiven two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.\\r\\n\\r\\n \\r\\n\\r\\n### Example 1\\r\\n\\r\\n```bash\\r\\nInput: beginWord = \\\"hit\\\", endWord = \\\"cog\\\", wordList = [\\\"hot\\\",\\\"dot\\\",\\\"dog\\\",\\\"lot\\\",\\\"log\\\",\\\"cog\\\"]\\r\\nOutput: 5\\r\\nExplanation: One shortest transformation sequence is \\\"hit\\\" -> \\\"hot\\\" -> \\\"dot\\\" -> \\\"dog\\\" -> cog\\\", which is 5 words long.\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n\\r\\n```bash\\r\\nInput: beginWord = \\\"hit\\\", endWord = \\\"cog\\\", wordList = [\\\"hot\\\",\\\"dot\\\",\\\"dog\\\",\\\"lot\\\",\\\"log\\\"]\\r\\nOutput: 0\\r\\nExplanation: The endWord \\\"cog\\\" is not in wordList, therefore there is no valid transformation sequence.\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n- 1 <= beginWord.length <= 10\\r\\n- endWord.length == beginWord.length\\r\\n- 1 <= wordList.length <= 5000\\r\\n- wordList[i].length == beginWord.length\\r\\n- beginWord, endWord, and wordList[i] consist of lowercase English letters.\\r\\n- beginWord != endWord\\r\\n- All the words in wordList are unique.\",\"basename\":\"word-ladder\"},\"word-search-ii\":{\"title\":\"Word Search II\",\"description\":\"Given an m x n board of characters and a list of strings words, return all words on the board.\",\"tags\":[\"hard\",\"trie\"],\"link\":\"https://leetcode.com/problems/word-search-ii/\",\"images\":[],\"preview\":\"### Description\\r\\n\\r\\nGiven an m x n board of characters and a list of strings words, return all words on the board.\\r\\n\\r\\nEach word must be constructed from letters of sequentially adjacent cells, where **adjacent cells** are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.\\r\\n\\r\\n### Example 1\\r\\n\\r\\n![](https://assets.leetcode.com/uploads/2020/11/07/search1.jpg)\\r\\n\\r\\n```bash\\r\\nInput: board = [[\\\"o\\\",\\\"a\\\",\\\"a\\\",\\\"n\\\"],[\\\"e\\\",\\\"t\\\",\\\"a\\\",\\\"e\\\"],[\\\"i\\\",\\\"h\\\",\\\"k\\\",\\\"r\\\"],[\\\"i\\\",\\\"f\\\",\\\"l\\\",\\\"v\\\"]], words = [\\\"oath\\\",\\\"pea\\\",\\\"eat\\\",\\\"rain\\\"]\\r\\nOutput: [\\\"eat\\\",\\\"oath\\\"]\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n\\r\\n![](https://assets.leetcode.com/uploads/2020/11/07/search2.jpg)\\r\\n\\r\\n\\r\\n```bash\\r\\nInput: board = [[\\\"a\\\",\\\"b\\\"],[\\\"c\\\",\\\"d\\\"]], words = [\\\"abcb\\\"]\\r\\nOutput: []\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n- m == board.length\\r\\n- n == board[i].length\\r\\n- 1 <= m, n <= 12\\r\\n- board[i][j] is a lowercase English letter.\\r\\n- 1 <= words.length <= 3 * 10^4\\r\\n- 1 <= words[i].length <= 10\\r\\n- words[i] consists of lowercase English letters.\\r\\n- All the strings of `words` are unique.\",\"basename\":\"word-search-ii\"},\"word-search\":{\"title\":\"Word Search\",\"description\":\"Given an m x n grid of characters board and a string word, return true if word exists in the grid.\",\"tags\":[],\"link\":\"https://leetcode.com/problems/word-search/\",\"images\":[],\"preview\":\"### Description\\r\\n\\r\\nGiven an `m x n` grid of characters `board` and a string `word`, return `true` if word exists in the grid.\\r\\nThe word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.\\r\\n\\r\\n### Example 1\\r\\n\\r\\n![](https://assets.leetcode.com/uploads/2020/11/04/word2.jpg)\\r\\n\\r\\n```bash\\r\\nInput: board = [[\\\"A\\\",\\\"B\\\",\\\"C\\\",\\\"E\\\"],[\\\"S\\\",\\\"F\\\",\\\"C\\\",\\\"S\\\"],[\\\"A\\\",\\\"D\\\",\\\"E\\\",\\\"E\\\"]], word = \\\"ABCCED\\\"\\r\\nOutput: true\\r\\n```\\r\\n\\r\\n### Example 2\\r\\n\\r\\n![](https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg)\\r\\n\\r\\n```bash\\r\\nInput: board = [[\\\"A\\\",\\\"B\\\",\\\"C\\\",\\\"E\\\"],[\\\"S\\\",\\\"F\\\",\\\"C\\\",\\\"S\\\"],[\\\"A\\\",\\\"D\\\",\\\"E\\\",\\\"E\\\"]], word = \\\"SEE\\\"\\r\\nOutput: true\\r\\n```\\r\\n\\r\\n### Example 3\\r\\n\\r\\n![](https://assets.leetcode.com/uploads/2020/10/15/word3.jpg)\\r\\n\\r\\n```bash\\r\\nInput: board = [[\\\"A\\\",\\\"B\\\",\\\"C\\\",\\\"E\\\"],[\\\"S\\\",\\\"F\\\",\\\"C\\\",\\\"S\\\"],[\\\"A\\\",\\\"D\\\",\\\"E\\\",\\\"E\\\"]], word = \\\"ABCB\\\"\\r\\nOutput: false\\r\\n```\\r\\n\\r\\n### Constraints:\\r\\n\\r\\n- m == board.length \\r\\n- n = board[i].length \\r\\n- 1 <= m, n <= 6 \\r\\n- 1 <= word.length <= 15 \\r\\n- board and word consists of only lowercase and uppercase English letters.\",\"basename\":\"word-search\"}}","basename":"prompt"},"redundant-connection":{"title":"Redundant Connection","description":"In this problem, a tree is an undirected graph that is connected and has no cycles.","tags":["medium","graphs"],"link":"https://leetcode.com/problems/redundant-connection/","images":["https://assets.leetcode.com/uploads/2021/05/02/reduntant1-1-graph.jpg","https://assets.leetcode.com/uploads/2021/05/02/reduntant1-2-graph.jpg"],"preview":"### Description\r\n\r\nIn this problem, a tree is an **undirected graph** that is connected and has no cycles.\r\n\r\nYou are given a graph that started as a tree with n nodes labeled from 1 to n, with one additional edge added. The added edge has two **different** vertices chosen from 1 to n, and was not an edge that already existed. The graph is represented as an array edges of length n where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the graph.\r\n\r\nReturn an edge that can be removed so that the resulting graph is a tree of n nodes. If there are multiple answers, return the answer that occurs last in the input.\r\n\r\n### Example 1\r\n\r\n![](https://assets.leetcode.com/uploads/2021/05/02/reduntant1-1-graph.jpg)\r\n\r\n```bash\r\nInput: edges = [[1,2],[1,3],[2,3]]\r\nOutput: [2,3]\r\n```\r\n\r\n### Example 2\r\n\r\n![](https://assets.leetcode.com/uploads/2021/05/02/reduntant1-2-graph.jpg)\r\n\r\n```bash\r\nInput: edges = [[1,2],[2,3],[3,4],[1,4],[1,5]]\r\nOutput: [1,4]\r\n```\r\n\r\n### Constraints:\r\n\r\n- n == edges.length\r\n- 3 <= n <= 1000\r\n- edges[i].length == 2\r\n- 1 <= ai < bi <= edges.length\r\n- ai != bi\r\n- There are no repeated edges.\r\n- The given graph is connected.","basename":"redundant-connection"},"regex-1":{"title":"Regex 1","description":"create a markdown that returns all 'hackerrank' matches","tags":["easy","regex"],"link":"https://www.hackerrank.com/challenges/regex-1/problem","preview":"### Description\r\n\r\nCreate a markdown that returns all 'hackerrank' matches\r\n\r\n### Example 1\r\n\r\n```bash\r\nInput The hackerrank team is on a mission to flatten the world by restructuring the hackerrank DNA of every company on the planet. We rank programmers based on their coding skills, helping companies source great programmers and reduce the time to hire. As a result, we are revolutionizing the way companies discover and evaluate talented engineers. The hackerrank platform is the destination for the best engineers to hone their skills and companies to find top engineers. \r\n\r\nOutput: ['hackerrank', 'hackerrank', 'hackerrank']\r\n```","basename":"regex-1"},"remove-from-nth":{"title":"Remove Nth Node From End of List","description":"Given the head of a linked list, remove the nth node from the end of the list and return its head.","tags":["medium","linked-list"],"link":"https://leetcode.com/problems/remove-nth-node-from-end-of-list/","preview":"### Description\r\n\r\nGiven the head of a linked list, remove the nth node from the end of the list and return its head.\r\n\r\n### Example 1\r\n\r\n```bash\r\nInput: head = [1,2,3,4,5], n = 2\r\nOutput: [1,2,3,5]\r\n```\r\n\r\n### Example 2\r\n\r\n```bash\r\nInput: head = [1], n = 1\r\nOutput: []\r\n```\r\n\r\n### Example 3\r\n\r\n```bash\r\nInput: head = [1,2], n = 1\r\nOutput: [1]\r\n```\r\n\r\n### Constraints:\r\n\r\n- The number of nodes in the list is sz. \r\n- 1 <= sz <= 30 \r\n- 0 <= Node.val <= 100 \r\n- 1 <= n <= sz","basename":"remove-from-nth"},"reorder-list":{"title":"Reorder List","description":"You are given the head of a singly linked-list. The list can be represented as","tags":["medium","linked-list"],"link":"https://leetcode.com/problems/reorder-list/","images":["https://assets.leetcode.com/uploads/2021/03/04/reorder1linked-list.jpg","https://assets.leetcode.com/uploads/2021/03/04/reorder2linked-list.jpg"],"preview":"### Description\r\n\r\nYou are given the head of a singly linked-list. The list can be represented as:\r\n\r\n`L0 â†’ L1 â†’ â€¦ â†’ Ln - 1 â†’ Ln`\r\nReorder the list to be on the following form:\r\n\r\n`L0 â†’ Ln â†’ L1 â†’ Ln - 1 â†’ L2 â†’ Ln - 2 â†’ â€¦`\r\nYou may not modify the values in the list's nodes. Only nodes themselves may be changed.\r\n\r\n### Example 1\r\n\r\n![](https://assets.leetcode.com/uploads/2021/03/04/reorder1linked-list.jpg)\r\n\r\n```bash\r\nInput: head = [1,2,3,4]\r\nOutput: [1,4,2,3]\r\n```\r\n\r\n### Example 2\r\n\r\n![](https://assets.leetcode.com/uploads/2021/03/04/reorder2linked-list.jpg)\r\n\r\n```bash\r\nInput: head = [1,2,3,4,5]\r\nOutput: [1,5,2,4,3]\r\n```\r\n\r\n### Constraints:\r\n\r\n- The number of nodes in the list is in the range [1, 5 * 104]. \r\n- 1 <= Node.val <= 1000","basename":"reorder-list"},"reverse-linked-list":{"title":"Reverse Linked List","description":"Given the head of a singly linked list, reverse the list, and return the reversed list.","tags":["easy","linked-list"],"link":"https://leetcode.com/problems/reverse-linked-list/","images":["https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg","https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg"],"preview":"### Description\r\n\r\nGovem the `head` of a singly linked list, reverse the list, and return the reversed list.\r\n\r\n### Example 1\r\n\r\n![](https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg)\r\n\r\n```bash\r\nInput: head = [1,2,3,4,5]\r\nOutput: [5,4,3,2,1]\r\n```\r\n\r\n### Example 2\r\n\r\n![](https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg)\r\n\r\n```bash\r\nInput: head = [1,2]\r\nOutput: [2,1]\r\n```\r\n\r\n### Example 3\r\n\r\n```bash\r\nInput: head = []\r\nOutput: []\r\n```\r\n\r\n\r\n### Constraints:\r\n\r\n- The number of nodes in the list is the range [0, 5000].\r\n- -5000 <= Node.val <= 5000","basename":"reverse-linked-list"},"reverse-nodes-in-k-group":{"title":"Reverse Nodes in k-Group","description":"Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.","tags":["hard","linked-list"],"link":"https://leetcode.com/problems/reverse-nodes-in-k-group/","preview":"### Description\r\n\r\nGiven the `head` of a linked list, reverse the nodes of the list `k` at a time, and return the modified list.\r\n\r\n`k` is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of `k` then left-out nodes, in the end, should remain as it is.\r\n\r\nYou may not alter the values in the list's nodes, only nodes themselves may be changed.\r\n\r\n### Example 1\r\n\r\n```bash\r\nInput: head = [1,2,3,4,5], k = 2\r\nOutput: [2,1,4,3,5]\r\n```\r\n\r\n### Example 2\r\n\r\n```bash\r\nInput: head = [1,2,3,4,5], k = 3\r\nOutput: [3,2,1,4,5]\r\n```\r\n\r\n### Constraints:\r\n\r\n- The number of nodes in the list is n. \r\n- 1 <= k <= n <= 5000 \r\n- 0 <= Node.val <= 1000","basename":"reverse-nodes-in-k-group"},"rotting-oranges":{"title":"Rotting Oranges","description":"Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1.","tags":["medium","graphs"],"link":"https://leetcode.com/problems/rotting-oranges/","images":["https://assets.leetcode.com/uploads/2019/02/16/oranges.png"],"preview":"### Description\r\n\r\nYou are given an m x n grid where each cell can have one of three values:\r\n\r\n- 0 representing an empty cell,\r\n- 1 representing a fresh orange, or\r\n- 2 representing a rotten orange.\r\n\r\nEvery minute, any fresh orange that is **4-directionally** adjacent to a rotten orange becomes rotten.\r\n\r\nReturn the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1.\r\n\r\n### Example 1\r\n\r\n![](https://assets.leetcode.com/uploads/2019/02/16/oranges.png)\r\n\r\n```bash\r\nInput: grid = [[2,1,1],[1,1,0],[0,1,1]]\r\nOutput: 4\r\n```\r\n\r\n### Example 2\r\n\r\n```bash\r\nInput: grid = [[2,1,1],[0,1,1],[1,0,1]]\r\nOutput: -1\r\nExplanation: The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally.\r\n```\r\n\r\n### Example 3\r\n\r\n```bash\r\nInput: grid = [[0,2]]\r\nOutput: 0\r\nExplanation: Since there are already no fresh oranges at minute 0, the answer is just 0.\r\n```\r\n\r\n### Constraints:\r\n\r\n- m == grid.length \r\n- n == grid[i].length\r\n- 1 <= m, n <= 10 \r\n- grid[i][j] is 0, 1, or 2.","basename":"rotting-oranges"},"same-tree":{"title":"Same Tree","description":"Given the roots of two binary trees p and q, write a function to check if they are the same or not.","tags":["easy","binary-tree"],"link":"https://leetcode.com/problems/same-tree/","images":["https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg","https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg","https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg"],"preview":"### Description\r\n\r\nGiven the roots of two binary trees p and q, write a function to check if they are the same or not.\r\n\r\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.\r\n\r\n### Example 1\r\n\r\n![](https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg)\r\n\r\n```bash\r\nInput: p = [1,2,3], q = [1,2,3]\r\nOutput: true\r\n```\r\n\r\n### Example 2\r\n\r\n![](https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg)\r\n\r\n\r\n```bash\r\nInput: p = [1,2], q = [1,null,2]\r\nOutput: false\r\n```\r\n\r\n### Example 3\r\n\r\n![](https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg)\r\n\r\n```bash\r\nInput: p = [1,2,1], q = [1,1,2]\r\nOutput: false\r\n```\r\n\r\n### Constraints:\r\n\r\n- The number of nodes in both trees is in the range [0, 100]. \r\n- -10^4 <= Node.val <= 10^4","basename":"same-tree"},"sample":{"title":"Bellflower","author":"guy","date":"2012-07-23T00:00:00.000Z","template":"article.jade","tags":["crab","rose","bells"],"preview":"## Interesting\r\n\r\nHow strange are those old recollections which haunt us without our being able to get rid of them! This one is so very old that I cannot understand how it has clung so vividly and tenaciously to my memory. Since then I have seen so many sinister things, either affecting or terrible, that I am astonished at not being able to pass a single day without the face of Mother Bellflower recurring to my mind's eye, just as I knew her formerly long, long ago, when I was ten or twelve years old. <span class=\"more\"></span>\r\n\r\nShe was an old seamstress who came to my parents' house once a week, every Thursday, to mend the linen. My parents lived in one of those country houses called chateaux, which are merely old houses with pointed roofs, to which are attached three or four adjacent farms.\r\n\r\nThe village, a large village, almost a small market town, was a few hundred yards off and nestled round the church, a red brick church, which had become black with age.\r\n\r\nWell, every Thursday Mother Bellflower came between half-past six and seven in the morning and went immediately into the linen room and began to work. She was a tall, thin, bearded or rather hairy woman, for she had a beard all over her face, a surprising, an unexpected beard, growing in improbable tufts, in curly bunches which looked as if they had been sown by a madman over that great face, the face of a gendarme in petticoats. She had them on her nose, under her nose, round her nose, on her chin, on her cheeks, and her eyebrows, which were extraordinarily thick and long and quite gray, bushy and bristling, looked exactly like a pair of mustaches stuck on there by mistake.\r\n\r\nShe limped, not like lame people generally do, but like a ship pitching. When she planted her great bony, vibrant body on her sound leg, she seemed to be preparing to mount some enormous wave, and then suddenly she dipped as if to disappear in an abyss and buried herself in the ground. Her walk reminded one of a ship in a storm, and her head, which was always covered with an enormous white cap, whose ribbons fluttered down her back, seemed to traverse the horizon from north to south and from south to north at each limp.\r\n\r\nI adored Mother Bellflower. As soon as I was up I used to go into the linen room, where I found her installed at work with a foot warmer under her feet. As soon as I arrived she made me take the foot warmer and sit upon it, so that I might not catch cold in that large chilly room under the roof.\r\n\r\n\"That draws the blood from your head,\" she would say to me.\r\n\r\nShe told me stories while mending the linen with her long, crooked, nimble fingers; behind her magnifying spectacles, for age had impaired her sight, her eyes appeared enormous to me, strangely profound, double.\r\n\r\nAs far as I can remember from the things which she told me and by which my childish heart was moved, she had the large heart of a poor woman. She told me what had happened in the village, how a cow had escaped from the cow house and had been found the next morning in front of Prosper Malet's mill looking at the sails turning, or about a hen's egg which had been found in the church belfry without anyone being able to understand what creature had been there to lay it, or the queer story of Jean Pila's dog who had gone ten leagues to bring back his master's breeches which a tramp had stolen while they were hanging up to dry out of doors after he had been caught in the rain. She told me these simple adventures in such a manner that in my mind they assumed the proportions of never-to-be-forgotten dramas, of grand and mysterious poems; and the ingenious stories invented by the poets, which my mother told me in the evening, had none of the flavor, none of the fullness or of the vigor of the peasant woman's narratives.\r\n\r\nWell, one Thursday when I had spent all the morning in listening to Mother Clochette, I wanted to go upstairs to her again during the day after picking hazelnuts with the manservant in the wood behind the farm. I remember it all as clearly as what happened only yesterday.\r\n\r\nOn opening the door of the linen room I saw the old seamstress lying on the floor by the side of her chair, her face turned down and her arms stretched out, but still holding her needle in one hand and one of my shirts in the other. One of her legs in a blue stocking, the longer one no doubt, was extended under her chair, and her spectacles glistened by the wall, where they had rolled away from her.\r\n\r\nI ran away uttering shrill cries. They all came running, and in a few minutes I was told that Mother Clochette was dead.\r\n\r\nI cannot describe the profound, poignant, terrible emotion which stirred my childish heart. I went slowly down into the drawing room and hid myself in a dark corner in the depths of a great old armchair, where I knelt and wept. I remained there for a long time, no doubt, for night came on. Suddenly someone came in with a lamp--without seeing me, however--and heard my father and mother talking with the medical man, whose voice recognized.\r\n\r\nHe had been sent for immediately, and he was explaining the cause of the accident, of which I understood nothing, however. Then he sat down and had a glass of liqueur and a biscuit.\r\n\r\nHe went on talking, and what he then said will remain engraved on my mind until I die. I think that I can give the exact words which he used.\r\n\r\n\"Ah!\" he said. \"The poor woman! she broke her leg the day of my arrival here. I had not even had time to wash my hands after getting off the diligence before I was sent for in all haste, for it was a bad case, very bad.\r\n\r\n\"She was seventeen and a pretty girl, very pretty! Would anyone believe it? I have never told her story before; in fact, no one but myself and one other person, who is no longer living in this part of the country, ever knew it. Now that she is dead I may be less discreet.\r\n\r\n\"A young assistant teacher had just come to live in the village; he was good looking and had the bearing of a soldier. All the girls ran after him, but he was disdainful. Besides that, he was very much afraid of his superior, the schoolmaster, old Grabu, who occasionally got out of bed the wrong foot first.\r\n\r\n\"Old Grabu already employed pretty Hortense, who has just died here and who was afterward nicknamed Clochette. The assistant master singled out the pretty young girl who was no doubt flattered at being chosen by this disdainful conqueror; at any rate, she fell in love with him, and he succeeded in persuading her to give him a first meeting in the hayloft behind the school at night after she had done her day's sewing.\r\n\r\n\"She pretended to go home, but instead of going downstairs when she left the Grabus', she went upstairs and hid among the hay to wait for her lover. He soon joined her, and he was beginning to say pretty things to her, when the door of the hayloft opened and the schoolmaster appeared and asked: 'What are you doing up there, Sigisbert?' Feeling sure that he would be caught, the young schoolmaster lost his presence of mind and replied stupidly: 'I came up here to rest a little among the bundles of hay, Monsieur Grabu.'\r\n\r\n\"The loft was very large and absolutely dark. Sigisbert pushed the frightened girl to the farther end and said: 'Go, there and hide yourself. I shall lose my situation, so get away and hide yourself.'\r\n\r\n\"When the schoolmaster heard the whispering he continued: 'Why, you are not by yourself.'\r\n\r\n\"'Yes, I am, Monsieur Grabu!'\r\n\r\n\"'But you are not, for you are talking.'\r\n\r\n\"'I swear I am, Monsieur Grabu.'\r\n\r\n\"'I will soon find out,' the old man replied and, double-locking the door, he went down to get a light.\r\n\r\n\"Then the young man, who was a coward such as one sometimes meets, lost his head, and he repeated, having grown furious all of a sudden: 'Hide yourself, so that he may not find you. You will deprive me of my bread for my whole life; you will ruin my whole career! Do hide yourself!'\r\n\r\n\"They could hear the key turning in the lock again, and Hortense ran to the window which looked out onto the street, opened it quickly and then in a low and determined voice said: 'You will come and pick me up when he is gone,' and she jumped out.\r\n\r\n\"Old Grabu found nobody and went down again in great surprise! A quarter of an hour later Monsieur Sigisbert came to me and related his adventure. The girl had remained at the foot of the wall, unable to get up, as she had fallen from the second story, and I went with him to fetch her. It was raining in torrents, and I brought the unfortunate girl home with me, for the right leg was broken in three places, and the bones had come out through the flesh. She did not complain and merely said with admirable resignation: 'I am punished, well punished!'\r\n\r\n\"I sent for assistance and for the workgirl's friends and told them a made-up story of a runaway carriage which had knocked her down and lamed her outside my door. They believed me, and the gendarmes for a whole month tried in vain to find the author of this accident.\r\n\r\n\"That is all! Now I say that this woman was a heroine and had the fiber of those who accomplish the grandest deeds in history.\r\n\r\n\"That was her only love affair, and she died a virgin. She was a martyr, a noble soul, a sublimely devoted woman! And if I did not absolutely admire her I should not have told you this story, which I would never tell anyone during her life; you understand why.\"\r\n\r\nThe doctor ceased; Mamma cried, and Papa said some words which I did not catch; then they left the room, and I remained on my knees in the armchair and sobbed, while I heard a strange noise of heavy footsteps and something knocking against the side of the staircase.\r\n\r\nThey were carrying away Clochette's body.","iso8601Date":"2012-07-22T20:00:00-04:00","basename":"sample"},"search-matrix":{"title":"Search a 2D Matrix","description":"You are given an m x n integer matrix matrix with the following two properties","tags":["medium","binary-search"],"link":"https://leetcode.com/problems/search-a-2d-matrix/","preview":"### Description\r\n\r\nYou are given an `m x n` integer matrix `matrix` with the following two properties:\r\n\r\n    Each row is sorted in non-decreasing order.\r\n    The first integer of each row is greater than the last integer of the previous row.\r\n\r\nGiven an integer target, return `true` if `target` is in `matrix` or `false` otherwise.\r\n\r\nYou must write a solution in `O(log(m * n))` time complexity.\r\n\r\n### Example 1\r\n\r\n![figure1](https://assets.leetcode.com/uploads/2020/10/05/mat.jpg)\r\n\r\n```bash\r\nInput: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\r\nOutput: true\r\n```\r\n\r\n### Example 2\r\n\r\n![figure2](https://assets.leetcode.com/uploads/2020/10/05/mat2.jpg)\r\n\r\n```bash\r\nInput: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13\r\nOutput: false\r\n```\r\n\r\n### Constraints:\r\n\r\n- m == matrix.length\r\n- n == matrix[i].length\r\n- 1 <= m, n <= 100\r\n- -104 <= matrix[i][j], target <= 104","basename":"search-matrix"},"search-rotated-array":{"title":"Search in Rotated Sorted Array","description":"Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.","tags":["medium","binary-search"],"link":"https://leetcode.com/problems/search-in-rotated-sorted-array/","preview":"### Description\r\n\r\nThere is an integer array `nums` sorted in ascending order (with **distinct** values).\r\n\r\nPrior to being passed to your function, nums is **possibly rotated** at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].\r\n\r\nGiven the array `nums` **after** the possible rotation and an integer target, return the index of `target` if it is in `nums`, or `-1` if it is not in `nums`.\r\n\r\nYou must write an algorithm with O(log n) runtime complexity.\r\n\r\n### Example 1\r\n\r\n```bash\r\nInput: nums = [4,5,6,7,0,1,2], target = 0\r\nOutput: 4\r\n```\r\n\r\n### Example 2\r\n\r\n```bash\r\nInput: nums = [4,5,6,7,0,1,2], target = 3\r\nOutput: -1\r\n```\r\n\r\n\r\n### Example 3\r\n\r\n```bash\r\nInput: nums = [1], target = 0\r\nOutput: -1\r\n```\r\n\r\n### Constraints:\r\n\r\n-      1 <= nums.length <= 5000     \r\n-      -104 <= nums[i] <= 104     \r\n-      All values of nums are unique.     \r\n-      nums is an ascending array that is possibly rotated.     \r\n-      -104 <= target <= 104","basename":"search-rotated-array"},"serialize-and-deserialize-binary-tree":{"title":"Serialize and Deserialize Binary Tree","description":"Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.","tags":["hard","binary-tree"],"link":"https://leetcode.com/problems/serialize-and-deserialize-binary-tree/","images":["https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg"],"preview":"### Description\r\n\r\nSerialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\r\n\r\nDesign an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.\r\n\r\n**Clarification**: The input/output format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.\r\n\r\n### Example 1\r\n\r\n![](https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg)\r\n\r\n```bash\r\nInput: root = [1,2,3,null,null,4,5]\r\nOutput: [1,2,3,null,null,4,5]\r\n```\r\n\r\n### Example 2\r\n\r\n```bash\r\nInput: root = []\r\nOutput: []\r\n```\r\n\r\n### Constraints:\r\n\r\n- The number of nodes in the tree is in the range [0, 10^4]. \r\n- -1000 <= Node.val <= 1000","basename":"serialize-and-deserialize-binary-tree"},"simple-division":{"title":"Simple Division","description":"A simple division example","tags":["sample","math"],"preview":"This is  a simple division example.\r\n\r\n```js\r\nimport { prompt } from 'dsa-cli';\r\nconst a = prompt('Enter a number: ');\r\nconst b = prompt('Enter another number: ');\r\nconsole.log(a / b);\r\n```\r\n\r\n```bash\r\n$ dsa run simple-division.js\r\nEnter a number: 10\r\n```","basename":"simple-division"},"simple-substraction":{"title":"Simple Substraction","description":"A simple substraction example","tags":["sample","math"],"preview":"This is  a simple substraction example.!\r\n\r\n```js\r\nimport { prompt } from 'dsa-cli';\r\nconst a = prompt('Enter a number: ');\r\nconst b = prompt('Enter another number: ');\r\nconsole.log(a - b);\r\n```\r\n\r\n```bash\r\n$ dsa run simple-substraction.js\r\nEnter a number: 11\r\nEnter another number: 5\r\n```","basename":"simple-substraction"},"simple-sum":{"title":"Simple Sum","description":"A simple sum example!","tags":["sample","math"],"preview":"This is  a simple sum example.\r\n\r\n```js\r\nimport { prompt } from 'dsa-cli';\r\nconst a = prompt('Enter a number: ');\r\nconst b = prompt('Enter another number: ');\r\nconsole.log(a + b);\r\n```\r\n\r\n```bash\r\n$ dsa run simple-sum.js\r\nEnter a number: 10\r\nEnter another number:\r\n```","basename":"simple-sum"},"subsets-ii":{"title":"Subsets II","description":"Given an integer array nums that may contain duplicates, return all possible subsets (the power set).","tags":["medium","backtracking"],"link":"https://leetcode.com/problems/subsets-ii/","images":[],"preview":"### Description\r\n\r\nGiven an integer array `nums` that may contain duplicates, return all possible subsets (the power set).\r\n\r\nThe solution set **must not** contain duplicate subsets. Return the solution in **any order**.\r\n\r\n### Example 1\r\n\r\n```bash\r\nInput: nums = [1,2,2]\r\nOutput: [[],[1],[1,2],[1,2,2],[2],[2,2]]\r\n```\r\n\r\n### Example 2\r\n\r\n```bash\r\nInput: nums = [0]\r\nOutput: [[],[0]]\r\n```\r\n\r\n### Constraints:\r\n\r\n- 1 <= nums.length <= 10\r\n- -10 <= nums[i] <= 10","basename":"subsets-ii"},"subsets":{"preview":"","basename":"subsets"},"subtree-of-another-tree":{"title":"Subtree of Another Tree","description":"A subtree of a binary tree tree is a tree that consists of a node in tree and all of this node's descendants. The tree tree could also be considered as a subtree of itself.","tags":["easy","binary-tree"],"link":"https://leetcode.com/problems/subtree-of-another-tree/","images":["https://assets.leetcode.com/uploads/2021/02/18/tree1.jpg","https://assets.leetcode.com/uploads/2021/02/18/tree2.jpg"],"preview":"### Description\r\n\r\nGiven the roots of two binary trees `root` and `subRoot`, return true if there is a subtree of root with the same structure and node values of `subRoot` and `false` otherwise.\r\n\r\nA subtree of a binary tree `tree` is a tree that consists of a node in tree and all of this node's descendants. The tree `tree` could also be considered as a subtree of itself.\r\n\r\n### Example 1\r\n\r\n![](https://assets.leetcode.com/uploads/2021/02/18/tree1.jpg)\r\n\r\n```bash\r\nInput: root = [3,4,5,1,2], subRoot = [4,1,2]\r\nOutput: true\r\n```\r\n\r\n### Example 2\r\n\r\n![](https://assets.leetcode.com/uploads/2021/02/18/tree2.jpg)\r\n\r\n```bash\r\nInput: root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]\r\nOutput: false\r\n```\r\n\r\n### Constraints:\r\n\r\n- The number of nodes in the root tree is in the range [1, 2000]. \r\n- The number of nodes in the subRoot tree is in the range [1, 1000]. \r\n- -10^4 <= root.val <= 10^4 \r\n- -10^4 <= subRoot.val <= 10^4","basename":"subtree-of-another-tree"},"surrounded-regions":{"title":"Surrounded Regions","description":"Given an m x n matrix board containing 'X' and 'O', capture all regions that are 4-directionally surrounded by 'X'.","tags":["medium","graphs"],"link":"https://leetcode.com/problems/surrounded-regions/","images":["https://assets.leetcode.com/uploads/2021/02/19/xogrid.jpg"],"preview":"### Description\r\n\r\nGiven an `m x n` matrix board containing 'X' and 'O', capture all regions that are 4-directionally surrounded by 'X'.\r\n\r\nA region is **captured** by flipping all 'O's into 'X's in that surrounded region.\r\n\r\n### Example 1\r\n\r\n![](https://assets.leetcode.com/uploads/2021/02/19/xogrid.jpg)\r\n\r\n```bash\r\nInput: board = [[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"O\",\"X\"],[\"X\",\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]]\r\nOutput: [[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]]\r\nExplanation: Notice that an 'O' should not be flipped if:\r\n- It is on the border, or\r\n- It is adjacent to an 'O' that should not be flipped.\r\nThe bottom 'O' is on the border, so it is not flipped.\r\nThe other three 'O' form a surrounded region, so they are flipped.\r\n```\r\n\r\n### Example 2\r\n\r\n```bash\r\nInput: board = [[\"X\"]]\r\nOutput: [[\"X\"]]\r\n```\r\n\r\n### Constraints:\r\n\r\n- m == board.length\r\n- n == board[i].length\r\n- 1 <= m, n <= 200\r\n- board[i][j] is 'X' or 'O'","basename":"surrounded-regions"},"task-scheduler":{"title":"Task Scheduler","description":"Return the least number of units of times that the CPU will take to finish all the given tasks.","tags":["medium","heap"],"link":"https://leetcode.com/problems/task-scheduler/","images":[],"preview":"### Description\r\n\r\nGiven a characters array tasks, representing the tasks a CPU needs to do, where each letter represents a different task. Tasks could be done in any order. Each task is done in one unit of time. For each unit of time, the CPU could complete either one task or just be idle.\r\n\r\nHowever, there is a non-negative integer n that represents the cooldown period between two **same tasks** (the same letter in the array), that is that there must be at least n units of time between any two same tasks.\r\n\r\nReturn the least number of units of times that the CPU will take to finish all the given tasks.\r\n\r\n### Example 1\r\n\r\n```bash\r\nInput: tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2\r\nOutput: 8\r\nExplanation: \r\nA -> B -> idle -> A -> B -> idle -> A -> B\r\nThere is at least 2 units of time between any two same tasks.\r\n```\r\n\r\n### Example 2\r\n\r\n```bash\r\nInput: tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 0\r\nOutput: 6\r\nExplanation: On this case any permutation of size 6 would work since n = 0.\r\n[\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"]\r\n[\"A\",\"B\",\"A\",\"B\",\"A\",\"B\"]\r\n[\"B\",\"B\",\"B\",\"A\",\"A\",\"A\"]\r\n...\r\nAnd so on.\r\n```\r\n\r\n### Example 3\r\n\r\n```bash\r\nInput: tasks = [\"A\",\"A\",\"A\",\"A\",\"A\",\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\"], n = 2\r\nOutput: 16\r\nExplanation: \r\nOne possible solution is\r\nA -> B -> C -> A -> D -> E -> A -> F -> G -> A -> idle -> idle -> A -> idle -> idle -> A\r\n```\r\n\r\n### Constraints:\r\n\r\n- 1 <= task.length <= 10^4 \r\n- tasks[i] is upper-case English letter. \r\n- The integer n is in the range [0, 100].","basename":"task-scheduler"},"three-number-sum":{"title":"Three Number Sum","description":"A three number sum example","tags":["arrays","math"],"preview":"## Three Number Sum\r\n\r\nGiven an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\r\n\r\nNotice that the solution set must not contain duplicate triplets.\r\n\r\n \r\n\r\nExample 1:\r\n```\r\nInput: nums = [-1,0,1,2,-1,-4]\r\nOutput: [[-1,-1,2],[-1,0,1]]\r\nExplanation: \r\nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\r\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\r\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\r\nThe distinct triplets are [-1,0,1] and [-1,-1,2].\r\nNotice that the order of the output and the order of the triplets does not matter.\r\n```\r\n\r\nExample 2:\r\n\r\n```\r\nInput: nums = [0,1,1]\r\nOutput: []\r\nExplanation: The only possible triplet does not sum up to 0.\r\n```\r\n\r\nExample 3:\r\n\r\n```\r\nInput: nums = [0,0,0]\r\nOutput: [[0,0,0]]\r\nExplanation: The only possible triplet sums up to 0.\r\n```","basename":"three-number-sum"},"trapping-rain-water":{"title":"Trapping Rain Water","description":"A trapping rain water example","tags":["hard","two-pointers"],"preview":"Given `n` non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\r\n\r\nExample 1\r\n\r\n```\r\nInput: height = [0,1,0,2,1,0,1,3,2,1,2,1]\r\nOutput: 6\r\nExplanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\r\n```\r\n\r\nExample 2\r\n\r\n```\r\nInput: height = [4,2,0,3,2,5]\r\nOutput: 9\r\n```","basename":"trapping-rain-water"},"valid-parentheses":{"title":"Valid Parentheses","description":"Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.","tags":["easy","stack"],"link":"https://leetcode.com/problems/valid-parentheses/","preview":"### Description\r\n\r\nGiven a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\r\n\r\nAn input string is valid if:\r\n\r\nOpen brackets must be closed by the same type of brackets.\r\nOpen brackets must be closed in the correct order.\r\nEvery close bracket has a corresponding open bracket of the same type.\r\n\r\n\r\n### Example 1\r\n```bash\r\nInput: s = \"()\"\r\nOutput: true\r\n```\r\n\r\n### Example 2\r\n```bash\r\nInput: s = \"()[]{}\"\r\nOutput: true\r\n```\r\n\r\n### Example 3\r\n```bash\r\nInput: s = \"(]\"\r\nOutput: false\r\n```\r\n\r\n### Constraints:\r\n\r\n-      1 <= s.length <= 104     \r\n-      s consists of parentheses only '()[]{}'.","basename":"valid-parentheses"},"validate-binary-search-tree":{"title":"Validate Binary Search Tree","description":"Given the root of a binary tree, determine if it is a valid binary search tree (BST).","tags":["medium","binary-tree"],"link":"https://leetcode.com/problems/validate-binary-search-tree/","images":["https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg","https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg"],"preview":"### Description\r\n\r\nGiven the root of a binary tree, determine if it is a valid binary search tree (BST).\r\n\r\nA valid BST is defined as follows:\r\n\r\n- The left subtree of a node contains only nodes with keys less than the node's key.\r\n- The right subtree of a node contains only nodes with keys greater than the node's key.\r\n- Both the left and right subtrees must also be binary search trees.\r\n\r\n### Example 1\r\n\r\n![](https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg)\r\n\r\n```bash\r\nInput: root = [2,1,3]\r\nOutput: true\r\n```\r\n\r\n### Example 2\r\n\r\n![](https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg)\r\n\r\n```bash\r\nInput: root = [5,1,4,null,null,3,6]\r\nOutput: false\r\nExplanation: The root node's value is 5 but its right child's value is 4.\r\n```\r\n\r\n### Constraints:\r\n\r\n- The number of nodes in the tree is in the range [1, 104].\r\n- -2^31 <= Node.val <= 2^31 - 1","basename":"validate-binary-search-tree"},"walls-and-gates":{"title":"Walls and Gates","description":"Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should be filled with INF.","tags":["medium","graphs"],"link":"https://tenderleo.gitbooks.io/leetcode-solutions-/content/GoogleMedium/286.html","images":[],"preview":"### Description\r\n\r\nYou are given a m x n 2D grid initialized with these three possible values.\r\n\r\n-1 - A wall or an obstacle. 0 - A gate. INF - Infinity means an empty room. We use the value 231 - 1 = 2147483647 to represent INF as you may assume that the distance to a gate is less than 2147483647. Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should be filled with INF.\r\n\r\n### Example 1\r\n\r\n```bash\r\nINF  -1  0  INF\r\nINF INF INF  -1\r\nINF  -1 INF  -1\r\n  0  -1 INF INF\r\n```\r\nAfter running the function, the 2D grid should be:\r\n\r\n```bash\r\n  3  -1   0   1\r\n  2   2   1  -1\r\n  1  -1   2  -1\r\n  0  -1   3   4\r\n```\r\n\r\n### Constraints:\r\n\r\n- m == rooms.length\r\n- n == rooms[i].length","basename":"walls-and-gates"},"word-ladder":{"title":"Word Ladder","description":"Given two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.","tags":["hard","graphs"],"link":"https://leetcode.com/problems/word-ladder/","images":[],"preview":"### Description\r\n\r\nA transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\r\n\r\n- Every adjacent pair of words differs by a single letter.\r\n- Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList.\r\n- sk == endWord\r\n\r\n\r\nGiven two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.\r\n\r\n \r\n\r\n### Example 1\r\n\r\n```bash\r\nInput: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\r\nOutput: 5\r\nExplanation: One shortest transformation sequence is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> cog\", which is 5 words long.\r\n```\r\n\r\n### Example 2\r\n\r\n```bash\r\nInput: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\r\nOutput: 0\r\nExplanation: The endWord \"cog\" is not in wordList, therefore there is no valid transformation sequence.\r\n```\r\n\r\n### Constraints:\r\n\r\n- 1 <= beginWord.length <= 10\r\n- endWord.length == beginWord.length\r\n- 1 <= wordList.length <= 5000\r\n- wordList[i].length == beginWord.length\r\n- beginWord, endWord, and wordList[i] consist of lowercase English letters.\r\n- beginWord != endWord\r\n- All the words in wordList are unique.","basename":"word-ladder"},"word-search-ii":{"title":"Word Search II","description":"Given an m x n board of characters and a list of strings words, return all words on the board.","tags":["hard","trie"],"link":"https://leetcode.com/problems/word-search-ii/","images":[],"preview":"### Description\r\n\r\nGiven an m x n board of characters and a list of strings words, return all words on the board.\r\n\r\nEach word must be constructed from letters of sequentially adjacent cells, where **adjacent cells** are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.\r\n\r\n### Example 1\r\n\r\n![](https://assets.leetcode.com/uploads/2020/11/07/search1.jpg)\r\n\r\n```bash\r\nInput: board = [[\"o\",\"a\",\"a\",\"n\"],[\"e\",\"t\",\"a\",\"e\"],[\"i\",\"h\",\"k\",\"r\"],[\"i\",\"f\",\"l\",\"v\"]], words = [\"oath\",\"pea\",\"eat\",\"rain\"]\r\nOutput: [\"eat\",\"oath\"]\r\n```\r\n\r\n### Example 2\r\n\r\n![](https://assets.leetcode.com/uploads/2020/11/07/search2.jpg)\r\n\r\n\r\n```bash\r\nInput: board = [[\"a\",\"b\"],[\"c\",\"d\"]], words = [\"abcb\"]\r\nOutput: []\r\n```\r\n\r\n### Constraints:\r\n\r\n- m == board.length\r\n- n == board[i].length\r\n- 1 <= m, n <= 12\r\n- board[i][j] is a lowercase English letter.\r\n- 1 <= words.length <= 3 * 10^4\r\n- 1 <= words[i].length <= 10\r\n- words[i] consists of lowercase English letters.\r\n- All the strings of `words` are unique.","basename":"word-search-ii"},"word-search":{"title":"Word Search","description":"Given an m x n grid of characters board and a string word, return true if word exists in the grid.","tags":[],"link":"https://leetcode.com/problems/word-search/","images":[],"preview":"### Description\r\n\r\nGiven an `m x n` grid of characters `board` and a string `word`, return `true` if word exists in the grid.\r\nThe word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.\r\n\r\n### Example 1\r\n\r\n![](https://assets.leetcode.com/uploads/2020/11/04/word2.jpg)\r\n\r\n```bash\r\nInput: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"\r\nOutput: true\r\n```\r\n\r\n### Example 2\r\n\r\n![](https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg)\r\n\r\n```bash\r\nInput: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"SEE\"\r\nOutput: true\r\n```\r\n\r\n### Example 3\r\n\r\n![](https://assets.leetcode.com/uploads/2020/10/15/word3.jpg)\r\n\r\n```bash\r\nInput: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCB\"\r\nOutput: false\r\n```\r\n\r\n### Constraints:\r\n\r\n- m == board.length \r\n- n = board[i].length \r\n- 1 <= m, n <= 6 \r\n- 1 <= word.length <= 15 \r\n- board and word consists of only lowercase and uppercase English letters.","basename":"word-search"}}