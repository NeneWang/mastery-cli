{"01-matrix":{"title":"01 Matrix","description":"Given an m x n binary matrix mat, return the distance of the nearest 0 for each cell. The distance between two adjacent cells is 1.","tags":["medium","graph","bfs"],"link":"https://leetcode.com/problems/01-matrix/","images":[],"preview":"### Description\n\nGiven an m x n binary matrix mat, return the distance of the nearest 0 for each cell.\n\nThe distance between two adjacent cells is 1.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2021/04/24/01-1-grid.jpg)\n\n```bash\nInput: mat = [[0,0,0],[0,1,0],[0,0,0]]\nOutput: [[0,0,0],[0,1,0],[0,0,0]]\n```\n\n### Example 2\n\n![](https://assets.leetcode.com/uploads/2021/04/24/01-2-grid.jpg)\n\n```bash\nInput: mat = [[0,0,0],[0,1,0],[1,1,1]]\nOutput: [[0,0,0],[0,1,0],[1,2,1]]\n```\n\n### Constraints:\n\n- m == mat.length\n- n == mat[i].length\n- 1 <= m, n <= 104\n- 1 <= m * n <= 104\n- mat[i][j] is either 0 or 1.\n- There is at least one 0 in mat.","basename":"01-matrix"},"4-keys-keyboard":{"title":"4 Keys Keyboard","description":"Given an integer n, return the maximum number of 'A' you can print on the screen with at most n presses on the keys.","tags":["medium","dp","general-1d"],"link":"https://leetcode.com/problems/4-keys-keyboard","images":[],"preview":"### Description\n\nImagine you have a special keyboard with the following keys:\n\n- A: Print one 'A' on the screen.\n- Ctrl-A: Select the whole screen.\n- Ctrl-C: Copy selection to buffer.\n- Ctrl-V: Print buffer on screen appending it after what has already been printed.\n\nGiven an integer n, return the maximum number of 'A' you can print on the screen with at most n presses on the keys.\n\n\n\n### Example 1\n\n```bash\nInput: n = 3\nOutput: 3\nExplanation: We can at most get 3 A's on screen by pressing the following key sequence:\nA, A, A\n```\n\n### Example 2\n\n```bash\nInput: n = 7\nOutput: 9\nExplanation: We can at most get 9 A's on screen by pressing following key sequence:\nA, A, A, Ctrl A, Ctrl C, Ctrl V, Ctrl V\n```\n\n### Constraints:\n\n- 1 <= n <= 50","basename":"4-keys-keyboard"},"a-star-search":{"title":"A Star Search","description":"AI Search Problem","tags":["medium","search","ai"],"preview":"### Description\n\nA* Search is a graph search algorithm that is often used in pathfinding and graph traversal, which is the process of visiting (checking and/or updating) each vertex in a graph. It enjoys widespread use due to its performance and accuracy. It is one of the best and popular techniques used in path-finding and graph traversals.\n\n\n### Example 1\n\n\nGiven: \n\n```js\n\n        //   A____B____C\n        //   |\\   |   /\n        //   | \\  |  /\n        //   |  \\ | /\n        //   D___\\E\n        //   |\\  |\n        //   | \\ |\n        //   |__\\|\n        //   F    G\n\n        const A = new Node('A', 0, 2);\n        const B = new Node('B', 1, 2);\n        const C = new Node('C', 2, 2);\n        const D = new Node('D', 0, 1);\n        const E = new Node('E', 1, 1);\n        const G = new Node('G', 0, 0);\n        const F = new Node('F', 1, 0);\n\n        const graph = new Graph();\n        graph.addEdge(A, B);\n        graph.addEdge(A, D);\n        graph.addEdge(B, C);\n        graph.addEdge(B, E);\n        graph.addEdge(C, E);\n        graph.addEdge(D, G);\n        graph.addEdge(D, F);\n        graph.addEdge(D, E);\n        graph.addEdge(E, G);\n        graph.addEdge(G, G);\n\n        const nodes = { A, B, C, D, E, G, F };\n        return { graph: graph, nodes: nodes };\n```\n\nShould be able to find it in 3 steps\n\n```js\nassert.equal(results.path.length, 3);\n        assert.equal(results.path[0], start);\n        assert.equal(results.path[2], goal);\n```","basename":"a-star-search"},"accounts-merge":{"title":"Accounts Merge","description":"After merging the accounts, return the accounts in the following format - the first element of each account is the name, and the rest of the elements are emails in sorted order. The accounts themselves can be returned in any order.","tags":["medium","graph","dfs"],"link":"https://leetcode.com/problems/accounts-merge","images":[],"preview":"### Description\n\nGiven a list of accounts where each element accounts[i] is a list of strings, where the first element accounts[i][0] is a name, and the rest of the elements are emails representing emails of the account.\n\nNow, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some common email to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name.\n\nAfter merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails in sorted order. The accounts themselves can be returned in any order.\n\n### Example 1\n\n```bash\nInput: accounts = [[\"John\",\"johnsmith@mail.com\",\"john_newyork@mail.com\"],[\"John\",\"johnsmith@mail.com\",\"john00@mail.com\"],[\"Mary\",\"mary@mail.com\"],[\"John\",\"johnnybravo@mail.com\"]]\nOutput: [[\"John\",\"john00@mail.com\",\"john_newyork@mail.com\",\"johnsmith@mail.com\"],[\"Mary\",\"mary@mail.com\"],[\"John\",\"johnnybravo@mail.com\"]]\nExplanation:\nThe first and second John's are the same person as they have the common email \"johnsmith@mail.com\".\nThe third John and Mary are different people as none of their email addresses are used by other accounts.\nWe could return these lists in any order, for example the answer [['Mary', 'mary@mail.com'], ['John', 'johnnybravo@mail.com'], \n['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com']] would still be accepted.\n```\n\n### Example 2\n\n```bash\nInput: accounts = [[\"Gabe\",\"Gabe0@m.co\",\"Gabe3@m.co\",\"Gabe1@m.co\"],[\"Kevin\",\"Kevin3@m.co\",\"Kevin5@m.co\",\"Kevin0@m.co\"],[\"Ethan\",\"Ethan5@m.co\",\"Ethan4@m.co\",\"Ethan0@m.co\"],[\"Hanzo\",\"Hanzo3@m.co\",\"Hanzo1@m.co\",\"Hanzo0@m.co\"],[\"Fern\",\"Fern5@m.co\",\"Fern1@m.co\",\"Fern0@m.co\"]]\nOutput: [[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]\n```\n\n### Constraints:\n\n- 1 <= accounts.length <= 1000\n- 2 <= accounts[i].length <= 10\n- 1 <= accounts[i][j].length <= 30\n- accounts[i][0] consists of English letters.\n- accounts[i][j] (for j > 0) is a valid email.","basename":"accounts-merge"},"add-binary":{"title":"Add Binary","description":"Given two binary strings a and b, return their sum as a binary string.","tags":["easy","math"],"link":"https://leetcode.com/problems/add-binary","images":[],"preview":"### Description\n\nGiven two binary strings a and b, return their sum as a binary string.\n\n### Example 1\n\n```bash\nInput: a = \"11\", b = \"1\"\nOutput: \"100\"\n```\n\n### Example 2\n\n```bash\nInput: a = \"1010\", b = \"1011\"\nOutput: \"10101\"\n```\n\n### Constraints:\n\n- 1 <= a.length, b.length <= 104\n- a and b consist only of '0' or '1' characters.\n- Each string does not contain leading zeros except for the zero itself.","basename":"add-binary"},"add-two-numbers":{"title":"Add Two Numbers","description":"You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.","tags":["neetcode","medium","linked-list"],"link":"https://leetcode.com/problems/add-two-numbers/","images":["https://assets.leetcode.com/uploads/2020/10/02/addtwonumber1.jpg"],"preview":"### Description\n\nYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\n\n\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2020/10/02/addtwonumber1.jpg)\n\n```bash\nInput: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.\n```\n\n### Example 2\n\n```bash\nInput: l1 = [0], l2 = [0]\nOutput: [0]\n```\n\n### Example 3\n\n```bash\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]\n```\n\n### Constraints:\n\n- The number of nodes in each linked list is in the range [1, 100]. \n- 0 <= Node.val <= 9 \n- It is guaranteed that the list represents a number that does not have leading zeros.","basename":"add-two-numbers"},"alien-dictionary":{"title":"Alien Dictionary","description":"Otherwise, return a string of the unique letters in the new alien language sorted in lexicographically increasing order by the new language's rules. If there are multiple solutions, return any of them.","tags":["hard","graph","topological-sort"],"link":"https://leetcode.com/problems/alien-dictionary/","images":[],"preview":"### Description\n\nThere is a new alien language that uses the English alphabet. However, the order of the letters is unknown to you.\n\nYou are given a list of strings words from the alien language's dictionary. Now it is claimed that the strings in words are sorted lexicographically by the rules of this new language.\n\nIf this claim is incorrect, and the given arrangement of string in words cannot correspond to any order of letters, return \"\".\n\nOtherwise, return a string of the unique letters in the new alien language sorted in lexicographically increasing order by the new language's rulesw. If there are multiple solutions, return any of them.\n\n\n### Example 1\n\n```bash\nInput: words = [\"wrt\",\"wrf\",\"er\",\"ett\",\"rftt\"]\nOutput: \"wertf\"\n```\n\n### Example 2\n\n```bash\nInput: words = [\"z\",\"x\"]\nOutput: \"zx\"\n```\n\n### Example 3\n\n```bash\nInput: words = [\"z\",\"x\",\"z\"]\nOutput: \"\"\nExplanation: The order is invalid, so return \"\".\n```\n\n### Constraints:\n\n- 1 <= words.length <= 100\n- 1 <= words[i].length <= 100\n- words[i] consists of only lowercase English letters.","basename":"alien-dictionary"},"all-paths-from-source-to-target":{"title":"All Paths From Source to Target","description":"The graph is given as follows - graph[i] is a list of all nodes you can visit from node i (i.e., there is a directed edge from node i to node graph[i][j]).","tags":["medium","graph","dfs"],"link":"https://leetcode.com/problems/all-paths-from-source-to-target","images":[],"preview":"### Description\n\nGiven a directed acyclic graph (DAG) of n nodes labeled from 0 to n - 1, find all possible paths from node 0 to node n - 1 and return them in any order.\n\nThe graph is given as follows: graph[i] is a list of all nodes you can visit from node i (i.e., there is a directed edge from node i to node graph[i][j]).\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2020/09/28/all_1.jpg)\n\n```bash\nInput: graph = [[1,2],[3],[3],[]]\nOutput: [[0,1,3],[0,2,3]]\nExplanation: There are two paths: 0 -> 1 -> 3 and 0 -> 2 -> 3.\n```\n\n### Example 2\n\n![](https://assets.leetcode.com/uploads/2020/09/28/all_2.jpg)\n\n```bash\nInput: graph = [[4,3,1],[3,2,4],[3],[4],[]]\nOutput: [[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]\n```\n\n### Constraints:\n\n- n == graph.length\n- 2 <= n <= 15\n- 0 <= graph[i][j] < n\n- graph[i][j] != i (i.e., there will be no self-loops).\n- All the elements of graph[i] are unique.\n- The input graph is guaranteed to be a DAG.","basename":"all-paths-from-source-to-target"},"all-possible-full-binary-trees":{"title":"All Possible Full Binary Trees","description":"Each element of the answer is the root node of one possible tree. You may return the final list of trees in any order.","tags":["medium","grand-dp","on-tree"],"link":"https://leetcode.com/problems/all-possible-full-binary-trees","images":[],"preview":"### Description\n\nGiven an integer n, return a list of all possible full binary trees with n nodes. Each node of each tree in the answer must have Node.val == 0.\n\nEach element of the answer is the root node of one possible tree. You may return the final list of trees in any order.\n\nA full binary tree is a binary tree where each node has exactly 0 or 2 children.\n\n \n\n### Example 1\n\n![](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/22/fivetrees.png)\n\n```bash\nInput: n = 7\nOutput: [[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]]\n```\n\n### Example 2\n\n```bash\nInput: n = 3\nOutput: [[0,0,0]]\n```\n\n### Constraints:\n\n- 1 <= n <= 20","basename":"all-possible-full-binary-trees"},"ambiguous-measurements":{"title":"Ambiguous Measurements","tags":["hard","algoexpert"],"preview":"# Ambiguous Measurements\n\nThis problem deals with measuring cups that are missing important measuring labels. Specifically, a measuring cup only has two measuring lines, a Low (L) line and a High (H) line. This means that these cups can't precisely measure and can only guarantee that the substance poured into them will be between the L and H line. For example, you might have a measuring cup that has a Low line at 400ml and a high line at 435ml. This means that when you use this measuring cup, you can only be sure that what you're measuring is between 400ml and 435ml.\n\nYou're given a list of measuring cups containing their low and high lines as well as one low integer and one high integer representing a range for a target measurement. Write a function that returns a boolean representing whether you can use the cups to accurately measure a volume in the specified [low, high] range (the range is inclusive).\n\nNote that:\n\n   - Each measuring cup will be represented by a pair of positive integers [L, H], where 0 <= L <= H.\n   - You'll always be given at least one measuring cup, and the low and high input parameters will always satisfy the following constraint: 0 <= low <= high.\n   - Once you've measured some liquid, it will immediately be transferred to a larger bowl that will eventually (possibly) contain the target measurement.\n   - You can't pour the contents of one measuring cup into another cup.\n\n## Sample Input\n\n``` \nmeasuringCups = [\n  [200, 210],\n  [450, 465],\n  [800, 850],\n] \nlow = 2100\nhigh = 2300\n```\n\n## Sample Output\n\n``` \ntrue\n// We use cup [450, 465] to measure four volumes:\n// First measurement: Low = 450, High = 465\n// Second measurement: Low = 450 + 450 = 900, High = 465 + 465 = 930\n// Third measurement: Low = 900 + 450 = 1350, High = 930 + 465 = 1395\n// Fourth measurement: Low = 1350 + 450 = 1800, High = 1395 + 465 = 1860\n\n// Then we use cup [200, 210] to measure two volumes:\n// Fifth measurement: Low = 1800 + 200 = 2000, High = 1860 + 210 = 2070\n// Sixth measurement: Low = 2000 + 200 = 2200, High = 2070 + 210 = 2280\n\n// We've measured a volume in the range [2200, 2280].\n// This is within our target range, so we return `true`.\n\n// Note: there are other ways to measure a volume in the target range.\n```\n\n### Hints\n\nHint 1\n> Start by considering the last cup that you'll use in your sequence of measurements. If it isn't possible to use any of the cups as the last cup, then you can't measure the desired volume.\n\nHint 2\n> If the cup that you're going to use last has a measuring range of [100, 110] and you want to measure in the range of [500, 550], then after you pick this cup as the last cup, you need to measure a range of [400, 440]. Now, you can simply pick the last cup you'll use to measure this new range. If you continue these steps, you'll eventually know if you're able to measure the entire range or not.\n\nHint 3\n> Hint #2 should give you an idea of how to solve this problem recursively. Try every cup as the last cup for the starting range, then recursively try to measure the new ranges created after using the selected last cups. If you ever reach a point where one cup can measure the entire range, then you're finished and you can measure the target range. Try to think of a way to optimize this recursive approach, since it might involve a lot of repeated calculations.\n\n```\nOptimal Space & Time Complexity\nO(low * high * n) time | O(low * high) space - where n is the number of measuring cups\n```\n\n![solution](image.png)\n\n### Notes\n\nAs we recursively call our canMeasureInRange function, we might realize that if the input low is ever less than or equal to 0, the outcome for that low is always the same.\n\nIn other words, checking if we can measure in the range [-10, 10] is equivalent to checking if we can measure in the range [-5, 10], which itself is equivalent to checking if we can measure in the range [0, 10].\n\nThe same logic applies to the high value.\n\nThus, we can optimize the solution described in the video explanation by capping the low and high values that we pass to our canMeasureInRange function to 0. This reduces the number of keys in our cache and maximizes cache hits, thereby optimizing our solution in practice (though not from a time-complexity point of view).\n\nThe two comments in the code snippet below highlight the changes that we've made to the code covered in the video explanation.\n\n``` \n// Change `<` to `<=`.\nif low <= 0 and high <= 0:\n    return False\n\ncanMeasure = False\nfor cup in measuringCups:\n    cupLow, cupHigh = cup\n    if low <= cupLow and cupHigh <= high:\n        canMeasure = True\n        break\n\n    // Cap the `newLow` and `newHigh` to 0.\n    newLow = max(0, low - cupLow)\n    newHigh = max(0, high - cupHigh)\n    canMeasure = canMeasureInRange(measuringCups, newLow, newHigh, memoization)\n    if canMeasure:\n        break\n```","basename":"ambiguous-measurements"},"average-of-levels-in-binary-tree":{"title":"Average of Levels in Binary Tree","description":"Given the root of a binary tree, return the average value of the nodes on each level in the form of an array. Answers within 10-5 of the actual answer will be accepted.","tags":["easy","binary-tree"],"link":null,"images":[],"preview":"### Description\n\n![](https://assets.leetcode.com/uploads/2021/03/09/avg1-tree.jpg)\n\n### Example 1\n\n```bash\nInput: root = [3,9,20,null,null,15,7]\nOutput: [3.00000,14.50000,11.00000]\nExplanation: The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11.\nHence return [3, 14.5, 11].\n```\n\n### Example 2\n\n![](https://assets.leetcode.com/uploads/2021/03/09/avg2-tree.jpg)\n\n```bash\nInput: root = [3,9,20,15,7]\nOutput: [3.00000,14.50000,11.00000]\n```\n\n### Constraints:\n\n- The number of nodes in the tree is in the range [1, 104].\n- -231 <= Node.val <= 231 - 1","basename":"average-of-levels-in-binary-tree"},"balance-a-binary-search-tree":{"title":"Balance a Binary Search Tree","description":"Balance a Binary Search Tree","tags":["medium","tree"],"link":"https://leetcode.com/problems/balance-a-binary-search-tree/","images":[],"preview":"### Description\n\nGiven the root of a binary search tree, return a balanced binary search tree with the same node values. If there is more than one answer, return any of them.\n\nA binary search tree is balanced if the depth of the two subtrees of every node never differs by more than `1`.\n\n### Example 1\n\n\n![](https://assets.leetcode.com/uploads/2021/08/10/balance1-tree.jpg)\n\n```bash\nInput: root = [1,null,2,null,3,null,4,null,null]\nOutput: [2,1,3,null,null,null,4]\nExplanation: This is not the only correct answer, [3,1,4,null,2] is also correct.\n```\n\n### Example 2\n\n![](https://assets.leetcode.com/uploads/2021/08/10/balanced2-tree.jpg)\n\n```bash\nInput: root = [2,1,3]\nOutput: [2,1,3]\n```\n\n### Constraints:\n\n- The number of nodes in the tree is in the range [1, 104].\n- 1 <= Node.val <= 105","basename":"balance-a-binary-search-tree"},"balanced-binary-tree":{"title":"Balanced Binary Tree","description":"Given a binary tree, determine if it is height-balanced.","tags":["neetcode","easy","binary-tree"],"link":"https://leetcode.com/problems/balanced-binary-tree/","images":["https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg"],"preview":"### Description\n\nGiven a binary tree, determine if it is height-balanced.\n\n### Example 1\n\n\n![](https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg)\n\n```bash\nInput: root = [3,9,20,null,null,15,7]\nOutput: true\n```\n\n### Example 2\n\n![](https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg)\n\n```bash\nInput: root = [1,2,2,3,3,null,null,4,4]\nOutput: false\n```\n\n### Example 3\n\n```bash\nInput: root = []\nOutput: true\n```\n\n### Constraints:\n\n- The number of nodes in the tree is in the range [0, 5000]. \n- -10^4 <= Node.val <= 10^4","basename":"balanced-binary-tree"},"basic-calculator":{"title":"Basic Calculator","description":"Given a string s representing a valid expression, implement a basic calculator to evaluate it, and return the result of the evaluation.","tags":["hard","stack"],"link":"https://leetcode.com/problems/basic-calculator","images":[],"preview":"### Description\n\nGiven a string s representing a valid expression, implement a basic calculator to evaluate it, and return the result of the evaluation.\n\nNote: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval().\n\n \n\n### Example 1\n\n```bash\nInput: s = \"1 + 1\"\nOutput: 2\n```\n\n### Example 2\n\n```bash\nInput: s = \" 2-1 + 2 \"\nOutput: 3\n```\n\n### Constraints:\n\n- 1 <= s.length <= 3 * 105\n- s consists of digits, '+', '-', '(', ')', and ' '.\n- s represents a valid expression.\n- '+' is not used as a unary operation (i.e., \"+1\" and \"\n- (2 + 3)\" is invalid).\n- '-' could be used as a unary operation (i.e., \"-1\" and \"-(2 + 3)\" is valid).\n- There will be no two consecutive operators in the input.\n- Every number and running calculation will fit in a signed 32-bit integer.","basename":"basic-calculator"},"battle-of-two-chess-roocks":{"title":"Battle of Two Chess Rooks","description":null,"tags":["medium","ai-search"],"link":"","images":[],"preview":"### Description\n\nGiven a simplified 4x4 chess board with only two rooks (one for each player) placed at random positions, you need to determine the minimum number of moves required for player A to capture player B's rook, considering that player B will try to avoid being captured.\n\nRooks can move any number of squares horizontally or vertically, but not diagonally. They capture an opponent's piece by moving to its square. Both players will make optimal moves.\n\nYou are provided with the coordinates of both rooks. Determine the minimum number of moves required for player A's rook to capture player B's rook.\n\nplayerA (0-indexed array): An array of two integers, [row, col], representing the position of player A's rook (0 <= row, col <= 3).\nplayerB (0-indexed array): An array of two integers, [row, col], representing the position of player B's rook (0 <= row, col <= 3).\n\n```js\nfunction min_moves_to_capture_adversarial(playerA, playerB) {\n    // ...\n}\n\n```\n\nOutput:\n\nReturn an integer representing the minimum number of moves required for player A's rook to capture player B's rook.\n\n\n### Example 1\n\n```bash\nconsole.log(min_moves_to_capture_adversarial([0, 0], [1, 0])); // Output: 3\nconsole.log(min_moves_to_capture_adversarial([0, 0], [1, 1])); // Output: 4\nconsole.log(min_moves_to_capture_adversarial([0, 1], [2, 3])); // Output: 4\n\n```\nExplanation: Player A's rook can directly move one step down to capture player B's rook.\n\n### Example 2\n\n\n```bash\nInput: [[0, 0], [3, 3]]\nExpected Output: 5\n\nA . . .\n. . . .\n. . . .\n. . . B\n\n```\n\nPlayer A's rook is at the top-left corner (0, 0), and player B's rook is at the bottom-right corner (3, 3). They are not on the same row or column, and their positions are not neighboring rows or columns.\n\nOptimal moves:\n\nPlayer A moves the rook to (1, 0) or (0, 1).\nPlayer B moves the rook to avoid capture.\nPlayer A moves the rook to block player B's rook (either on the same row or column).\nPlayer B moves the rook to avoid capture again.\nPlayer A captures player B's rook.\nMinimum moves needed: 5\n\n\n### Example 3\n\n```bash\nInput: [[2, 2], [0, 0]]\nExpected Output: 5\n```\n\n```bash\nB . . .\n. . . .\n. . A .\n. . . .\n\n```\n\nPlayer A's rook is in the middle of the board (2, 2), and player B's rook is at the top-left corner (0, 0). They are not on the same row or column, and their positions are not neighboring rows or columns.\n\nOptimal moves:\n\nPlayer A moves the rook to (1, 2) or (2, 1).\nPlayer B moves the rook to avoid capture.\nPlayer A moves the rook to block player B's rook (either on the same row or column).\nPlayer B moves the rook to avoid capture again.\nPlayer A captures player B's rook.\n\n### Solution\n\n```js\nfunction min_moves_to_capture_adversarial(playerA, playerB) {\n    const [rowA, colA] = playerA;\n    const [rowB, colB] = playerB;\n\n    // If the rooks are on the same row or same column, player A needs 3 moves\n    if (rowA === rowB || colA === colB) {\n        return 3;\n    }\n\n    // If the rooks are on neighboring rows or columns, player A needs 4 moves\n    if (Math.abs(rowA - rowB) <= 1 || Math.abs(colA - colB) <= 1) {\n        return 4;\n    }\n\n    // In other cases, player A needs at least 5 moves\n    return 5;\n}\n\n// Test cases\nconsole.log(min_moves_to_capture_adversarial([0, 0], [1, 0])); // Output: 3\nconsole.log(min_moves_to_capture_adversarial([0, 0], [1, 1])); // Output: 4\nconsole.log(min_moves_to_capture_adversarial([0, 1], [2, 3])); // Output: 5\n\n```\n\nconst root_1 = new TreeNode(\n    7,\n    new TreeNode(3, new TreeNode(6), new TreeNode(1)),\n    new TreeNode(5, new TreeNode(4), new TreeNode(2))\n);\nconsole.log(optimalPlay(root_1)); // Output: [12, 4]","basename":"battle-of-two-chess-roocks"},"beam-search":{"title":"beam search","description":"AI Search Problem","tags":["medium","search","ai"],"preview":"### Description\n\nIntroduction :\nA heuristic technique is a set of criteria for determining which of multiple options will be the most effective in achieving a particular goal. This strategy increases the efficiency of a search process by surrendering claims of systematic and completeness of the best.\nWe can hope to achieve a good solution to difficult problems (such as the traveling salesman problem) in less than exponent time if we use appropriate heuristics. \n\n\n### Example 1\n\nSample Graph\n\nGiven: \n\n```js\n\n        //   A____B____C\n        //   |   |   /\n        //   |   |  /\n        //   |   | /\n        //   D___E\n        //   |\\  |\n        //   | \\ |\n        //   |__\\|\n        //   F    G\n\n        const A = new Node('A', 0, 2);\n        const B = new Node('B', 1, 2);\n        const C = new Node('C', 2, 2);\n        const D = new Node('D', 0, 1);\n        const E = new Node('E', 1, 1);\n        const G = new Node('G', 0, 0);\n        const F = new Node('F', 1, 0);\n\n        const graph = new Graph();\n        graph.addEdge(A, B);\n        graph.addEdge(A, D);\n        graph.addEdge(B, C);\n        graph.addEdge(B, E);\n        graph.addEdge(C, E);\n        graph.addEdge(D, G);\n        graph.addEdge(D, F);\n        graph.addEdge(D, E);\n        graph.addEdge(D,  G);\n        graph.addEdge(E, G);\n        graph.addEdge(G, G);\n\n        const nodes = { A, B, C, D, E, G, F };\n        return { graph: graph, nodes: nodes };\n```\n\nShould be able to find it it using Beam Search.\n\nTraversal:\n\n```js\n______________________________________________\nResults from create_graph_5, Beam Search\n\nexploring current level: A\nexploring current level: D, B\nexploring current level: G, F, E //Note how g goes first.\n{\n  path: [\n    Node { id: 'A', x: 0, y: 2, heuristic: 2 },\n    Node { id: 'D', x: 0, y: 1, heuristic: 1 },\n    Node { id: 'G', x: 0, y: 0, heuristic: 0 }\n  ],\n  cost: 4,\n  count_searches: 4,\n  formatted_path: 'A -> D -> G',\n  exploration_path: [\n    Node { id: 'A', x: 0, y: 2, heuristic: 2 },\n    Node { id: 'D', x: 0, y: 1, heuristic: 1 },\n    Node { id: 'B', x: 1, y: 2, heuristic: 3 },\n    Node { id: 'G', x: 0, y: 0, heuristic: 0 }\n  ],\n  queue_snapshot: [\n    [ { '0': Node { id: 'A', x: 0, y: 2, heuristic: 2 } } ],\n    [\n      {\n        '0': Node { id: 'D', x: 0, y: 1, heuristic: 1 },\n        '1': Node { id: 'B', x: 1, y: 2, heuristic: 3 }\n      }\n    ],\n    [\n      {\n        '0': Node { id: 'G', x: 0, y: 0, heuristic: 0 },\n        '1': Node { id: 'F', x: 1, y: 0 },\n        '2': Node { id: 'E', x: 1, y: 1 }\n      }\n    ]\n  ]\n}\n```\n\n\n### t_graph_1\n\n```js\n        /**  \n        A----B\n       |  \\ | \\\n       D   \\|  H\n       |  \\ | /|\n       |    C  |\n        \\    \\ G\n         \\    /\n          \\  /\n           E\n           |\n           F\n         */\n\n\n        const A = new Node('A', 0, 1);\n        const B = new Node('B', 2, 1);\n        const C = new Node('C', 2, -1);\n        const D = new Node('D', 0, 0);\n        const E = new Node('E', 1, -5);\n        const F = new Node('F', 1, -6);\n        const G = new Node('G', 3, -2);\n        const H = new Node('H', 3, 0);\n\n        const nodes = { A, B, C, D, E, F, G, H };\n\n\n        const graph = new BidirectionalGraph();\n        graph.addEdge(A, B);\n        graph.addEdge(A, D);\n        graph.addEdge(A, C);\n        graph.addEdge(B, C);\n        graph.addEdge(B, H);\n        graph.addEdge(C, H);\n        graph.addEdge(C, G);\n        graph.addEdge(C, D);\n        graph.addEdge(D, E);\n        graph.addEdge(D, G);\n        graph.addEdge(E, G);\n        graph.addEdge(E, F);\n```\n\n```js\nexploring current level: A\nexploring current level: C, D, B // note how C is first, as it has the lowest heuristic.\nexploring current level: E, G, H // Note how e is first., then g, then H.\nexploring current level: F\n______________________________________________\nResults from t_graph_1, Beam Search\n{\n  path: [\n    Node { id: 'A', x: 0, y: 1, heuristic: 8 },\n    Node { id: 'D', x: 0, y: 0, heuristic: 7 },\n    Node { id: 'E', x: 1, y: -5, heuristic: 1 },\n    Node { id: 'F', x: 1, y: -6, heuristic: 0 }\n  ],\n  cost: 8,\n  count_searches: 8,\n  formatted_path: 'A -> D -> E -> F',\n  exploration_path: [\n    Node { id: 'A', x: 0, y: 1, heuristic: 8 },\n    Node { id: 'C', x: 2, y: -1, heuristic: 6 },\n    Node { id: 'D', x: 0, y: 0, heuristic: 7 },\n    Node { id: 'B', x: 2, y: 1, heuristic: 8 },\n    Node { id: 'E', x: 1, y: -5, heuristic: 1 },\n    Node { id: 'G', x: 3, y: -2, heuristic: 6 },\n    Node { id: 'H', x: 3, y: 0, heuristic: 8 },\n    Node { id: 'F', x: 1, y: -6, heuristic: 0 }\n  ],\n  queue_snapshot: [\n    [ { '0': Node { id: 'A', x: 0, y: 1, heuristic: 8 } } ],\n    [\n      {\n        '0': Node { id: 'C', x: 2, y: -1, heuristic: 6 },\n        '1': Node { id: 'D', x: 0, y: 0, heuristic: 7 },\n        '2': Node { id: 'B', x: 2, y: 1, heuristic: 8 }\n      }\n    ],\n    [\n      {\n        '0': Node { id: 'E', x: 1, y: -5, heuristic: 1 },\n        '1': Node { id: 'G', x: 3, y: -2, heuristic: 6 },\n        '2': Node { id: 'H', x: 3, y: 0, heuristic: 8 }\n      }\n    ],\n    [ { '0': Node { id: 'F', x: 1, y: -6, heuristic: 0 } } ]\n  ]\n}\n t_graph_1 Beam Search: 8\n```\n\n\n### Suprisingly for create_long_ass_graph \n\n- It shouldnt be able to find the response with k = 2\n- It should be able to find the response with k = 5\n\n\n\n```js width: 3\n______________________________________________\n\nResults from create_long_ass_graph Beam Search beam_width 3\n\nexploring current level: A\nexploring current level: B, C\nexploring current level: G, D, E\nexploring current level: K, H, N\nexploring current level: AC, V, W\nerror, neighbor is undefined\nerror, neighbor is undefined\nerror, neighbor is undefined\n```\n\nBut once we increase the beam:\n\nYou can also see how the level size increases.\n\n```js width: 5\nResults from create_long_ass_graph Beam Search beam_width 5\n\nexploring current level: A\nexploring current level: B, C\nexploring current level: G, D, E, F\nexploring current level: K, L, H, M, N\nexploring current level: AC, V, W, P, X\nerror, neighbor is undefined\nerror, neighbor is undefined\nerror, neighbor is undefined\nerror, neighbor is undefined\nexploring current level: AF, AG\n```\n\n\n\n```js width: 10\n______________________________________________\n\nResults from create_long_ass_graph Beam Search beam_width 10 \n\nexploring current level: A\nexploring current level: B, C\nexploring current level: G, D, E, F\nexploring current level: K, L, H, M, N, I, O, J\nexploring current level: AC, V, AD, W, P, AE, X, Q, Y, R\nerror, neighbor is undefined\nerror, neighbor is undefined\nerror, neighbor is undefined\nerror, neighbor is undefined\nerror, neighbor is undefined\nerror, neighbor is undefined\nerror, neighbor is undefined\nexploring current level: AK, AF, AG, AH, AI, AJ\nCount Searches: 26\n{\n  path: [\n    Node { id: 'A', x: 0, y: 0, heuristic: 16 },\n    Node { id: 'B', x: 1, y: -1, heuristic: 14 },\n    Node { id: 'D', x: 2, y: -2, heuristic: 12 },\n    Node { id: 'I', x: 3, y: 1, heuristic: 14 },\n    Node { id: 'R', x: 5, y: -1, heuristic: 10 },\n    Node { id: 'AK', x: 8, y: -8, heuristic: 0 }\n  ],\n  cost: 26,\n  count_searches: 26, // Total nodes is around 36. So it is still better than that.\n  formatted_path: 'A -> B -> D -> I -> R -> AK',\n  exploration_path: [\n    Node { id: 'A', x: 0, y: 0, heuristic: 16 },\n    Node { id: 'B', x: 1, y: -1, heuristic: 14 },\n    Node { id: 'C', x: 1, y: 1, heuristic: 16 },\n    Node { id: 'G', x: 3, y: -3, heuristic: 10 },\n    Node { id: 'D', x: 2, y: -2, heuristic: 12 },\n    Node { id: 'E', x: 2, y: 0, heuristic: 14 },\n    Node { id: 'F', x: 2, y: 2, heuristic: 16 },\n    Node { id: 'K', x: 4, y: -4, heuristic: 8 },\n    Node { id: 'L', x: 4, y: -2, heuristic: 10 },\n    Node { id: 'H', x: 3, y: -1, heuristic: 12 },\n    Node { id: 'M', x: 4, y: 0, heuristic: 12 },\n    Node { id: 'N', x: 4, y: 2, heuristic: 14 },\n    Node { id: 'I', x: 3, y: 1, heuristic: 14 },\n    Node { id: 'O', x: 4, y: 4, heuristic: 16 },\n    Node { id: 'J', x: 3, y: 3, heuristic: 16 },\n    Node { id: 'AC', x: 7, y: -7, heuristic: 2 },\n    Node { id: 'V', x: 6, y: -6, heuristic: 4 },\n    Node { id: 'AD', x: 7, y: -5, heuristic: 4 },\n    Node { id: 'W', x: 6, y: -4, heuristic: 6 },\n    Node { id: 'P', x: 5, y: -5, heuristic: 6 },\n    Node { id: 'AE', x: 7, y: -3, heuristic: 6 },\n    Node { id: 'X', x: 6, y: -2, heuristic: 8 },\n    Node { id: 'Q', x: 5, y: -3, heuristic: 8 },\n    Node { id: 'Y', x: 6, y: 0, heuristic: 10 },\n    Node { id: 'R', x: 5, y: -1, heuristic: 10 },\n    Node { id: 'AK', x: 8, y: -8, heuristic: 0 }\n  ],\n  queue_snapshot: [\n    [ { '0': Node { id: 'A', x: 0, y: 0, heuristic: 16 } } ],\n    [\n      {\n        '0': Node { id: 'B', x: 1, y: -1, heuristic: 14 },\n        '1': Node { id: 'C', x: 1, y: 1, heuristic: 16 }\n      }\n    ],\n    [\n      {\n        '0': Node { id: 'G', x: 3, y: -3, heuristic: 10 },\n        '1': Node { id: 'D', x: 2, y: -2, heuristic: 12 },\n        '2': Node { id: 'E', x: 2, y: 0, heuristic: 14 },\n        '3': Node { id: 'F', x: 2, y: 2, heuristic: 16 }\n      }\n    ],\n    [\n      {\n        '0': Node { id: 'K', x: 4, y: -4, heuristic: 8 },\n        '1': Node { id: 'L', x: 4, y: -2, heuristic: 10 },\n        '2': Node { id: 'H', x: 3, y: -1, heuristic: 12 },\n        '3': Node { id: 'M', x: 4, y: 0, heuristic: 12 },\n        '4': Node { id: 'N', x: 4, y: 2, heuristic: 14 },\n        '5': Node { id: 'I', x: 3, y: 1, heuristic: 14 },\n        '6': Node { id: 'O', x: 4, y: 4, heuristic: 16 },\n        '7': Node { id: 'J', x: 3, y: 3, heuristic: 16 }\n      }\n    ],\n    [\n      {\n        '0': Node { id: 'AC', x: 7, y: -7, heuristic: 2 },\n        '1': Node { id: 'V', x: 6, y: -6, heuristic: 4 },\n        '2': Node { id: 'AD', x: 7, y: -5, heuristic: 4 },\n        '3': Node { id: 'W', x: 6, y: -4, heuristic: 6 },\n        '4': Node { id: 'P', x: 5, y: -5, heuristic: 6 },\n        '5': Node { id: 'AE', x: 7, y: -3, heuristic: 6 },\n        '6': Node { id: 'X', x: 6, y: -2, heuristic: 8 },\n        '7': Node { id: 'Q', x: 5, y: -3, heuristic: 8 },\n        '8': Node { id: 'Y', x: 6, y: 0, heuristic: 10 },\n        '9': Node { id: 'R', x: 5, y: -1, heuristic: 10 }\n      }\n    ],\n    [\n      {\n        '0': Node { id: 'AK', x: 8, y: -8, heuristic: 0 },\n        '1': Node { id: 'AF', x: 7, y: -1 },\n        '2': Node { id: 'AG', x: 7, y: 1 },\n        '3': Node { id: 'AH', x: 7, y: 3 },\n        '4': Node { id: 'AI', x: 7, y: 5 },\n        '5': Node { id: 'AJ', x: 7, y: 7 }\n      }\n    ]\n  ]\n}\n```","basename":"beam-search"},"best-team-with-no-conflicts":{"title":"Best Team with No Conflicts","description":"Given two lists, scores and ages, where each scores[i] and ages[i] represents the score and age of the ith player, respectively, return the highest overall score of all possible basketball teams.","tags":["medium","grand-dp","knapsack"],"link":"https://leetcode.com/problems/best-team-with-no-conflicts","images":[],"preview":"### Description\n\nYou are the manager of a basketball team. For the upcoming tournament, you want to choose the team with the highest overall score. The score of the team is the sum of scores of all the players in the team.\n\nHowever, the basketball team is not allowed to have conflicts. A conflict exists if a younger player has a strictly higher score than an older player. A conflict does not occur between players of the same age.\n\nGiven two lists, scores and ages, where each scores[i] and ages[i] represents the score and age of the ith player, respectively, return the highest overall score of all possible basketball teams.\n\n### Example 1\n\n```bash\nInput: scores = [1,3,5,10,15], ages = [1,2,3,4,5]\nOutput: 34\nExplanation: You can choose all the players.\n```\n\n### Example 2\n\n```bash\nInput: scores = [4,5,6,5], ages = [2,1,2,1]\nOutput: 16\nExplanation: It is best to choose the last 3 players. Notice that you are allowed to choose multiple people of the same age.\n```\n\n### Constraints:\n\n- 1 <= scores.length, ages.length <= 1000\n- scores.length == ages.length\n- 1 <= scores[i] <= 106\n- 1 <= ages[i] <= 1000","basename":"best-team-with-no-conflicts"},"best-time-to-buy-and-sell-stock-ii":{"title":"Best Time to Buy and Sell Stock II","description":"You are given an integer array prices where prices[i] is the price of a given stock on the ith day.  On each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.  Find and return the maximum profit you can achieve.","tags":["array","medium"],"link":"https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/","preview":"### Description\n\nYou are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.\n\n### Example 1\n\n```bash\nInput: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\n```\n\n### Example 2\n\n```bash\nInput: prices = [1,2,3,4,5]\nOutput: 4\nExplanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nTotal profit is 4.\n```\n\n### Constraints:\n\n- 1 <= prices.length <= 3 * 10^4\n- 0 <= prices[i] <= 10^4\n\n\n### Hint\n\n![](https://wiki.anviltech.net/images/Tets.jpg)","basename":"best-time-to-buy-and-sell-stock-ii"},"best-time-to-buy-and-sell-stock-iii":{"title":"Best Time to Buy and Sell Stock III","description":"Find the maximum profit you can achieve. You may complete at most two transactions.","tags":["multi-dimensional-dp","hard"],"link":"https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii","images":[],"preview":"### Description\n\nYou are given an array prices where prices[i] is the price of a given stock on the ith day.\n\nFind the maximum profit you can achieve. You may complete at most two transactions.\n\nNote: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n\n \n\n### Example 1\n\n```bash\nInput: prices = [3,3,5,0,0,3,1,4]\nOutput: 6\nExplanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\nThen buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.\n```\n\n### Example 2\n\n```bash\nInput: prices = [1,2,3,4,5]\nOutput: 4\nExplanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nNote that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.\n```\n\n### Constraints:\n\n- 1 <= prices.length <= 105\n- 0 <= prices[i] <= 105","basename":"best-time-to-buy-and-sell-stock-iii"},"best-time-to-buy-and-sell-stock-iv":{"title":"Best Time to Buy and Sell Stock IV","description":"k times and sell at most k times.","tags":[],"link":null,"images":[],"preview":"### Description\n\nYou are given an integer array prices where prices[i] is the price of a given stock on the ith day, and an integer k.\n\nFind the maximum profit you can achieve. You may complete at most k transactions: i.e. you may buy at most k times and sell at most k times.\n\nNote: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n\n### Example 1\n\n```bash\nInput: k = 2, prices = [2,4,1]\nOutput: 2\nExplanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.\n```\n\n### Example 2\n\n```bash\nInput: k = 2, prices = [3,2,6,5,0,3]\nOutput: 7\nExplanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\n```\n\n### Constraints:\n\n-","basename":"best-time-to-buy-and-sell-stock-iv"},"best-time-to-buy-and-sell-stock-with-transaction-fee":{"title":"Best Time to Buy and Sell Stock with Transaction Fee","description":"Find the maximum profit you can achieve. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction.","tags":["medium","dp","state-machine"],"link":"https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee","images":[],"preview":"### Description\n\nYou are given an array prices where prices[i] is the price of a given stock on the ith day, and an integer fee representing a transaction fee.\n\nFind the maximum profit you can achieve. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction.\n\nNote:\n\nYou may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\nThe transaction fee is only charged once for each stock purchase and sale.\n\n### Example 1\n\n```bash\nInput: prices = [1,3,2,8,4,9], fee = 2\nOutput: 8\nExplanation: The maximum profit can be achieved by:\n- Buying at prices[0] = 1\n- Selling at prices[3] = 8\n- Buying at prices[4] = 4\n- Selling at prices[5] = 9\nThe total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.\n```\n\n### Example 2\n\n```bash\nInput: prices = [1,3,7,5,10,3], fee = 3\nOutput: 6\n```\n\n### Constraints:\n\n- 1 <= prices.length <= 5 * 104\n- 1 <= prices[i] < 5 * 104\n- 0 <= fee < 5 * 104","basename":"best-time-to-buy-and-sell-stock-with-transaction-fee"},"binary-search-tree-iterator":{"title":"Binary Search Tree Iterator","description":"Implement the BSTIterator class that represents an iterator over the in-order traversal of a binary search tree (BST)","tags":["binary-tree","medium"],"link":"https://leetcode.com/problems/binary-search-tree-iterator","images":[],"preview":"### Description\n\nImplement the BSTIterator class that represents an iterator over the in-order traversal of a binary search tree (BST):\n\nBSTIterator(TreeNode root) Initializes an object of the BSTIterator class. The root of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST.\nboolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false.\nint next() Moves the pointer to the right, then returns the number at the pointer.\nNotice that by initializing the pointer to a non-existent smallest number, the first call to next() will return the smallest element in the BST.\n\nYou may assume that next() calls will always be valid. That is, there will be at least a next number in the in-order traversal when next() is called.\n\n\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2018/12/25/bst-tree.png)\n\n```bash\nInput\n[\"BSTIterator\", \"next\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\"]\n[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]\nOutput\n[null, 3, 7, true, 9, true, 15, true, 20, false]\n\nExplanation\nBSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);\nbSTIterator.next();    // return 3\nbSTIterator.next();    // return 7\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 9\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 15\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 20\nbSTIterator.hasNext(); // return False\n```\n\n\n### Constraints:\n\n- The number of nodes in the tree is in the range [1, 105].\n- 0 <= Node.val <= 106\n- At most 105 calls will be made to hasNext, and next.","basename":"binary-search-tree-iterator"},"binary-search-tree-to-greater-sum-tree":{"title":"Binary Search Tree to Greater Sum Tree","description":"convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST.","tags":["medium","tree"],"link":"https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/description/","images":[],"preview":"### Description\n\nGiven the root of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST.\n\nAs a reminder, a binary search tree is a tree that satisfies these constraints:\n\nThe left subtree of a node contains only nodes with keys less than the node's key.\nThe right subtree of a node contains only nodes with keys greater than the node's key.\nBoth the left and right subtrees must also be binary search trees.\n\n### Example 1\n\n\n![](https://assets.leetcode.com/uploads/2019/05/02/tree.png)\n\n```bash\nInput: root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]\nOutput: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]\n```\n\n### Example 2\n\n```bash\nInput: root = [0,null,1]\nOutput: [1,null,1]\n \n```\n\n### Constraints:\n\n-","basename":"binary-search-tree-to-greater-sum-tree"},"binary-search":{"title":"Binary Search","description":"Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.","tags":["neetcode","medium","binary-search"],"link":"https://leetcode.com/problems/binary-search/","images":[],"preview":"### Description\n\nGiven an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.\n\nYou must write an algorithm with O(log n) runtime complexity.\n\n### Example 1\n\n```bash\nInput: nums = [-1,0,3,5,9,12], target = 9\nOutput: 4\nExplanation: 9 exists in nums and its index is 4\n```\n\n### Example 2\n\n```bash\nInput: nums = [-1,0,3,5,9,12], target = 2\nOutput: -1\nExplanation: 2 does not exist in nums so return -1\n```\n\n### Constraints:\n\n-     1 <= nums.length <= 104\n-     -104 < nums[i], target < 104\n-     All the integers in nums are unique.\n-     uunums is sorted in ascending order.","basename":"binary-search"},"binary-tree-cameras":{"title":"Binary Tree Cameras","description":"Return the minimum number of cameras needed to monitor all nodes of the tree.","tags":["hard","on-tree","dp"],"link":"https://leetcode.com/problems/binary-tree-cameras","images":[],"preview":"### Description\n\nYou are given the root of a binary tree. We install cameras on the tree nodes where each camera at a node can monitor its parent, itself, and its immediate children.\n\nReturn the minimum number of cameras needed to monitor all nodes of the tree.\n\n### Example 1\n\n```bash\nInput: root = [0,0,null,0,0]\nOutput: 1\nExplanation: One camera is enough to monitor all nodes if placed as shown.\n```\n\n### Example 2\n\n```bash\nInput: root = [0,0,null,0,null,0,null,null,0]\nOutput: 2\nExplanation: At least two cameras are needed to monitor all nodes of the tree. The above image shows one of the valid configurations of camera placement.\n```\n\n### Constraints:\n\n- The number of nodes in the tree is in the range [1, 1000].\n- Node.val == 0","basename":"binary-tree-cameras"},"binary-tree-level-order-traversal":{"title":"Binary Tree Level Order Traversal","description":"Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).","tags":["neetcode","medium","binary-tree"],"link":"https://leetcode.com/problems/binary-tree-level-order-traversal/","images":["https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg"],"hints":["https://wngnelson.com/assets/img_src/dsa/binary_traversal.gif"],"preview":"### Description\n\nGiven the `root` of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)\n\n```bash\nInput: root = [3,9,20,null,null,15,7]\nOutput: [[3],[9,20],[15,7]]\n```\n\n### Example 2\n\n```bash\nInput: root = [1]\nOutput: [[1]]\n```\n\n### Constraints:\n\n- The number of nodes in the tree is in the range [0, 2000]. \n- -1000 <= Node.val <= 1000","basename":"binary-tree-level-order-traversal"},"binary-tree-maximum-path-sum":{"title":"Binary Tree Maximum Path Sum","description":"Given the root of a binary tree, return the maximum path sum of any non-empty path.","tags":["neetcode","hard","binary-tree"],"link":"https://leetcode.com/problems/binary-tree-maximum-path-sum/","images":["https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg","https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg"],"preview":"### Description\n\nA path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.\n\nThe path sum of a path is the sum of the node's values in the path.\n\nGiven the root of a binary tree, return the maximum path sum of any non-empty path.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg)\n\n```bash\nInput: root = [1,2,3]\nOutput: 6\nExplanation: The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6.\n```\n\n### Example 2\n\n![](https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg)\n\n```bash\nInput: root = [-10,9,20,null,null,15,7]\nOutput: 42\nExplanation: The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42.\n```\n\n### Constraints:\n\n- The number of nodes in the tree is in the range [1, 3 * 10^4]. \n- -1000 <= Node.val <= 1000","basename":"binary-tree-maximum-path-sum"},"binary-tree-right-side-view":{"title":"Binary Tree Right Side View","description":"Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.","tags":["neetcode","medium","binary-tree"],"link":"https://leetcode.com/problems/binary-tree-right-side-view/","images":["https://assets.leetcode.com/uploads/2021/02/14/tree.jpg"],"hints":["https://wngnelson.com/assets/img_src/dsa/rightsideview.gif"],"preview":"### Description\n\nGiven the `root` of a binary tree, imagine yourself standing on the **right side** of it, return the values of the nodes you can see ordered from top to bottom.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2021/02/14/tree.jpg)\n\n\n```bash\nInput: root = [1,2,3,null,5,null,4]\nOutput: [1,3,4]\n```\n\n### Example 2\n\n```bash\nInput: root = [1,null,3]\nOutput: [1,3]\n```\n\n### Constraints:\n\n- The number of nodes in the tree is in the range [0, 100]. \n- -100 <= Node.val <= 100","basename":"binary-tree-right-side-view"},"bitwise-and-of-numbers-range":{"title":"Biwise AND of Numbers Range","description":"Given two integers left and right that represent the range [left, right], return the bitwise AND of all numbers in this range, inclusive.","tags":[],"link":null,"images":[],"preview":"### Description\n\nGiven two integers left and right that represent the range [left, right], return the bitwise AND of all numbers in this range, inclusive.\n\n### Example 1\n\n```bash\nInput: left = 5, right = 7\nOutput: 4\n```\n\n### Example 2\n\n```bash\nInput: left = 0, right = 0\nOutput: 0\n```\n\n### Example 3\n\n```bash\nInput: left = 1, right = 2147483647\nOutput: 0\n```\n\n### Constraints:\n\n- \n0 <= left <= right <= 231 - 1","basename":"bitwise-and-of-numbers-range"},"boggle-board":{"title":"boggle-board","tags":["hard","algoexpert"],"preview":"# Boggle Board\n\nYou're given a two-dimensional array (a matrix) of potentially unequal height and width containing letters; this matrix represents a boggle board. You're also given a list of words.\n\nWrite a function that returns an array of all the words contained in the boggle board. The final words don't need to be in any particular order.\n\nA word is constructed in the boggle board by connecting adjacent (horizontally, vertically, or diagonally) letters, without using any single letter at a given position more than once; while a word can of course have repeated letters, those repeated letters must come from different positions in the boggle board in order for the word to be contained in the board. Note that two or more words are allowed to overlap and use the same letters in the boggle board.\n\n## Sample Input\n```\nboard = [\n    [\"t\", \"h\", \"i\", \"s\", \"i\", \"s\", \"a\"],\n    [\"s\", \"i\", \"m\", \"p\", \"l\", \"e\", \"x\"],\n    [\"b\", \"x\", \"x\", \"x\", \"x\", \"e\", \"b\"],\n    [\"x\", \"o\", \"g\", \"g\", \"l\", \"x\", \"o\"],\n    [\"x\", \"x\", \"x\", \"D\", \"T\", \"r\", \"a\"],\n    [\"R\", \"E\", \"P\", \"E\", \"A\", \"d\", \"x\"],\n    [\"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\"],\n    [\"N\", \"O\", \"T\", \"R\", \"E\", \"-\", \"P\"],\n    [\"x\", \"x\", \"D\", \"E\", \"T\", \"A\", \"E\"],\n],\nwords = [\n    \"this\", \"is\", \"not\", \"a\", \"simple\", \"boggle\",\n    \"board\", \"test\", \"REPEATED\", \"NOTRE-PEATED\",\n]\n```\n\n## Sample Output\n```\n[\"this\", \"is\", \"a\", \"simple\", \"boggle\", \"board\", \"NOTRE-PEATED\"]\n// The words could be ordered differently.\n```\n\n### Hints\n\nHint 1\n> You can divide this question into two separate problems: one part involves traversing the boggle board in such a way that allows you to construct strings letter by letter; the other part involves actually comparing the strings you construct in the board against the words in the list that you're given. For the second part, what data structure lends itself very well to matching characters to multiple strings at once?\n\nHint 2\n> Try creating a trie out of the input list of words. This will allow you to compare letters in the boggle board against all input words in constant time. How can you efficiently traverse the boggle board to construct all potentially valid strings, without counting letters twice in any string?\n\nHint 3\n> Treat the board as a graph, where each element in the board is a node with up to 8 neighboring nodes. Traverse it in a depth-first-search-like fashion, checking if letters are contained in the trie and traversing the trie simultaneously if it makes sense to do so. How can you keep track of letters that you've already visited in order to avoid erroneously counting some of them twice in a single string? Could you keep track of visited nodes in an auxiliary data structure?\n\nHint 4\n> Keeping in mind that you only want to mark nodes as visited in a single branch of the graph that you're traversing (i.e., you don't want the state of visited nodes in one branch of the graph to spill into the state of another branch of the graph), try marking any node you traverse as unvisited at the end of the recursive call that actually traverses it, after traversing through all of the node's neighbors and performing the same actions on them recursively.\n\n```\nOptimal Space & Time Complexity\nO(nm*8^s + ws) time | O(nm + ws) space - where n is the width the board, m is the height of the board, w is the number of words, and s is the length of the longest word\n```","basename":"boggle-board"},"breadth-first-search":{"title":"Breadth First Search","description":"AI Search Problem","tags":["medium","search","ai"],"preview":"### Description\n\n- uninformed search\n- adds neighbors in queue\n\n### Example 1\n\n\nGiven: \n\n```js\n\n        //   A____B____C\n        //   |   |   /\n        //   |   |  /\n        //   |   | /\n        //   D___E\n        //   |\\  |\n        //   | \\ |\n        //   |__\\|\n        //   F    G\n\n        const A = new Node('A', 0, 2);\n        const B = new Node('B', 1, 2);\n        const C = new Node('C', 2, 2);\n        const D = new Node('D', 0, 1);\n        const E = new Node('E', 1, 1);\n        const G = new Node('G', 0, 0);\n        const F = new Node('F', 1, 0);\n\n        const graph = new Graph();\n        graph.addEdge(A, B);\n        graph.addEdge(A, D);\n        graph.addEdge(B, C);\n        graph.addEdge(B, E);\n        graph.addEdge(C, E);\n        graph.addEdge(D, G);\n        graph.addEdge(D, F);\n        graph.addEdge(D, E);\n        graph.addEdge(D,  G);\n        graph.addEdge(E, G);\n        graph.addEdge(G, G);\n\n        const nodes = { A, B, C, D, E, G, F };\n        return { graph: graph, nodes: nodes };\n```\n\nResults in:\n\n```bash\n{\n  path: [\n    Node { id: 'A', x: 0, y: 2 },\n    Node { id: 'D', x: 0, y: 1 },\n    Node { id: 'G', x: 0, y: 0 }\n  ],\n  cost: null,\n  count_searches: 6,\n  formatted_path: 'A -> D -> G',\n  exploration_path: [\n    Node { id: 'A', x: 0, y: 2 },\n    Node { id: 'B', x: 1, y: 2 },\n    Node { id: 'D', x: 0, y: 1 },\n    Node { id: 'C', x: 2, y: 2 },\n    Node { id: 'E', x: 1, y: 1 },\n    Node { id: 'G', x: 0, y: 0 }\n  ]\n}\n```\n\nShould be able to find it it using breadth First Search.\n\n\n\n### t_graph_1\n\n\n```js\n        A----B\n       |  \\ | \\\n       D   \\|  H\n       |  \\ | /|\n       |    C  |\n        \\    \\ G\n         \\    /\n          \\  /\n           E\n           |\n           F\n\n\nconst A = new Node('A', 0, 1);\nconst B = new Node('B', 2, 1);\nconst C = new Node('C', 2, -1);\nconst D = new Node('D', 0, 0);\nconst E = new Node('E', 1, -5);\nconst F = new Node('F', 1, -2);\nconst G = new Node('G', 3, -2);\nconst H = new Node('H', 3, 0);\n\nconst nodes = {A, B, C, D, E, F, G, H};\n\n\nconst graph = new Graph();\ngraph.addEdge(A, B);\ngraph.addEdge(A, D);\ngraph.addEdge(A, C);\ngraph.addEdge(B, C);\ngraph.addEdge(B, H);\ngraph.addEdge(C, H);\ngraph.addEdge(C, G);\ngraph.addEdge(C, D);\ngraph.addEdge(D, E);\ngraph.addEdge(D, G);\ngraph.addEdge(E, G);\ngraph.addEdge(E, F);\n\n```\n\n\n```bash\n path: [\n    Node { id: 'A', x: 0, y: 1 },\n    Node { id: 'D', x: 0, y: 0 },\n    Node { id: 'E', x: 1, y: -5 },\n    Node { id: 'F', x: 1, y: -2 }\n  ],\n  cost: null,\n  count_searches: 8,\n  formatted_path: 'A -> D -> E -> F',\n  exploration_path: [\n    Node { id: 'A', x: 0, y: 1 },\n    Node { id: 'B', x: 2, y: 1 },\n    Node { id: 'D', x: 0, y: 0 },\n    Node { id: 'C', x: 2, y: -1 },\n    Node { id: 'H', x: 3, y: 0 },\n    Node { id: 'E', x: 1, y: -5 },\n    Node { id: 'G', x: 3, y: -2 },\n    Node { id: 'F', x: 1, y: -2 }\n  ]\n```","basename":"breadth-first-search"},"brick-wall":{"title":"Brick Wall","description":"There is a rectangular brick wall in front of you with n rows of bricks. The ith row has some number of bricks each of the same height (i.e., one unit) but they can be of different widths. The total width of each row is the same.","tags":["medium"],"link":"https://leetcode.com/problems/brick-wall/description/","images":[],"preview":"### Description\n\nThere is a rectangular brick wall in front of you with n rows of bricks. The ith row has some number of bricks each of the same height (i.e., one unit) but they can be of different widths. The total width of each row is the same.\n\nDraw a vertical line from the top to the bottom and cross the least bricks. If your line goes through the edge of a brick, then the brick is not considered as crossed. You cannot draw a line just along one of the two vertical edges of the wall, in which case the line will obviously cross no bricks.\n\nGiven the 2D array wall that contains the information about the wall, return the minimum number of crossed bricks after drawing such a vertical line.\n\n\n### Example 1\n\n```bash\nInput: wall = [[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]]\nOutput: 2\n```\n\n### Example 2\n\n```bash\nInput: wall = [[1],[1],[1]]\nOutput: 3\n```","basename":"brick-wall"},"bus-routes":{"title":"Bus Routes","description":"You are given an array routes representing bus routes where routes[i] is a bus route that the ith bus repeats forever.","tags":["hard","daily"],"link":"https://leetcode.com/problems/bus-routes","images":[],"preview":"### Description\n\nYou are given an array routes representing bus routes where routes[i] is a bus route that the ith bus repeats forever.\n\nFor example, if routes[0] = [1, 5, 7], this means that the 0th bus travels in the sequence 1 -> 5 -> 7 -> 1 -> 5 -> 7 -> 1 -> ... forever.\nYou will start at the bus stop source (You are not on any bus initially), and you want to go to the bus stop target. You can travel between bus stops by buses only.\n\nReturn the least number of buses you must take to travel from source to target. Return -1 if it is not possible.\n\n### Example 1\n\n```bash\nInput: routes = [[1,2,7],[3,6,7]], source = 1, target = 6\nOutput: 2\nExplanation: The best strategy is take the first bus to the bus stop 7, then take the second bus to the bus stop 6.\n```\n\n### Example 2\n\n```bash\nInput: routes = [[7,12],[4,5,15],[6],[15,19],[9,12,13]], source = 15, target = 12\nOutput: -1\n```\n\n### Constraints:\n\n- 1 <= routes.length <= 500.\n- 1 <= routes[i].length <= 105\n- All the values of routes[i] are unique.\n- sum(routes[i].length) <= 105\n- 0 <= routes[i][j] < 106\n- 0 <= source, target < 106","basename":"bus-routes"},"campus-bikes":{"title":"Campus Bikes","description":"On a campus represented on the X-Y plane, there are n workers and m bikes, with n <= m.","tags":["medium","daily","greedy","sort","bucket-sort"],"link":"https://leetcode.com/problems/campus-bikes","images":[],"date":"2023-11-12 09:40:34","preview":"### Description\n\n\nOn a campus represented on the X-Y plane, there are n workers and m bikes, with n <= m.\n\nYou are given an array workers of length n where workers[i] = [xi, yi] is the position of the ith worker. You are also given an array bikes of length m where bikes[j] = [xj, yj] is the position of the jth bike. All the given positions are unique.\n\nAssign a bike to each worker. Among the available bikes and workers, we choose the (workeri, bikej) pair with the shortest Manhattan distance between each other and assign the bike to that worker.\n\nIf there are multiple (workeri, bikej) pairs with the same shortest Manhattan distance, we choose the pair with the smallest worker index. If there are multiple ways to do that, we choose the pair with the smallest bike index. Repeat this process until there are no available workers.\n\nReturn an array answer of length n, where answer[i] is the index (0-indexed) of the bike that the ith worker is assigned to.\n\nThe Manhattan distance between two points p1 and p2 is Manhattan(p1, p2) = |p1.x - p2.x| + |p1.y - p2.y|.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2019/03/06/1261_example_1_v2.png)\n\n```bash\nInput: workers = [[0,0],[2,1]], bikes = [[1,2],[3,3]]\nOutput: [1,0]\nExplanation: Worker 1 grabs Bike 0 as they are closest (without ties), and Worker 0 is assigned Bike 1. So the output is [1, 0].\n```\n\n### Example 2\n\n![](https://assets.leetcode.com/uploads/2019/03/06/1261_example_2_v2.png)\n\n```bash\nInput: workers = [[0,0],[1,1],[2,0]], bikes = [[1,0],[2,2],[2,1]]\nOutput: [0,2,1]\nExplanation: Worker 0 grabs Bike 0 at first. Worker 1 and Worker 2 share the same distance to Bike 2, thus Worker 1 is assigned to Bike 2, and Worker 2 will take Bike 1. So the output is [0,2,1].\n```\n\n### Constraints:\n\n- n == workers.length\n- m == bikes.length\n- 1 <= n <= m <= 1000\n- workers[i].length == bikes[j].length == 2\n- 0 <= xi, yi < 1000\n- 0 <= xj, yj < 1000\n- All worker and bike locations are unique.","iso8601Date":"2023-11-12T09:40:34-03:00","basename":"campus-bikes"},"candy":{"title":"Candy","description":"Return the minimum number of candies you need to have to distribute the candies to the children.","tags":["hard","array"],"link":"https://leetcode.com/problems/candy/","images":[],"hint":["https://wngnelson.com/assets/img_src/dsa/Candy.gif"],"preview":"### Description\n\nThere are n children standing in a line. Each child is assigned a rating value given in the integer array ratings.\n\nYou are giving candies to these children subjected to the following requirements:\n\n    Each child must have at least one candy.\n    Children with a higher rating get more candies than their neighbors.\n\nReturn the minimum number of candies you need to have to distribute the candies to the children.\n\n### Example 1\n\n![](https://wngnelson.com/assets/img_src/dsa/Candy.gif)\n\n\n```bash\nInput: ratings = [1,0,2]\nOutput: 5\nExplanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively.\n```\n\n### Example 2\n\n```bash\nInput: ratings = [1,2,2]\nOutput: 4\nExplanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively.\nThe third child gets 1 candy because it satisfies the above two conditions.\n```\n\n### Constraints:\n\n-     n == ratings.length\n-       1 <= n <= 2 * 104\n-       0 <= ratings[i] <= 2 * 104","basename":"candy"},"car-fleet":{"title":"Car Fleet","description":"There are n cars going to the same destination along a one-lane road. The destination is target miles away.","tags":["neetcode","medium","stack"],"link":"https://leetcode.com/problems/car-fleet/","images":[],"preview":"### Description\n\nThere are `n` cars going to the same destination along a one-lane road. The destination is `target` miles away.\n\nYou are given two integer array position and speed, both of length n, where position[i] is the position of the ith car and speed[i] is the speed of the ith car (in miles per hour).\n\nA car can never pass another car ahead of it, but it can catch up to it and drive bumper to bumper at the same speed. The faster car will slow down to match the slower car's speed. The distance between these two cars is ignored (i.e., they are assumed to have the same position).\n\nA car fleet is some non-empty set of cars driving at the same position and same speed. Note that a single car is also a car fleet.\n\nIf a car catches up to a car fleet right at the destination point, it will still be considered as one car fleet.\n\nReturn the number of car fleets that will arrive at the destination.\n\n### Example 1\n\n```bash\nInput: target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]\nOutput: 3\nExplanation:\nThe cars starting at 10 (speed 2) and 8 (speed 4) become a fleet, meeting each other at 12.\nThe car starting at 0 does not catch up to any other car, so it is a fleet by itself.\nThe cars starting at 5 (speed 1) and 3 (speed 3) become a fleet, meeting each other at 6. The fleet moves at speed 1 until it reaches target.\nNote that no other cars meet these fleets before the destination, so the answer is 3.\n```\n\n### Example 2\n\n```bash\nInput: target = 10, position = [3], speed = [3]\nOutput: 1\nExplanation: There is only one car, hence there is only one fleet.\n```\n\n### Example 3\n\n```bash\nInput: target = 100, position = [0,2,4], speed = [4,2,1]\nOutput: 1\nExplanation:\nThe cars starting at 0 (speed 4) and 2 (speed 2) become a fleet, meeting each other at 4. The fleet moves at speed 2.\nThen, the fleet (speed 2) and the car starting at 4 (speed 1) become one fleet, meeting each other at 6. The fleet moves at speed 1 until it reaches target.\n```\n\n### Constraints:\n\n-      n == position.length == speed.length     \n-      1 <= n <= 105\n-      0 < target <= 106\n-      0 <= position[i] < target\n-      All the values of position are unique.\n-      0 < speed[i] <= 106","basename":"car-fleet"},"character-replacement":{"title":"Character Replacement","description":"Longest Repeating Character Replacement","tags":["neetcode","medium","sliding-window"],"hint":["To solve this problem, you need to first find the longest contiguous substring of s that contains the same letter. Then, you need to check if you can make this substring longer by changing some of the characters to the same letter. You can do this by counting the frequency of each character in the substring and checking if the number of characters you need to change to the most frequent character is less than or equal to k.  If it is, you can change those characters to the most frequent character and obtain a longer substring with the same letter. If it is not, you cannot change enough characters to make the substring longer and you should move on to the next contiguous substring in s.  Repeat this process for all contiguous substrings of s to find the longest substring containing the same letter that can be obtained after performing at most k operations."],"preview":"### Description\n\nYou are given a string `s` and an integer `k`. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most `k` times.\n\nReturn the length of the longest substring containing the same letter you can get after performing the above operations.\n\n### Re-explained:\n\nYou have a sentence (string) and a number (k). You can change any letter in the sentence to another letter of the alphabet, but you can only change up to k letters. You want to find the longest part of the sentence where all the letters are the same, but you can change some letters to make it longer\n\n\n### Example 1\n```bash\nInput: s = \"ABAB\", k = 2\nOutput: 4\nExplanation: Replace the two 'A's with two 'B's or vice versa.\n```\n\n### Example 2\n```bash\nInput: s = \"AABABBA\", k = 1\nOutput: 4\nExplanation: Replace the one 'A' in the middle with 'B' and form \"AABBBBA\".\nThe substring \"BBBB\" has the longest repeating letters, which is 4.\n```\n\n\n### Example 3\n\n```bash\nInput: s = \"abcdeffggg\", k = 2\nOutput: 6\nExplanation: The longest substring containing the same letter is \"ggg\", which is 3 letters long. You can change the 'e' to a 'g' and the 'f' to a 'g' to make the substring \"gggggg\", which is 6 letters long.\n```\n\n### Example 4\n\n```bash\nInput: s = \"AAAAAA\", k = 2\nOutput: 6\nExplanation: You don't need to change any letters because the entire string is already made up of the same letter 'A', which is 6 letters long.\n```\n\n### Example 5\n\n```bash\nInput: s = \"abccbaaaabbccaa\", k = 3\nOutput: 7\nExplanation: The longest substring containing the same letter is \"aaa\", which is 3 letters long. You can change the 'b' to an 'a', the first 'c' to an 'a', and the second 'c' to an 'a' to make the substring \"aaaaaaa\", which is 7 letters long.\n```\n\n\n### Constraints:\n\n- 1 <= s.length <= 105\n- s consists of only uppercase English letters.\n- 0 <= k <= s.length","basename":"character-replacement"},"cheapest-flights-within-k-stops":{"title":"Cheapest FLights Within K Stops","description":"You are also given three integers src, dst, and k, return the cheapest price from src to dst with at most k stops. If there is no such route, return -1.","tags":["medium","graph","dijkstra"],"link":null,"images":[],"preview":"### Description\n\nThere are n cities connected by some number of flights. You are given an array flights where flights[i] = [fromi, toi, pricei] indicates that there is a flight from city fromi to city toi with cost pricei.\n\nYou are also given three integers src, dst, and k, return the cheapest price from src to dst with at most k stops. If there is no such route, return -1.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2022/03/18/cheapest-flights-within-k-stops-3drawio.png)\n\n```bash\nInput: n = 4, flights = [[0,1,100],[1,2,100],[2,0,100],[1,3,600],[2,3,200]], src = 0, dst = 3, k = 1\nOutput: 700\nExplanation:\nThe graph is shown above.\nThe optimal path with at most 1 stop from city 0 to 3 is marked in red and has cost 100 + 600 = 700.\nNote that the path through cities [0,1,2,3] is cheaper but is invalid because it uses 2 stops.\n```\n\n### Example 2\n\n![](https://assets.leetcode.com/uploads/2022/03/18/cheapest-flights-within-k-stops-1drawio.png)\n\n```bash\nInput: n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 1\nOutput: 200\nExplanation:\nThe graph is shown above.\nThe optimal path with at most 1 stop from city 0 to 2 is marked in red and has cost 100 + 100 = 200.\n```\n\n![](https://assets.leetcode.com/uploads/2022/03/18/cheapest-flights-within-k-stops-2drawio.png)\n\n```bash\nInput: n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 0\nOutput: 500\nExplanation:\nThe graph is shown above.\nThe optimal path with no stops from city 0 to 2 is marked in red and has cost 500.\n```\n\n\n### Constraints:\n\n- 1 <= n <= 100\n- 0 <= flights.length <= (n * (n - 1) / 2)\n- flights[i].length == 3\n- 0 <= fromi, toi < n\n- fromi != toi\n- 1 <= pricei <= 104\n- There will not be any multiple flights between two cities.\n- 0 <= src, dst, k < n\n- src != dst","basename":"cheapest-flights-within-k-stops"},"class-photos":{"title":"Class Photo","description":"The function is going to arrange the students and return true if we can take a photo that follows these constraints; otherwise return false.","tags":["easy","algoexpert"],"link":"https://github.com/pinglu85/algoExpert/blob/main/Easy/class-photos.md","images":[],"preview":"### Description\n\n### Understanding the problem\n\nWe are given two non-empty arrays of positive integers: the first is going to represent the heights of students wearing red shirts and the second is going to represent the heights of students wearing blue shirts. The two arrays will always have the same length. We are asked to write a function that is going to find out if we can take a photo of these students that satisfies the following constraints:\n\n1. All the students that are wearing red shirts must be in the same row;\n2. All of the students that are wearing blue shirts must be in the same row;\n3. The photo must have exactly two rows and the two rows must have the same number of students in them.\n4. Every student in the front row must be shorter than the student directly behind them in the back row.\n\nThe function is going to arrange the students and return `true` if we can take a photo that follows these constraints; otherwise return `false`.\n\n\n### Example 1\n\n```bash\n([5, 8, 1, 3, 4], [6, 9, 2, 4, 5]) => true\n```\n\n### Example 2\n\n```bash\n([5, 8, 1, 3, 4], [6, 9, 2, 4, 4]) => false\n```\n\n```bash\n([5, 8, 1, 3, 4], [6, 9, 2, 4, 5]) => true\n```\n\n```bash\n([5, 8, 1, 3, 4, 9], [6, 9, 2, 4, 5, 1]) => false\n```\n\n```bash\n([6], [6]) => true\n```\n\n```bash\n([2, 3, 4, 5, 6], [1, 2, 3, 4, 5]) => true\n```","basename":"class-photos"},"climbing-stairs":{"title":"Climbing Stairs","description":"You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?","tags":["easy","dp","neetcode"],"link":"https://leetcode.com/problems/climbing-stairs/","images":[],"preview":"### Description\n\nYou are climbing a staircase. It takes `n` steps to reach the top.\n\nEach time you can either climb `1` or `2` steps. In how many distinct ways can you climb to the top?\n\n### Example 1\n\n```bash\nInput: n = 2\nOutput: 2\nExplanation: There are two ways to climb to the top.\n1. 1 step + 1 step\n2. 2 steps\n```\n\n### Example 2\n\n```bash\nInput: n = 3\nOutput: 3\nExplanation: There are three ways to climb to the top.\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step\n```\n\n### Constraints:\n\n- 1 <= n <= 45","basename":"climbing-stairs"},"clone-graph":{"title":"Clone Graph","description":"Given a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph. Each node in the graph contains a val (int) and a list (List[Node]) of its neighbors.","tags":["neetcode","medium","graphs"],"link":"https://leetcode.com/problems/clone-graph/","images":[],"preview":"### Description\n\nGiven a reference of a node in a connected undirected graph.\n\nReturn a deep copy (clone) of the graph.\n\nEach node in the graph contains a value (int) and a list (List[Node]) of its neighbors.\n\n### Example 1\n\n```bash\nInput: adjList = [[2,4],[1,3],[2,4],[1,3]]\nOutput: [[2,4],[1,3],[2,4],[1,3]]\nExplanation: There are 4 nodes in the graph.\n1st node (val = 1)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\n2nd node (val = 2)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).\n3rd node (val = 3)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\n4th node (val = 4)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).\n```\n\n### Example 2\n\n```bash\nInput: adjList = [[]]\nOutput: [[]]\nExplanation: Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors.\n```\n\n### Example 3\n\n```bash\nInput: adjList = []\nOutput: []\n```\n\n### Constraints:\n\n- The number of nodes in the graph is in the range [0, 100].\n- 1 <= Node.val <= 100\n- Node.val is unique for each node.\n- There are no repeated edges and no self-loops in the graph.\n- The Graph is connected and all nodes can be visited starting from the given node.","basename":"clone-graph"},"coin-change":{"title":"Coin Change","description":"You may assume that you have an infinite number of each kind of coin.","tags":["medium","dp","neetcode"],"link":"https://leetcode.com/problems/coin-change/","images":[],"hints":["https://wngnelson.com/assets/img_src/dsa/coin_change.gif"],"preview":"### Description\n\nYou are given an integer array `coins` representing coins of different denominations and an integer amount representing a total `amount` of money.\n\nReturn the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return `-1`.\n\nYou may assume that you have an infinite number of each kind of coin.\n\n### Example 1\n\n```bash\nInput: coins = [1,2,5], amount = 11\nOutput: 3\nExplanation: 11 = 5 + 5 + 1\n```\n\n### Example 2\n\n```bash\nInput: coins = [2], amount = 3\nOutput: -1\n```\n\n### Example 3\n\n```bash\nInput: coins = [1], amount = 0\nOutput: 0\n```\n\n### Constraints:\n\n- 1 <= coins.length <= 12\n- 1 <= coins[i] <= 231 - 1\n- 0 <= amount <= 104","basename":"coin-change"},"combination-sum-ii":{"title":"Combination Sum II","description":"Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.","tags":["neetcode","medium","backtracking"],"link":"https://leetcode.com/problems/combination-sum-ii/","images":[],"preview":"### Description\n\nGiven a collection of candidate numbers (`candidates`) and a target number (`target`), find all unique combinations in `candidates` where the candidate numbers sum to target.\n\nEach number in candidates may only be used **once** in the combination.\n\n**Note**: The solution set must not contain duplicate combinations.\n\n### Example 1\n\n```bash\nInput: candidates = [10,1,2,7,6,1,5], target = 8\nOutput: \n[\n[1,1,6],\n[1,2,5],\n[1,7],\n[2,6]\n]\n```\n\n### Example 2\n\n```bash\nInput: candidates = [2,5,2,1,2], target = 5\nOutput: \n[\n[1,2,2],\n[5]\n]\n```\n\n### Constraints:\n\n- 1 <= candidates.length <= 100 \n- 1 <= candidates[i] <= 50 \n- 1 <= target <= 30","basename":"combination-sum-ii"},"combination-sum":{"title":"Combination Sum","description":"The test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input.","tags":["neetcode","medium","backtracking"],"link":"https://leetcode.com/problems/combination-sum/","images":[],"preview":"### Description\n\nGiven an array of **distinct** integers candidates and a target integer target, return a list of all **unique combinations** of candidates where the chosen numbers sum to target. You may return the combinations in **any order**.\n\nThe **same** number may be chosen from candidates an **unlimited number of times**. Two combinations are unique if the frequency of at least one of the chosen numbers is different.\n\nThe test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input.\n\n \n\n### Example 1\n\n```bash\nInput: candidates = [2,3,6,7], target = 7\nOutput: [[2,2,3],[7]]\nExplanation:\n2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\n7 is a candidate, and 7 = 7.\nThese are the only two combinations.\n```\n\n### Example 2\n\n```bash\nInput: candidates = [2,3,5], target = 8\nOutput: [[2,2,2,2],[2,3,3],[3,5]]\n```\n\n### Constraints:\n\n- 1 <= candidates.length <= 30\n- 2 <= candidates[i] <= 40\n- All elements of candidates are distinct.\n- 1 <= target <= 40","basename":"combination-sum"},"combinations":{"title":"Combination","description":"Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, n].","tags":["medium","backtracking"],"link":"https://leetcode.com/problems/combinations/description","images":[],"preview":"### Description\n\nGiven two integers n and k, return all possible combinations of k numbers chosen from the range [1, n].\n\nYou may return the answer in any order.\n\n### Example 1\n\n```bash\nInput: n = 4, k = 2\nOutput: [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\nExplanation: There are 4 choose 2 = 6 total combinations.\nNote that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same combination.\n```\n\n### Example 2\n\n```bash\nInput: n = 1, k = 1\nOutput: [[1]]\nExplanation: There is 1 choose 1 = 1 total combination.\n```\n\n### Constraints:\n\n- 1 <= n <= 20\n- 1 <= k <= n","basename":"combinations"},"connecting-cities-with-minimum-cost":{"title":"Connecting Cities With Minimum Cost","description":"Return the minimum cost to connect all the n cities such that there is at least one path between each pair of cities. If it is impossible to connect all the n cities, return -1,","tags":["graph","medium","minimum-spanning-tree"],"link":"https://leetcode.com/problems/connecting-cities-with-minimum-cost","images":[],"preview":"### Description\n\nThere are n cities labeled from 1 to n. You are given the integer n and an array connections where connections[i] = [xi, yi, costi] indicates that the cost of connecting city xi and city yi (bidirectional connection) is costi.\n\nReturn the minimum cost to connect all the n cities such that there is at least one path between each pair of cities. If it is impossible to connect all the n cities, return -1,\n\nThe cost is the sum of the connections' costs used.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2019/04/20/1314_ex2.png)\n\n```bash\nInput: n = 3, connections = [[1,2,5],[1,3,6],[2,3,1]]\nOutput: 6\nExplanation: Choosing any 2 edges will connect all cities so we choose the minimum 2.\n```\n\n### Example 2\n\n![](https://assets.leetcode.com/uploads/2019/04/20/1314_ex1.png)\n\n```bash\nInput: n = 4, connections = [[1,2,3],[3,4,4]]\nOutput: -1\nExplanation: There is no way to connect all cities even if all edges are used.\n```\n\n### Constraints:\n\n- 1 <= n <= 10^4\n- 1 <= connections.length <= 10^4\n- connections[i].length == 3\n- 1 <= xi, yi <= n\n- xi != yi\n- 0 <= costi <= 105","basename":"connecting-cities-with-minimum-cost"},"construct-binary-tree-from-inorder-and-postorder-traversal":{"title":"Construct Binary Tree from Inorder and Postorder Traversal","description":"Given two integer arrays inorder and postorder where inorder is the inorder traversal of a binary tree and postorder is the postorder traversal of the same tree, construct and return the binary tree.","tags":["binary-tree","medium"],"link":"https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal","images":[],"preview":"### Description\n\nGiven two integer arrays inorder and postorder where inorder is the inorder traversal of a binary tree and postorder is the postorder traversal of the same tree, construct and return the binary tree.\n\n### Example 1\n\n```bash\nInput: inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]\nOutput: [3,9,20,null,null,15,7]\n```\n\n### Example 2\n\n```bash\nInput: inorder = [-1], postorder = [-1]\nOutput: [-1]\n```\n\n### Constraints:\n\n- 1 <= inorder.length <= 3000\n- postorder.length == inorder.length\n- -3000 <= inorder[i], postorder[i] <= 3000\n- inorder and postorder consist of unique values.\n- Each value of postorder also appears in inorder.\n- inorder is guaranteed to be the inorder traversal of the tree.\n- postorder is guaranteed to be the postorder traversal of the tree.","basename":"construct-binary-tree-from-inorder-and-postorder-traversal"},"construct-binary-tree-from-preorder-and-inorder-traversal":{"title":"Construct Binary Tree from Preorder and Inorder Traversal","description":"Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.","tags":["neetcode","medium","binary-tree"],"link":"https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/","images":["https://assets.leetcode.com/uploads/2021/02/19/tree.jpg"],"hints":["https://wngnelson.com/assets/img_src/dsa/constructbinary.gif","https://twitter.com/i/status/1720443249553195506"],"preview":"### Description\n\nGiven two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg)\n\n```bash\nInput: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]\nOutput: [3,9,20,null,null,15,7]\n```\n\n### Example 2\n\n```bash\nInput: preorder = [-1], inorder = [-1]\nOutput: [-1]\n```\n\n### Constraints:\n\n- 1 <= preorder.length <= 3000 \n- inorder.length == preorder.length\n- -3000 <= preorder[i], inorder[i] <= 3000 \n- preorder and inorder consist of unique values. \n- Each value of inorder also appears in preorder. \n- preorder is guaranteed to be the preorder traversal of the tree. \n- inorder is guaranteed to be the inorder traversal of the tree.","basename":"construct-binary-tree-from-preorder-and-inorder-traversal"},"construct-quad-tree":{"title":"Construct Quad Tree","description":"Given a n * n matrix grid of 0's and 1's only. We want to represent grid with a Quad-Tree.","tags":["medium","divide-and-conquer"],"link":"https://leetcode.com/problems/construct-quad-tree/","images":[],"preview":"### Description\n\nGiven a n * n matrix grid of 0's and 1's only. We want to represent grid with a Quad-Tree.\n\nReturn the root of the Quad-Tree representing grid.\n\nA Quad-Tree is a tree data structure in which each internal node has exactly four children. Besides, each node has two attributes:\n\nval: `True` if the node represents a grid of 1's or `False` if the node represents a grid of 0's. Notice that you can assign the val to True or False when isLeaf is False, and both are accepted in the answer.\nisLeaf: `True` if the node is a `leaf` node on the tree or `False` if the `node has four children`.\n\n```js\nclass Node {\n    public boolean val;\n    public boolean isLeaf;\n    public Node topLeft;\n    public Node topRight;\n    public Node bottomLeft;\n    public Node bottomRight;\n}\n```\n\nWe can construct a Quad-Tree from a two-dimensional area using the following steps:\n\n1. If the current grid has the same value (i.e all 1's or all 0's) set isLeaf True and set val to the value of the grid and set the four children to Null and stop.\n2. If the current grid has different values, set isLeaf to False and set val to any value and divide the current grid into four sub-grids as shown in the photo.\n3. Recurse for each of the children with the proper sub-grid.\n\n![](https://assets.leetcode.com/uploads/2020/02/11/new_top.png)\n\nIf you want to know more about the Quad-Tree, you can refer to the wiki.\n\nQuad-Tree format:\n\nYou don't need to read this section for solving the problem. This is only if you want to understand the output format here. The output represents the serialized format of a Quad-Tree using level order traversal, where null signifies a path terminator where no node exists below.\n\nIt is very similar to the serialization of the binary tree. The only difference is that the node is represented as a list [isLeaf, val].\n\nIf the value of isLeaf or val is True we represent it as 1 in the list [isLeaf, val] and if the value of isLeaf or val is False we represent it as 0.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2020/02/11/grid1.png)\n\n```bash\nInput: grid = [[0,1],[1,0]]\nOutput: [[0,1],[1,0],[1,1],[1,1],[1,0]]\nExplanation: The explanation of this example is shown below:\nNotice that 0 represents False and 1 represents True in the photo representing the Quad-Tree.\n```\n\n![](https://assets.leetcode.com/uploads/2020/02/12/e1tree.png)\n\n### Example 2\n\n![](https://assets.leetcode.com/uploads/2020/02/12/e2mat.png)\n\n```bash\nInput: grid = [[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]\nOutput: [[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]\nExplanation: All values in the grid are not the same. We divide the grid into four sub-grids.\nThe topLeft, bottomLeft and bottomRight each has the same value.\nThe topRight have different values so we divide it into 4 sub-grids where each has the same value.\n```\n\n![](https://assets.leetcode.com/uploads/2020/02/12/e2tree.png)\n\n### Constraints:\n\n- n == grid.length == grid[i].length\n- n == 2x where 0 <= x <= 6","basename":"construct-quad-tree"},"container-with-most-water":{"title":"Container With Most Water","description":"A container with most water example","tags":["neetcode","array","medium"],"images":["https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg"],"link":"https://leetcode.com/problems/container-with-most-water/","preview":"## Container With Most Water\n\nYou are given an integer array height of length n. There are n vertical lines drawn such that the two endp, neetcodeoints of the ith line are (i, 0) and (i, height[i]).\n\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\n\nReturn the maximum amount of water a container can store.\n\nNotice that you may not slant the container.\n\n![](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg)\n\n\n```\nInput: height = [1,8,6,2,5,4,8,3,7]\nOutput: 49\nExplanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\n```\n\n\n### Example 2\n\n```\nInput: height = [1,1]\nOutput: 1\n```","basename":"container-with-most-water"},"contains-duplicate-ii":{"title":"Contains Duplicate II","description":"Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) <= k.","tags":["hashmap","leetcode"],"link":"https://leetcode.com/problems/contains-duplicate-ii/?envType=study-plan-v2&envId=top-interview-150","images":[],"preview":"### Description\n\nGiven an integer array `nums` and an integer `k`, return `true` if there are two distinct indices `i` and `j` in the array such that `nums[i] == nums[j]` and `abs(i - j) <= k`.\n\n\n### Example 1\n\n```bash\nInput: nums = [1,2,3,1], k = 3\nOutput: true\n```\n\n### Example 2\n\n```bash\nInput: nums = [1,0,1,1], k = 1\nOutput: true\n```\n\n### Example 3\n\n```bash\nInput: nums = [1,2,3,1,2,3], k = 2\nOutput: false\n```\n\n### Constraints:\n\n- 1 <= nums.length <= 105\n- -109 <= nums[i] <= 109\n- 0 <= k <= 105","basename":"contains-duplicate-ii"},"continuous-median":{"title":"Continuous Median","description":"Write a ContinuousMedianHandler class that supports The continuous insertion of numbers with the insert method. The instant (O(1) time) retrieval of the median of the numbers that have been inserted thus far with the getMedian method.","tags":["hard","algoexpert"],"link":null,"images":[],"preview":"# Continuous Median\n\nWrite a ContinuousMedianHandler class that supports:\n\n   - The continuous insertion of numbers with the insert method.\n   - The instant (O(1) time) retrieval of the median of the numbers that have been inserted thus far with the getMedian method.\n\nThe getMedian method has already been written for you. You simply have to write the insert method.\n\nThe median of a set of numbers is the \"middle\" number when the numbers are ordered from smallest to greatest. If there's an odd number of numbers in the set, as in {1, 3, 7}, the median is the number in the middle (3 in this case); if there's an even number of numbers in the set, as in {1, 3, 7, 8}, the median is the average of the two middle numbers ((3 + 7) / 2 == 5 in this case).\n\n## Sample Usage\n\n```\n// All operations below are performed sequentially.\nContinuousMedianHandler(): - // instantiate a ContinuousMedianHandler\ninsert(5): -\ninsert(10): -\ngetMedian(): 7.5\ninsert(100): -\ngetMedian(): 10\n```\n\n### Hints\n\nHint 1\n> The median of a set of numbers is often, by definition, one of the numbers in the set. Thus, you likely have to store all of the inserted numbers somewhere to be able to continuously compute their median.\n\nHint 2\n> The median of a set of numbers is either the middle number of that set (if the set has an odd amount of numbers) or the average of the middle numbers (if the set has an even amount of numbers). This means that if you could somehow keep track of the middle number(s) of the set of inserted numbers, you could easily compute the median by finding the indices of the middle numbers and doing some simple calculations. Perhaps storing all of the numbers in a sorted array could work, but what would be the runtime implication of inserting each new number into a sorted array?\n\nHint 3\n> Realizing that you only need to keep track of the middle numbers in the set of inserted numbers to compute the median, try keeping track of two subsets of the numbers: a max-heap of the lower half of the numbers and a min-heap of the greater half of the numbers. Any time you insert a number, pick the heap to place it in by comparing it to the max / min values of the heaps. Then, re-balance the heaps in an effort to keep their sizes apart by at most one. Doing so will allow you to access the middle number(s) of the set of inserted numbers very easily, which will make calculating the median a trivial computation. Re-balancing the heaps can be accomplished by simply removing a value from the larger heap and inserting it in the smaller one. What are the runtime implications of all these operations?\n\n```\nOptimal Space & Time Complexity\nInsert: O(log(n)) time | O(n) space - where n is the number of inserted numbers\n```","basename":"continuous-median"},"convert-sorted-array-to-binary-search-tree":{"title":"Convert Sorted Array to Binary Search Tree","description":"Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree.","tags":["easy","binar-search-tree","depth-first-search"],"link":"https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree","images":[],"preview":"### Description\n\nGiven an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg)\n\n```bash\nInput: nums = [-10,-3,0,5,9]\nOutput: [0,-3,9,-10,null,5]\nExplanation: [0,-10,5,null,-3,null,9] is also accepted:\n```\n\n### Example 2\n\n![](https://assets.leetcode.com/uploads/2021/02/18/btree.jpg)\n\n```bash\nInput: nums = [1,3]\nOutput: [3,1]\nExplanation: [1,null,3] and [3,1] are both height-balanced BSTs.\n```\n\n### Constraints:\n\n- 1 <= nums.length <= 104\n- -104 <= nums[i] <= 104\n- nums is sorted in a strictly increasing order.","basename":"convert-sorted-array-to-binary-search-tree"},"copy-list-with-random-pointer":{"title":"Copy List with Random Pointer","description":"A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null.","tags":["neetcode","medium","linked-list"],"link":"https://leetcode.com/problems/copy-list-with-random-pointer/","images":["https://assets.leetcode.com/uploads/2019/12/18/e1.png","https://assets.leetcode.com/uploads/2019/12/18/e2.png","https://assets.leetcode.com/uploads/2019/12/18/e3.png"],"preview":"### Description\n\nA linked list of length `n` is given such that each node contains an additional random pointer, which could point to any node in the list, or `null`.\n\nConstruct a deep copy of the list. The deep copy should consist of exactly n **brand new **nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. **None of the pointers in the new list should point to nodes in the original list.**\n\nFor example, if there are two nodes X and Y in the original list, where X.random --> Y, then for the corresponding two nodes x and y in the copied list, x.random --> y.\n\nReturn the head of the copied linked list.\n\nThe linked list is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where:\n\n- `val`: an integer representing `Node.val`\n- `random_index`: the index of the node (range from `0` to `n-1`) that the `random pointer` points to, or null if it does not point to any node.\n\nYour code will **only** be given the head of the original linked list.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2019/12/18/e1.png)\n\n```bash\nInput: head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\nOutput: [[7,null],[13,0],[11,4],[10,2],[1,0]]\n```\n\n### Example 2\n\n![](https://assets.leetcode.com/uploads/2019/12/18/e2.png)\n\n\n```bash\nInput: head = [[1,1],[2,1]]\nOutput: [[1,1],[2,1]]\n```\n\n### Example 3\n\n![](https://assets.leetcode.com/uploads/2019/12/18/e3.png)\n\n```bash\nInput: head = [[3,null],[3,0],[3,null]]\nOutput: [[3,null],[3,0],[3,null]]\n```\n\n### Constraints:\n\n- 0 <= n <= 1000\n- -104 <= Node.val <= 104\n- Node.random is null or is pointing to some node in the linked list.","basename":"copy-list-with-random-pointer"},"corporate_gb_plus":{"preview":"Given the following table named `CORPORATION`:\n\n| name          | datatype |\n| ------------- | -------- |\n| ENTITY_EMAIL  | str      |\n| PF_STATE      | str      |\n| STATUS        | str      |\n| CREATION_DATE | date     |\n\n\n\n### 1. GROUP BY CUBE Example\n\n**Scenario:**\nAnalyze the distribution of corporation statuses across different states with an ability to see the counts by status, by state, and the overall totals.\n\n\nOutput something like this:\n\n| pf_state  | STATUS             | COUNT(*) |\n| --------- | ------------------ | -------- |\n| FL        | I                  | 7669287  |\n| CT        | Dissolved          | 282001   |\n| Dissolved | 282001             |          |\n| CT        | Pending Conversion | 1        |\n| FL        | A                  | 3600710  |\n\n\n\n\n**Explanation:**\n- `GROUP BY CUBE (pf_state, status)` generates grouping sets that include all possible combinations of `pf_state` and `status`, as well as the total count of corporations for each state, each status, and a grand total for all corporations.\n- This query will help understand the distribution and count of corporations by state and status, including subtotals and a grand total.\n\n\n\n### 2. GROUP BY ROLLUP Example\n\n**Scenario:**\nCalculate the number of corporations created in each year, broken down by state, and provide cumulative totals for each state and an overall total.\n\nAssuming `creation_date` is stored in a `YYYY-MM-DD` format, we would first extract the year from the date to group by it.\n\n\n**Explanation:**\n- `GROUP BY ROLLUP (pf_state, year)` provides a hierarchical summarization by `pf_state` and `year`. It includes subtotals at each level of grouping, with the most detailed level being by state and year, then by state, and finally a grand total across all states and years.\n- This query helps track the growth or reduction in the number of corporations over the years within each state and overall.\n\nBoth of these queries allow for complex aggregation with less effort and can be very powerful tools for data analysis and reporting in SQL.\n\n\n```sql\nSELECT\n    pf_state,\n    EXTRACT(YEAR FROM creation_date) AS year,\n    COUNT(*) AS total_corporations\nFROM\n    corporation\nGROUP BY ROLLUP (pf_state, EXTRACT(YEAR FROM creation_date));\n```","basename":"corporate_gb_plus"},"corporation_count_repetitions":{"title":"Corporation Count Repetitions","tags":["snowflake"],"preview":"### Description\n\nGiven the following table named `CORPORATION`:\n\n| name          | datatype |\n| ------------- | -------- |\n| ENTITY_EMAIL  | str      |\n| PF_STATE      | str      |\n| STATUS        | str      |\n| CREATION_DATE | date     |\n\n\n\n## 1. Select Email Frequency\n\nSelect table of entities and their frequency of emails in the state of `Florida` = `FL` that are `active`.\n\n\n| entity_email                 | count |\n| ---------------------------- | ----- |\n| admin@uplegacy.com           | 1     |\n| nsowani@eofficesolutions.net | 42    |\n| NGARCIA@TAXPRONET.COM        | 26    |\n| govdocs@corpcreations.com    | 3849  |\n| KBERGER132@HOTMAIL.COM       | 1     |\n| gracefrancesca1180@gmail.com | 1     |\n| asuperiorpavers@yahoo.com    | 1     |\n\n\n\n\n## 2. Create a Frequency Repetition Table\n\nWrite a SQL query to count that count number of entities where have count of specific number of emails in the state of `Florida` = `FL` that are active and were created in the first quarter of 2024.\n\nFor example:\n\n| frequency | countofrepetitions |\n| --------- | ------------------ |\n| 1         | 106259             |\n| 2         | 4533               |\n| 3         | 1388               |\n| 4         | 660                |\n| 5         | 454                |","basename":"corporation_count_repetitions"},"corporation_selection_subq":{"title":"Corporation Selection Subquery","tags":["snowflake"],"preview":"### Description\n\n\nUsing table `corporation` with the following schema:\n\n| name          | datatype |\n| ------------- | -------- |\n| entity_email  | str      |\n| pf_state      | str      |\n| status        | str      |\n| creation_date | date     |\n\n### 1. Select using temporal table:\n\n\n```sql\nCREATE TEMPORARY TABLE mytemptable (id NUMBER, creation_date DATE);\n```\n\nSelect all corporations where:\n- Entities have less than 4 emails in the state of `Florida` = `FL` that are active.\n- corporations were created in 2024.\n\n\nUse the following Streatgy: Create a temporary table to store the count of emails per entity in the state of `Florida` and then use it to filter the corporations.\n\n\n\n### 2. Select using partition\n\nUsing the temporary table `LESS5EMAIL` to filter the corporations. Select the last corporation created in 2024 for each entity.\n\n\n## Reference\n\n\n### Temporal Tables\n\nhttps://docs.snowflake.com/en/user-guide/tables-temp-transient\n\n```sql\nCREATE TEMPORARY TABLE mytemptable (id NUMBER, creation_date DATE);\n```\n\nSimilar to the other table types (transient and permanent), temporary tables belong to a specified database and schema; however, because they are session-based, they arent bound by the same uniqueness requirements. This means you can create temporary and non-temporary tables with the same name within the same schema.\n\n\n### Having & Group By\n\nhttps://docs.snowflake.com/en/sql-reference/constructs/having\n\n```sql\nSELECT ...\nFROM ...\nGROUP BY ...\nHAVING <predicate>\n[ ... ]\n```\n\nThe condition specified by the HAVING clause applies to expressions produced by the GROUP BY. Therefore, the same restrictions that apply to GROUP BY expressions also apply to the HAVING clause. The predicate can only refer to:\n\n\n```sql\nSELECT ...\n  FROM ...\n  [ ... ]\n  GROUP BY groupItem [ , groupItem [ , ... ] ]\n  [ ... ]\n```","basename":"corporation_selection_subq"},"corporation_updates":{"title":"Corporation Table and Recalculation Updates","tags":["snowflake"],"preview":"Given the following table named `CORPORATION`:\n\n| name          | datatype |\n| ------------- | -------- |\n| ENTITY_EMAIL  | str      |\n| PF_STATE      | str      |\n| STATUS        | str      |\n| CREATION_DATE | date     |\n\n\n\n\n## Add Email Count Column\n\nUpdate the `CORPORATION` table to add a column named `pf_state_company_per_email_count` that will store the count of emails per company per state in the state of `Florida` = `FL`.\n\n\n\n## Switch Case Update Dates\n\nAdd Datetime Column named `pf_cta_due_date` to the `CORPORATION` table and set the value of the column based on the following rules:\n- If the `CREATION_DATE` is before `2024-01-01`, set the `pf_cta_due_date` to `2025-01-01`.\n- If the `CREATION_DATE` is on or after `2024-01-01` and before `2025-01-01`, set the `pf_cta_due_date` to 90 days after the `CREATION_DATE`.\n- If the `CREATION_DATE` is on or after `2025-01-01`, set the `pf_cta_due_date` to 30 days after the `CREATION_DATE`.","basename":"corporation_updates"},"count-all-possible-routes":{"title":"Count All Possible Routes","description":"Notice that fuel cannot become negative at any point in time, and that you are allowed to visit any city more than once (including start and finish).","tags":["hard","grand-dp","general-multi-d"],"link":"https://leetcode.com/problems/count-all-possible-routes/","images":[],"preview":"### Description\n\nYou are given an array of distinct positive integers locations where locations[i] represents the position of city i. You are also given integers start, finish and fuel representing the starting city, ending city, and the initial amount of fuel you have, respectively.\n\nAt each step, if you are at city i, you can pick any city j such that j != i and 0 <= j < locations.length and move to city j. Moving from city i to city j reduces the amount of fuel you have by |locations[i] - locations[j]|. Please notice that |x| denotes the absolute value of x.\n\nNotice that fuel cannot become negative at any point in time, and that you are allowed to visit any city more than once (including start and finish).\n\nReturn the count of all possible routes from start to finish. Since the answer may be too large, return it modulo 10^9 + 7.\n\n### Example 1\n\n```bash\nInput: locations = [2,3,6,8,4], start = 1, finish = 3, fuel = 5\nOutput: 4\nExplanation: The following are all possible routes, each uses 5 units of fuel:\n1 -> 3\n1 -> 2 -> 3\n1 -> 4 -> 3\n1 -> 4 -> 2 -> 3\n```\n\n### Example 2\n\n```bash\nInput: locations = [4,3,1], start = 1, finish = 0, fuel = 6\nOutput: 5\nExplanation: The following are all possible routes:\n1 -> 0, used fuel = 1\n1 -> 2 -> 0, used fuel = 5\n1 -> 2 -> 1 -> 0, used fuel = 5\n1 -> 0 -> 1 -> 0, used fuel = 3\n1 -> 0 -> 1 -> 0 -> 1 -> 0, used fuel = 5\n```\n\n### Constraints:\n\n- 2 <= locations.length <= 100\n- 1 <= locations[i] <= 109\n- All integers in locations are distinct.\n- 0 <= start, finish < locations.length\n- 1 <= fuel <= 200","basename":"count-all-possible-routes"},"count-complete-tree-nodes":{"title":"Count Complete Tree Nodes","description":"Design an algorithm that runs in less than O(n) time complexity.","tags":["easy","binary-tree"],"link":"https://leetcode.com/problems/count-complete-tree-nodes","images":[],"preview":"### Description\n\nGiven the root of a complete binary tree, return the number of the nodes in the tree.\n\nAccording to Wikipedia, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.\n\nDesign an algorithm that runs in less than O(n) time complexity.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2021/01/14/complete.jpg)\n\n```bash\nInput: root = [1,2,3,4,5,6]\nOutput: 6\n```\n\n### Example 2\n\n```bash\nInput: root = []\nOutput: 0\n```\n\n### Example 3\n\n```bash\nInput: root = [1]\nOutput: 1\n```\n\n\n### Constraints:\n\n- The number of nodes in the tree is in the range [0, 5 * 104].\n- 0 <= Node.val <= 5 * 104\n- The tree is guaranteed to be complete.","basename":"count-complete-tree-nodes"},"count-good-nodes-in-binary-tree":{"title":"Count Good Nodes in Binary Tree","description":"Given a binary tree root, a node X in the tree is named good if in the path from root to X there are no nodes with a value greater than X.","tags":["neetcode","medium","binary-tree"],"link":"https://leetcode.com/problems/count-good-nodes-in-binary-tree/","images":["https://assets.leetcode.com/uploads/2020/04/02/test_sample_1.png","https://assets.leetcode.com/uploads/2020/04/02/test_sample_2.png"],"preview":"### Description\n\nGiven a binary tree root, a node X in the tree is named good if in the path from root to X there are no nodes with a value greater than X.\n\nReturn the number of **good** nodes in the binary tree.\n\n \n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2020/04/02/test_sample_1.png)\n\n```bash\nInput: root = [3,1,4,3,null,1,5]\nOutput: 4\n\n\nExplanation: Nodes in blue are good.\nRoot Node (3) is always a good node.\nNode 4 -> (3,4) is the maximum value in the path starting from the root.\nNode 5 -> (3,4,5) is the maximum value in the path\nNode 3 -> (3,1,3) is the maximum value in the path.\n```\n\n### Example 2\n\n![](https://assets.leetcode.com/uploads/2020/04/02/test_sample_2.png)\n\n```bash\n\n```bash\nInput: root = [3,3,null,4,2]\nOutput: 3\nExplanation: Node 2 -> (3, 3, 2) is not good, because \"3\" is higher than it.\n```\n\n### Example 3\n\n```bash\nInput: root = [1]\nOutput: 1\nExplanation: Root is considered as good.\n```\n\n### Constraints:\n\n- The number of nodes in the binary tree is in the range [1, 10^5]. \n- Each node's value is between [-10^4, 10^4].","basename":"count-good-nodes-in-binary-tree"},"count-nice-pairs-in-an-array":{"title":"Count Nice Pairs in an Array","description":"Count nice","tags":["mid","grand-dp","general-multi-d"],"link":null,"images":[],"preview":"### Description\n\nYou are given an array nums that consists of non-negative integers. Let us define rev(x) as the reverse of the non-negative integer x. For example, rev(123) = 321, and rev(120) = 21. A pair of indices (i, j) is nice if it satisfies all of the following conditions:\n\n0 <= i < j < nums.length\nnums[i] + rev(nums[j]) == nums[j] + rev(nums[i])\nReturn the number of nice pairs of indices. Since that number can be too large, return it modulo 109 + 7.\n\n \n\n### Example 1\n\n```bash\nInput: nums = [42,11,1,97]\nOutput: 2\nExplanation: The two pairs are:\n - (0,3) : 42 + rev(97) = 42 + 79 = 121, 97 + rev(42) = 97 + 24 = 121.\n - (1,2) : 11 + rev(1) = 11 + 1 = 12, 1 + rev(11) = 1 + 11 = 12.\n```\n\n### Example 2\n\n```bash\nInput: nums = [13,10,35,24,76]\nOutput: 4\n```\n\n### Constraints:\n\n- 1 <= nums.length <= 105\n- 0 <= nums[i] <= 109","basename":"count-nice-pairs-in-an-array"},"count-number-of-homogenous-substrings":{"title":"Count Number of Homogenous Substrings","description":"Given a string s, return the number of homogenous substrings of s. Since the answer may be too large, return it modulo 109 + 7.","tags":["medium","string","math","daily-challenge"],"link":"https://leetcode.com/problems/count-number-of-homogenous-substrings/","images":[],"preview":"### Description\n\nGiven a string s, return the number of homogenous substrings of s. Since the answer may be too large, return it modulo 109 + 7.\n\nA string is homogenous if all the characters of the string are the same.\n\nA substring is a contiguous sequence of characters within a string.\n\n### Example 1\n\n```bash\nInput: s = \"abbcccaa\"\nOutput: 13\nExplanation: The homogenous substrings are listed as below:\n\"a\"   appears 3 times.\n\"aa\"  appears 1 time.\n\"b\"   appears 2 times.\n\"bb\"  appears 1 time.\n\"c\"   appears 3 times.\n\"cc\"  appears 2 times.\n\"ccc\" appears 1 time.\n3 + 1 + 2 + 1 + 3 + 2 + 1 = 13.\n```\n\n### Example 2\n\n```bash\nInput: s = \"xy\"\nOutput: 2\nExplanation: The homogenous substrings are \"x\" and \"y\".\n```\n\n### Example 3\n\n```bash\nInput: s = \"zzzzz\"\nOutput: 15\n```\n\n### Constraints:\n\n- 1 <= s.length <= 105\n- s consists of lowercase letters.","basename":"count-number-of-homogenous-substrings"},"count-substrings-without-repeating-character":{"title":"Count Substrings Without Repeating Characters","description":"abcd -> a, b, c, d, ab, bc, cd, abc, bcd, abcd = 10","tags":["medium","premium"],"link":"https://leetcode.com/problems/count-substrings-without-repeating-character/description/?envType=weekly-question&envId=2024-06-22","images":[],"preview":"### Description\n\nu are given a string s consisting only of lowercase English letters. We call a substring special if it contains no character which has occurred at least twice (in other words, it does not contain a repeating character). Your task is to count the number of special substrings. For example, in the string \"pop\", the substring \"po\" is a special substring, however, \"pop\" is not special (since 'p' has occurred twice).\n\nReturn the number of special substrings.\n\nA **substring** is a contiguous sequence of characters within a string. For example, \"abc\" is a substring of \"abcd\", but \"acd\" is not.\n\n \n\n### Example 1\n\n```bash\nInput: s = \"abcd\"\nOutput: 10\nExplanation: Since each character occurs once, every substring is a special substring. We have 4 substrings of length one, 3 of length two, 2 of length three, and 1 substring of length four. So overall there are 4 + 3 + 2 + 1 = 10 special substrings.\n```\n\n### Example 2\n\n```bash\nInput: s = \"ooo\"\nOutput: 3\nExplanation: Any substring with a length of at least two contains a repeating character. So we have to count the number of substrings of length one, which is 3.\n```\n\n### Example 3\n\n```bash\nInput: s = \"abab\"\nOutput: 7\nExplanation: Special substrings are as follows (sorted by their start positions):\nSpecial substrings of length 1: \"a\", \"b\", \"a\", \"b\"\nSpecial substrings of length 2: \"ab\", \"ba\", \"ab\"\nAnd it can be shown that there are no special substrings with a length of at least three. So the answer would be 4 + 3 = 7.\n```\n\n\n### Constraints:\n\n- 1 <= s.length <= 105\n- s consists of lowercase English letters","basename":"count-substrings-without-repeating-character"},"count-vowels-permutation":{"title":"Count Vowels Permutation","description":"Given an integer n, your task is to count how many strings of length n can be formed under the following rules.","tags":["hard","dp","general-1d"],"link":"https://leetcode.com/problems/count-vowels-permutation","images":[],"preview":"### Description\n\nGiven an integer n, your task is to count how many strings of length n can be formed under the following rules:\n\nEach character is a lower case vowel ('a', 'e', 'i', 'o', 'u')\n- Each vowel 'a' may only be followed by an 'e'.\n- Each vowel 'e' may only be followed by an 'a' or an 'i'.\n- Each vowel 'i' may not be followed by another 'i'.\n- Each vowel 'o' may only be followed by an 'i' or a 'u'.\n- Each vowel 'u' may only be followed by an 'a'.\n\nSince the answer may be too large, return it modulo 10^9 + 7.\n\n \n\n### Example 1\n\n```bash\nInput: n = 1\nOutput: 5\nExplanation: All possible strings are: \"a\", \"e\", \"i\" , \"o\" and \"u\".\n```\n\n### Example 2\n\n```bash\nInput: n = 2\nOutput: 10\nExplanation: All possible strings are: \"ae\", \"ea\", \"ei\", \"ia\", \"ie\", \"io\", \"iu\", \"oi\", \"ou\" and \"ua\".\n```\n\n### Example 3\n\n```bash\nInput: n = 5\nOutput: 68\n```\n\n### Constraints:\n\n- 1 <= n <= 2 * 10^4","basename":"count-vowels-permutation"},"count-ways-to-build-good-strings":{"title":"Count Ways to Build Rooms in an Ant Colony","description":"A good string is a string constructed by the above process having a length between low and high (inclusive).","tags":["medium","dp","general-1d"],"link":"https://leetcode.com/problems/count-ways-to-build-good-strings","images":[],"preview":"### Description\n\nGiven the integers zero, one, low, and high, we can construct a string by starting with an empty string, and then at each step perform either of the following:\n\n- Append the character '0' zero times.\n- Append the character '1' one times.\nThis can be performed any number of times.\n\nA good string is a string constructed by the above process having a length between low and high (inclusive).\n\nReturn the number of different good strings that can be constructed satisfying these properties. Since the answer can be large, return it modulo 109 + 7.\n\n \n\n### Example 1\n\n```bash\nInput: low = 3, high = 3, zero = 1, one = 1\nOutput: 8\nExplanation: \nOne possible valid good string is \"011\". \nIt can be constructed as follows: \"\" -> \"0\" -> \"01\" -> \"011\". \nAll binary strings from \"000\" to \"111\" are good strings in this example.\n```\n\n### Example 2\n\n```bash\nInput: low = 2, high = 3, zero = 1, one = 2\nOutput: 5\nExplanation: The good strings are \"00\", \"11\", \"000\", \"110\", and \"011\".\n```\n\n### Constraints:\n\n- 1 <= low <= high <= 105\n- 1 <= zero, one <= low","basename":"count-ways-to-build-good-strings"},"counting-bits":{"title":"Counting Bits","description":"Given an integer n, return an array ans of length n + 1 such that for each i (0 <= i <= n), ans[i] is the number of 1's in the binary representation of i.","tags":["easy","bit-manipulation"],"link":"https://leetcode.com/problems/counting-bits/","images":[],"preview":"### Description\n\nGiven an integer `n`, return an array `ans` of length `n + 1` such that for each `i` (`0 <= i <= n`), `ans[i]` is the **number of 1's** in the binary representation of `i`.\n\n### Example 1\n\n```bash\nInput: n = 2\nOutput: [0,1,1]\nExplanation:\n0 --> 0\n1 --> 1\n2 --> 10\n```\n\n### Example 2\n\n```bash\nInput: n = 5\nOutput: [0,1,1,2,1,2]\nExplanation:\n0 --> 0\n1 --> 1\n2 --> 10\n3 --> 11\n4 --> 100\n5 --> 101\n```\n\n### Constraints:\n\n- 0 <= n <= 10^5","basename":"counting-bits"},"course-schedule-ii":{"title":"Course Schedule II","description":"Return the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.","tags":["neetcode","medium","graph","topological-sort"],"link":"https://leetcode.com/problems/course-schedule-ii/","images":[],"preview":"### Description\n\nThere are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where `prerequisites[i] = [ai, bi]` indicates that you must take course bi first if you want to take course ai.\n\nFor example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\nReturn the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return **an empty array**.\n\n### Example 1\n\n```bash\nInput: numCourses = 2, prerequisites = [[1,0]]\nOutput: [0,1]\nExplanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].\n```\n\n### Example 2\n\n```bash\nInput: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]\nOutput: [0,2,1,3]\nExplanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.\nSo one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].\n```\n\n### Example 3\n\n```bash\nInput: numCourses = 1, prerequisites = []\nOutput: [0]\n```\n\n### Constraints:\n\n- 1 <= numCourses <= 2000 \n- 0 <= prerequisites.length <= numCourses * (numCourses - 1)\n- prerequisites[i].length == 2 \n- 0 <= ai, bi < numCourses \n- ai != bi \n- All the pairs [ai, bi] are distinct.","basename":"course-schedule-ii"},"course-schedule":{"title":"Course Schedule","description":"Return true if you can finish all courses. Otherwise, return false.","tags":["neetcode","medium","graphs","topological-sort","standard-traversal"],"link":"https://leetcode.com/problems/course-schedule/","images":[],"hints":["https://wngnelson.com/assets/img_src/dsa/course_schedule.gif"],"preview":"### Description\n\nThere are a total of `numCourses` courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where `prerequisites[i] = [ai, bi]` indicates that you **must** take course bi first if you want to take course ai.\n\nFor example, the pair `[0, 1]`, indicates that to take course 0 you have to first take course 1.\nReturn true if you can finish all courses. Otherwise, return `false`.\n\n### Example 1\n\n```bash\nInput: numCourses = 2, prerequisites = [[1,0]]\nOutput: true\nExplanation: There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0. So it is possible.\n```\n\n### Example 2\n\n```bash\nInput: numCourses = 2, prerequisites = [[1,0],[0,1]]\nOutput: false\nExplanation: There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.\n```\n\n### Constraints:\n\n- 1 <= numCourses <= 2000 \n- 0 <= prerequisites.length <= 5000 \n- prerequisites[i].length == 2 \n- 0 <= ai, bi < numCourses \n- All the pairs prerequisites[i] are unique.\n\n\n### Sample Markdown Solution\n\n| Step | numCourses | prerequisites | indegree | adj | queue | traversed | node | Return |\n|------|------------|---------------|----------|-----|-------|-----------|------|--------|\n| 0    | 8          | [[1, 0], [2, 6], [1, 7], [6, 4], [7, 0], [0, 5]] | [0, 0, 0, 0, 0, 0, 0, 0] | [[], [], [], [], [], [], [], []] | [] | 0 | |\n| 1    | 8          | [[1, 0], [2, 6], [1, 7], [6, 4], [7, 0], [0, 5]] | [0, 1, 0, 0, 0, 0, 0, 0] | [[1], [], [], [], [], [], [], []] | [] | 0 | |\n| 2    | 8          | [[1, 0], [2, 6], [1, 7], [6, 4], [7, 0], [0, 5]] | [0, 1, 1, 0, 0, 0, 0, 0] | [[1], [], [], [], [], [], [2], []] | [] | 0 | |\n| 3    | 8          | [[1, 0], [2, 6], [1, 7], [6, 4], [7, 0], [0, 5]] | [0, 2, 1, 0, 0, 0, 0, 0] | [[1], [], [], [], [], [], [2], [1]] | [] | 0 | |\n| 4    | 8          | [[1, 0], [2, 6], [1, 7], [6, 4], [7, 0], [0, 5]] | [0, 2, 1, 0, 0, 0, 1, 0] | [[1], [], [], [], [6], [], [2], [1]] | [] | 0 | |\n| 5    | 8          | [[1, 0], [2, 6], [1, 7], [6, 4], [7, 0], [0, 5]] | [0, 2, 1, 0, 0, 0, 1, 1] | [[1], [], [], [], [6], [0], [2], [1]] | [] | 0 | |\n| 6    | 8          | [[1, 0], [2, 6], [1, 7], [6, 4], [7, 0], [0, 5]] | [1, 2, 1, 0, 0, 0, 1, 1] | [[1, 7], [], [], [], [6], [0], [2], [1]] | [] | 0 | |\n| 7    | 8          | [[1, 0], [2, 6], [1, 7], [6, 4], [7, 0], [0, 5]] | [1, 2, 1, 0, 0, 0, 1, 1] | [[1, 7], [], [], [], [6], [0], [2], [1]] | [3, 4] | 1 | 5 |\n| 8    | 8          | [[1, 0], [2, 6], [1, 7], [6, 4], [7, 0], [0, 5]] | [0, 2, 1, 0, 0, 0, 1, 1] | [[1, 7], [], [], [], [6], [0], [2], [1]] | [3, 4] | 2 | 0 |\n| 9    | 8          | [[1, 0], [2, 6], [1, 7], [6, 4], [7, 0], [0, 5]] | [0, 1, 1, 0, 0, 0, 1, 0] | [[1, 7], [], [], [], [6], [0], [2], [1]] | [3, 4] | 3 | 7 |\n| 10   | 8          | [[1, 0], [2, 6], [1, 7], [6, 4], [7, 0], [0, 5]] | [0, 0, 1, 0, 0, 0, 1, 0] | [[1, 7], [], [], [], [6], [0], [2], [1]] | [3, 4] | 4 | 1 |\n| 11   | 8          | [[1, 0], [2, 6], [1, 7], [6, 4], [7, 0], [0, 5]] | [0, 0, 1, 0, 0, 0, 1, 0] | [[1, 7], [], [], [], [6], [0], [2], [1]] | [3] | 5 | 4 |\n| 12   | 8          | [[1, 0], [2, 6], [1, 7], [6, 4], [7, 0], [0, 5]] | [0, 0, 1, 0, 0, 0, 0, 0] | [[1, 7], [], [], [], [6], [0], [2], [1]] | [3] | 6 | 6 |\n| 13   | 8          | [[1, 0], [2, 6], [1, 7], [6, 4], [7, 0], [0, 5]] | [0, 0, 0, 0, 0, 0, 0, 0] | [[1, 7], [], [], [], [6], [0], [2], [1]] | [3] | 7 | 2 |\n| 14   | 8          | [[1, 0], [2, 6], [1, 7], [6, 4], [7, 0], [0, 5]] | [0, 0, 0, 0, 0, 0, 0, 0] | [[1, 7], [], [], [], [6], [0], [2], [1]] | [] | 8 |","basename":"course-schedule"},"cpp-substrings-that-begin-and-end-with-the-same-letter":{"title":"Substrings That Begin and End With the Same Letter (Language Practice)","description":"Rewrite the provided code for this algorithm in diffrent languages.","tags":["language-practice"],"link":"https://leetcode.com/problems/substrings-that-begin-and-end-with-the-same-letter","images":[],"preview":"### Description\n\nYou are given a 0-indexed string s consisting of only lowercase English letters. Return the number of substrings in s that begin and end with the same character.\n\nA substring is a contiguous non-empty sequence of characters within a string.\n\n### Example 1\n\n```bash\nInput: s = \"abcba\"\nOutput: 7\nExplanation:\nThe substrings of length 1 that start and end with the same letter are: \"a\", \"b\", \"c\", \"b\", and \"a\".\nThe substring of length 3 that starts and ends with the same letter is: \"bcb\".\nThe substring of length 5 that starts and ends with the same letter is: \"abcba\".\n```\n\n### Example 2\n\n```bash\nInput: s = \"abacad\"\nOutput: 9\nExplanation:\nThe substrings of length 1 that start and end with the same letter are: \"a\", \"b\", \"a\", \"c\", \"a\", and \"d\".\nThe substrings of length 3 that start and end with the same letter are: \"aba\" and \"aca\".\nThe substring of length 5 that starts and ends with the same letter is: \"abaca\".\n```\n\n### Python Solution\n\n\n```python\nclass Solution:\n    def numberOfSubstrings(self, s: str) -> int:\n        \"\"\"\n        Ap1:\n        1. Add all single letters to resutls\n        2. Where count >= add the combinatorics of the count of the letter choose 2\n        \"\"\"\n        countLetters = {}\n        for letter in s:\n            if letter not in countLetters:\n                countLetters[letter] = 0\n            countLetters[letter] += 1\n        results = len(s) \n        for letter in countLetters:\n            count = countLetters[letter]\n            if count < 2:\n                continue\n            results += math.comb(count, 2)\n        return results\n\n```","basename":"cpp-substrings-that-begin-and-end-with-the-same-letter"},"critical-connections-in-a-network":{"title":"Critical Connections in a Network","description":"A critical connection is a connection that, if removed, will make some servers unable to reach some other server.","tags":["hard","graph","dfs"],"link":"https://leetcode.com/problems/critical-connections-in-a-network","images":[],"preview":"### Description\n\nThere are n servers numbered from 0 to n - 1 connected by undirected server-to-server connections forming a network where connections[i] = [ai, bi] represents a connection between servers ai and bi. Any server can reach other servers directly or indirectly through the network.\n\nA critical connection is a connection that, if removed, will make some servers unable to reach some other server.\n\nReturn all critical connections in the network in any order.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2019/09/03/1537_ex1_2.png)\n\n```bash\nInput: n = 4, connections = [[0,1],[1,2],[2,0],[1,3]]\nOutput: [[1,3]]\nExplanation: [[3,1]] is also accepted.\n```\n\n### Example 2\n\n```bash\nInput: n = 2, connections = [[0,1]]\nOutput: [[0,1]]\n```\n\n### Constraints:\n\n- 2 <= n <= 105\n- n - 1 <= connections.length <= 105\n- 0 <= ai, bi <= n - 1\n- ai != bi\n- There are no repeated connections.","basename":"critical-connections-in-a-network"},"daily-temperatures":{"title":"Daily Temperatures","description":"Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.","tags":["neetcode","medium","stack","sliding-window"],"link":"https://leetcode.com/problems/daily-temperatures/","images":[],"preview":"### Description\n\nGiven an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.\n\n### Example 1\n\n```bash\nInput: temperatures = [73,74,75,71,69,72,76,73]\nOutput: [1,1,4,2,1,1,0,0]\n```\n\n### Example 2\n\n```bash\nInput: temperatures = [30,40,50,60]\nOutput: [1,1,1,0]\n```\n\n### Constraints:\n\n-     1 <= temperatures.length <= 105\n-     30 <= temperatures[i] <= 100","basename":"daily-temperatures"},"decode-ways-ii":{"title":"Decode Ways II","description":"Given a string s consisting of digits and '*' characters, return the number of ways to decode it.","tags":["hard","dp","general-1d"],"link":null,"images":[],"preview":"### Description\n\nA message containing letters from A-Z can be encoded into numbers using the following mapping:\n\n\n```\n'A' -> \"1\"\n'B' -> \"2\"\n```\n\n```\n'Z' -> \"26\"\n```\n\nTo decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, \"11106\" can be mapped into:\n\n\"AAJF\" with the grouping (1 1 10 6)\n\"KJF\" with the grouping (11 10 6)\nNote that the grouping (1 11 06) is invalid because \"06\" cannot be mapped into 'F' since \"6\" is different from \"06\".\n\nIn addition to the mapping above, an encoded message may contain the '*' character, which can represent any digit from '1' to '9' ('0' is excluded). For example, the encoded message \"1*\" may represent any of the encoded messages \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", or \"19\". Decoding \"1*\" is equivalent to decoding any of the encoded messages it can represent.\n\nGiven a string s consisting of digits and '*' characters, return the number of ways to decode it.\n\nSince the answer may be very large, return it modulo 10^9 + 7.\n\n### Example 1\n\n```bash\nInput: s = \"*\"\nOutput: 9\nExplanation: The encoded message can represent any of the encoded messages \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", or \"9\".\nEach of these can be decoded to the strings \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", and \"I\" respectively.\nHence, there are a total of 9 ways to decode \"*\".\n```\n\n### Example 2\n\n```bash\nInput: s = \"1*\"\nOutput: 18\nExplanation: The encoded message can represent any of the encoded messages \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", or \"19\".\nEach of these encoded messages have 2 ways to be decoded (e.g. \"11\" can be decoded to \"AA\" or \"K\").\nHence, there are a total of 9 * 2 = 18 ways to decode \"1*\".\n```\n\n### Example 3\n\n```bash\nInput: s = \"2*\"\nOutput: 15\nExplanation: The encoded message can represent any of the encoded messages \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", or \"29\".\n\"21\", \"22\", \"23\", \"24\", \"25\", and \"26\" have 2 ways of being decoded, but \"27\", \"28\", and \"29\" only have 1 way.\nHence, there are a total of (6 * 2) + (3 * 1) = 12 + 3 = 15 ways to decode \"2*\".\n```\n\n### Constraints:\n\n- 1 <= s.length <= 105\n- s[i] is a digit or '","basename":"decode-ways-ii"},"decode-ways":{"title":"Decode Ways","description":"Given a string s containing only digits, return the number of ways to decode it.","tags":["medium","dp","neetcode"],"link":"https://leetcode.com/problems/decode-ways/","images":[],"hints":["https://wngnelson.com/assets/img_src/dsa/decodeways.gif"],"preview":"### Description\n\nA message containing letters from A-Z can be **encoded** into numbers using the following mapping:\n\n```\n'A' -> \"1\"\n'B' -> \"2\"\n...\n'Z' -> \"26\"\n```\n\nTo decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, \"11106\" can be mapped into:\n\n    \"AAJF\" with the grouping (1 1 10 6)\n    \"KJF\" with the grouping (11 10 6)\n\nNote that the grouping (1 11 06) is invalid because \"06\" cannot be mapped into 'F' since \"6\" is different from \"06\".\n\nGiven a string s containing only digits, return the **number** of ways to **decode** it.\n\nThe test cases are generated so that the answer fits in a **32-bit** integer.\n\n### Example 1\n\n```bash\nInput: s = \"12\"\nOutput: 2\nExplanation: \"12\" could be decoded as \"AB\" (1 2) or \"L\" (12).\n```\n\n### Example 2\n\n```bash\nInput: s = \"226\"\nOutput: 3\nExplanation: \"226\" could be decoded as \"BZ\" (2 26), \"VF\" (22 6), or \"BBF\" (2 2 6).\n```\n\n### Example 3\n\n```bash\nInput: s = \"06\"\nOutput: 0\nExplanation: \"06\" cannot be mapped to \"F\" because of the leading zero (\"6\" is different from \"06\").\n```\n\n\n### Constraints:\n\n- 1 <= s.length <= 100\n- s contains only digits and may contain leading zero(s).","basename":"decode-ways"},"delete-and-earn":{"title":"Delete and Earn","description":"Return the maximum number of points you can earn by applying the above operation some number of times.","tags":["medium","dp","fibonacci"],"link":"https://leetcode.com/problems/delete-and-ear","images":[],"preview":"### Description\n\nYou are given an integer array nums. You want to maximize the number of points you get by performing the following operation any number of times:\n\n- Pick any nums[i] and delete it to earn nums[i] points. Afterwards, you must delete every element equal to nums[i] - 1 and every element equal to nums[i] + 1.\n\nReturn the maximum number of points you can earn by applying the above operation some number of times.\n\n### Example 1\n\n```bash\nInput: nums = [3,4,2]\nOutput: 6\nExplanation: You can perform the following operations:\n- Delete 4 to earn 4 points. Consequently, 3 is also deleted. nums = [2].\n- Delete 2 to earn 2 points. nums = [].\nYou earn a total of 6 points.\n```\n\n### Example 2\n\n```bash\nInput: nums = [2,2,3,3,3,4]\nOutput: 9\nExplanation: You can perform the following operations:\n- Delete a 3 to earn 3 points. All 2's and 4's are also deleted. nums = [3,3].\n- Delete a 3 again to earn 3 points. nums = [3].\n- Delete a 3 once more to earn 3 points. nums = [].\nYou earn a total of 9 points.\n```\n\n### Constraints:\n\n- 1 <= nums.length <= 2 * 104\n- 1 <= nums[i] <= 104","basename":"delete-and-earn"},"depth-first-search":{"title":"Depth First Search","description":"AI Search Problem","tags":["medium","search","ai"],"preview":"### Description\n\nDepth First Search is a graph search algorithm that is often used in pathfinding and graph traversal, which is the process of visiting (checking and/or updating) each vertex in a graph. \n\n\n### Example 1\n\n\nGiven: \n\n```js\n\n        //   A____B____C\n        //   |\\   |   /\n        //   | \\  |  /\n        //   |  \\ | /\n        //   D___\\E\n        //   |\\  |\n        //   | \\ |\n        //   |__\\|\n        //   F    G\n\n        const A = new Node('A', 0, 2);\n        const B = new Node('B', 1, 2);\n        const C = new Node('C', 2, 2);\n        const D = new Node('D', 0, 1);\n        const E = new Node('E', 1, 1);\n        const G = new Node('G', 0, 0);\n        const F = new Node('F', 1, 0);\n\n        const graph = new Graph();\n        graph.addEdge(A, B);\n        graph.addEdge(A, D);\n        graph.addEdge(B, C);\n        graph.addEdge(B, E);\n        graph.addEdge(C, E);\n        graph.addEdge(D, G);\n        graph.addEdge(D, F);\n        graph.addEdge(D, E);\n        graph.addEdge(E, G);\n        graph.addEdge(G, G);\n\n        const nodes = { A, B, C, D, E, G, F };\n        return { graph: graph, nodes: nodes };\n```\n\nShould be able to find it it using depth First Search.","basename":"depth-first-search"},"design-add-and-search-words-data-structure":{"title":"Design Add and Search Words Data Structure","description":"Design a data structure that supports adding new words and finding if a string matches any previously added string.","tags":["neetcode","medium","trie"],"link":"https://leetcode.com/problems/design-add-and-search-words-data-structure/","images":[],"preview":"### Description\n\nDesign a data structure that supports adding new words and finding if a string matches any previously added string.\n\nImplement the `WordDictionary` class:\n\n- WordDictionary() Initializes the object.\n- void addWord(word) Adds word to the data structure, it can be matched later.\n- bool search(word) Returns true if there is any string in the data structure that matches word or false otherwise. word may contain dots '.' where dots can be matched with any letter.\n\n### Example 1\n\n```bash\nInput\n[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"]\n[[],[\"bad\"],[\"dad\"],[\"mad\"],[\"pad\"],[\"bad\"],[\".ad\"],[\"b..\"]]\nOutput\n[null,null,null,null,false,true,true,true]\n\nExplanation\nWordDictionary wordDictionary = new WordDictionary();\nwordDictionary.addWord(\"bad\");\nwordDictionary.addWord(\"dad\");\nwordDictionary.addWord(\"mad\");\nwordDictionary.search(\"pad\"); // return False\nwordDictionary.search(\"bad\"); // return True\nwordDictionary.search(\".ad\"); // return True\nwordDictionary.search(\"b..\"); // return True\n```\n\n\n### Constraints:\n\n- 1 <= word.length <= 25\n- word in addWord consists of lowercase English letters.\n- word in search consist of '.' or lowercase English letters.\n- There will be at most 3 dots in word for search queries.\n- At most 104 calls will be made to addWord and search.","basename":"design-add-and-search-words-data-structure"},"design-graph-with-shortest-path-calculator":{"title":"Design Graph with Shortes Path Calculator","description":"graph that returns the minimum cost of a path from node1 to node2. If no path exists, return -1. The cost of a path is the sum of the costs of the edges in the path.","tags":[],"link":"https://leetcode.com/problems/design-graph-with-shortest-path-calculator/","images":[],"preview":"### Description\n\nThere is a directed weighted graph that consists of n nodes numbered from 0 to n - 1. The edges of the graph are initially represented by the given array edges where edges[i] = [fromi, toi, edgeCosti] meaning that there is an edge from fromi to toi with the cost edgeCosti.\n\nImplement the Graph class:\n\n- Graph(int n, int[][] edges) initializes the object with n nodes and the given edges.\n- addEdge(int[] edge) adds an edge to the list of edges where edge = [from, to, edgeCost]. It is guaranteed that there is no edge between the two nodes before adding this one.\n- int shortestPath(int node1, int node2) returns the minimum cost of a path from node1 to node2. If no path exists, return -1. The cost of a path is the sum of the costs of the edges in the path.\n \n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2023/01/11/graph3drawio-2.png)\n\n```bash\nInput\n[\"Graph\", \"shortestPath\", \"shortestPath\", \"addEdge\", \"shortestPath\"]\n[[4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]], [3, 2], [0, 3], [[1, 3, 4]], [0, 3]]\nOutput\n[null, 6, -1, null, 6]\n\nExplanation\nGraph g = new Graph(4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]);\ng.shortestPath(3, 2); // return 6. The shortest path from 3 to 2 in the first diagram above is 3 -> 0 -> 1 -> 2 with a total cost of 3 + 2 + 1 = 6.\ng.shortestPath(0, 3); // return -1. There is no path from 0 to 3.\ng.addEdge([1, 3, 4]); // We add an edge from node 1 to node 3, and we get the second diagram above.\ng.shortestPath(0, 3); // return 6. The shortest path from 0 to 3 now is 0 -> 1 -> 3 with a total cost of 2 + 4 = 6.\n```\n\n\n### Constraints:\n\n- 1 <= n <= 100\n- 0 <= edges.length <= n * (n - 1)\n- edges[i].length == edge.length == 3\n- 0 <= fromi, toi, from, to, node1, node2 <= n - 1\n- 1 <= edgeCosti, edgeCost <= 106\n- There are no repeated edges and no self-loops in\n- the graph at any point.\n- At most 100 calls will be made for addEdge.\n- At most 100 calls will be made for shortestPath.","basename":"design-graph-with-shortest-path-calculator"},"design-twitter":{"title":"Design Twitter","description":"https://leetcode.com/problems/design-twitter/","tags":["neetcode","medium","heap"],"link":"https://leetcode.com/problems/design-twitter/","images":[],"preview":"### Description\n\nDesign a simplified version of Twitter where users can post tweets, follow/unfollow another user, and is able to see the 10 most recent tweets in the user's news feed.\n\nImplement the `Twitter` class:\n\n- Twitter() Initializes your twitter object.\n- void postTweet(int userId, int tweetId) Composes a new tweet with ID tweetId by the user userId. Each call to this function will be made with a unique tweetId.\n- List<Integer> getNewsFeed(int userId) Retrieves the 10 most recent tweet IDs in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user themself. Tweets must be ordered from most recent to least recent.\n- void follow(int followerId, int followeeId) The user with ID followerId started following the user with ID followeeId.\n- void unfollow(int followerId, int followeeId) The user with ID followerId started unfollowing the user with ID followeeId.\n\n### Example 1\n\n```bash\nInput\n[\"Twitter\", \"postTweet\", \"getNewsFeed\", \"follow\", \"postTweet\", \"getNewsFeed\", \"unfollow\", \"getNewsFeed\"]\n[[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]\nOutput\n[null, null, [5], null, null, [6, 5], null, [5]]\n\nExplanation\nTwitter twitter = new Twitter();\ntwitter.postTweet(1, 5); // User 1 posts a new tweet (id = 5).\ntwitter.getNewsFeed(1);  // User 1's news feed should return a list with 1 tweet id -> [5]. return [5]\ntwitter.follow(1, 2);    // User 1 follows user 2.\ntwitter.postTweet(2, 6); // User 2 posts a new tweet (id = 6).\ntwitter.getNewsFeed(1);  // User 1's news feed should return a list with 2 tweet ids -> [6, 5]. Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.\ntwitter.unfollow(1, 2);  // User 1 unfollows user 2.\ntwitter.getNewsFeed(1);  // User 1's news feed should return a list with 1 tweet id -> [5], since user 1 is no longer following user 2.\n```\n\n### Example 2\n\n```bash\n\n```\n\n### Constraints:\n\n- 1 <= userId, followerId, followeeId <= 500\n- 0 <= tweetId <= 10^4\n- All the tweets have unique IDs.\n- At most 3 * 10^4 calls will be made to postTweet, getNewsFeed, follow, and unfollow.","basename":"design-twitter"},"detect-squares":{"title":"Detect Squares","description":"An axis-aligned square is a square whose edges are all the same length and are either parallel or perpendicular to the x-axis and y-axis.","tags":["medium","dp","neetcode"],"link":"https://leetcode.com/problems/detect-squares/","images":["https://assets.leetcode.com/uploads/2021/09/01/image.png"],"preview":"### Description\n\nYou are given a stream of points on the X-Y plane. Design an algorithm that:\n\n- Adds new points from the stream into a data structure. Duplicate points are allowed and should be treated as different points.\n-  Given a query point, counts the number of ways to choose three points from the data structure such that the three points and the query point form an **axis-aligned square** with **positive area**.\n\nAn **axis-aligned square** is a square whose edges are all the same length and are either parallel or perpendicular to the x-axis and y-axis.\n\nImplement the `DetectSquares` class:\n\n- `DetectSquares()` Initializes the object with an empty data structure.\n- `void add(int[] point)` Adds a new point point = [x, y] to the data structure.\n- `int count(int[] point)` Counts the number of ways to form axis-aligned squares with point point = [x, y] as described above.\n\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2021/09/01/image.png)\n\n```bash\nInput\n[\"DetectSquares\", \"add\", \"add\", \"add\", \"count\", \"count\", \"add\", \"count\"]\n[[], [[3, 10]], [[11, 2]], [[3, 2]], [[11, 10]], [[14, 8]], [[11, 2]], [[11, 10]]]\nOutput\n[null, null, null, null, 1, 0, null, 2]\n\nExplanation\nDetectSquares detectSquares = new DetectSquares();\ndetectSquares.add([3, 10]);\ndetectSquares.add([11, 2]);\ndetectSquares.add([3, 2]);\ndetectSquares.count([11, 10]); // return 1. You can choose:\n                               //   - The first, second, and third points\ndetectSquares.count([14, 8]);  // return 0. The query point cannot form a square with any points in the data structure.\ndetectSquares.add([11, 2]);    // Adding duplicate points is allowed.\ndetectSquares.count([11, 10]); // return 2. You can choose:\n                               //   - The first, second, and third points\n                               //   - The first, third, and fourth points\n```\n\n\n### Constraints:\n\n- point.length == 2\n- 0 <= x, y <= 1000\n- At most 3000 calls in total will be made to add and count","basename":"detect-squares"},"diameter-of-binary-tree":{"title":"Diameter of Binary Tree","description":"Given the root of a binary tree, return the length of the diameter of the tree.","tags":["neetcode","easy","binary-tree"],"link":"https://leetcode.com/problems/diameter-of-binary-tree/","images":["https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg"],"hints":["https://wngnelson.com/assets/img_src/dsa/diameter.gif"],"preview":"### Description\n\nGiven the `root` of a binary tree, return the **length** of the diameter of the tree.\n\nThe **diameter** of a binary tree is the **length** of the longest path between any two nodes in a tree. This path may or may not pass through the root.\n\nThe **length** of a path between two nodes is represented by the number of edges between them.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg)\n\n```bash\nInput: root = [1,2,3,4,5]\nOutput: 3\nExplanation: 3 is the length of the path [4,2,1,3] or [5,2,1,3].\n```\n\n### Example 2\n\n```bash\nInput: root = [1,2]\nOutput: 1\n```\n\n### Constraints:\n\n- The number of nodes in the tree is in the range [1, 104]. \n- -100 <= Node.val <= 100","basename":"diameter-of-binary-tree"},"different-ways-to-add-parentheses":{"title":"Different Ways to Add Parentheses","description":"Given a string expression of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. You may return the answer in any order.","tags":["medium"],"link":"https://leetcode.com/problems/different-ways-to-add-parentheses/description/","images":[],"preview":"### Description\n\nGiven a string expression of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. You may return the answer in any order.\n\nThe test cases are generated such that the output values fit in a 32-bit integer and the number of different results does not exceed `10^4`.\n\n### Example 1\n\n```bash\nInput: expression = \"2-1-1\"\nOutput: [0,2]\nExplanation:\n((2-1)-1) = 0 \n(2-(1-1)) = 2\n```\n\n### Example 2\n\n```bash\nInput: expression = \"2-1-1\"\nOutput: [0,2]\nExplanation:\n((2-1)-1) = 0 \n(2-(1-1)) = 2\n```\n\n### Constraints:\n\n- 1 <= expression.length <= 20\n- expression consists of digits and the operator '+', '-', and '*'.\n- All the integer values in the input expression are in the range [0, 99].\n- The integer values in the input expression do not have a leading '-' or '+' denoting the sign.","basename":"different-ways-to-add-parentheses"},"dijkstra-search":{"title":"Dijkstra Search","description":"AI Search Problem","tags":["medium","search","ai"],"preview":"### Description\n\nDijkstra's search algorithm is like a game where you want to find the shortest path from your home to your friend's house. Imagine your town is made up of several intersections (vertices) connected by roads (edges). Each road has a distance (weight) associated with it.\n\nHere's how Dijkstra's algorithm works:\n\n    You start at your home, mark its distance as 0, and write it down on a list (the list is called a priority queue).\n\n    Then, you check all the neighboring intersections directly connected to your home. You calculate the distance from your home to each of these intersections and write them down on the list. The list is always sorted by distance, so the shortest distance is always at the top.\n\n    You pick the intersection with the shortest distance from the list and visit it. If it's your friend's house, you've found the shortest path! If not, repeat step 2 for this intersection: Check all its unvisited neighbors, calculate the distances, and add them to the list.\n\n    Continue visiting the intersections with the shortest distances on the list until you reach your friend's house.\n\n    To find the shortest path, trace back from your friend's house to your home, following the intersections with the smallest distances.\n\n![](./../../../img/2023-03-27-17-10-14.png)\n\n![](https://upload.wikimedia.org/wikipedia/commons/thumb/5/57/Dijkstra_Animation.gif/220px-Dijkstra_Animation.gif)\n\n\n### Example 1\n\n\nGiven: \n\n```js\n\n        //   A____B____C\n        //   |\\   |   /\n        //   | \\  |  /\n        //   |  \\ | /\n        //   D___\\E\n        //   |\\  |\n        //   | \\ |\n        //   |__\\|\n        //   F    G\n\n        const A = new Node('A', 0, 2);\n        const B = new Node('B', 1, 2);\n        const C = new Node('C', 2, 2);\n        const D = new Node('D', 0, 1);\n        const E = new Node('E', 1, 1);\n        const G = new Node('G', 0, 0);\n        const F = new Node('F', 1, 0);\n\n        const graph = new Graph();\n        graph.addEdge(A, B);\n        graph.addEdge(A, D);\n        graph.addEdge(B, C);\n        graph.addEdge(B, E);\n        graph.addEdge(C, E);\n        graph.addEdge(D, G);\n        graph.addEdge(D, F);\n        graph.addEdge(D, E);\n        graph.addEdge(E, G);\n        graph.addEdge(G, G);\n\n        const nodes = { A, B, C, D, E, G, F };\n        return { graph: graph, nodes: nodes };\n```\n\nShould be able to find it in 3 steps\n\nSample path taken:\n\n```js\n{\n  path: [\n    Node { id: 'A', x: 0, y: 2 },\n    Node { id: 'D', x: 0, y: 1 },\n    Node { id: 'G', x: 0, y: 0 }\n  ],\n  cost: 2,\n  count_searches: 6,\n  formatted_path: 'A -> D -> G',\n  exploration_path: [\n    Node { id: 'A', x: 0, y: 2 },\n    Node { id: 'B', x: 1, y: 2 },\n    Node { id: 'D', x: 0, y: 1 },\n    Node { id: 'C', x: 2, y: 2 },\n    Node { id: 'E', x: 1, y: 1 },\n    Node { id: 'G', x: 0, y: 0 }\n  ],\n  queue_snapshot: [\n    [],\n    [ { id: 'D', priority: 1 } ],\n    [ { id: 'C', priority: 2 }, { id: 'E', priority: 2 } ],\n    [\n      { id: 'E', priority: 2 },\n      { id: 'G', priority: 2 },\n      { id: 'F', priority: 2 }\n    ],\n    [ { id: 'G', priority: 2 }, { id: 'F', priority: 2 } ],\n    [ { id: 'F', priority: 2 } ]\n  ]\n}\n```\n\n\n\n```js\nassert.equal(results.path.length, 3);\n        assert.equal(results.path[0], start);\n        assert.equal(results.path[2], goal);\n```\n\n\n\n| Algorithm             | Formatted Path (Path Found) | Count Searches | Cost |\n| --------------------- | --------------------------- | -------------- | ---- |\n| AStarSearch           | A -> D -> G                 | 3              | 2    |\n| DepthFirstSearch      | A -> D -> E -> G            | 4              | 3    |\n| GreedyBestFirstSearch | A -> D -> G                 | 3              | 2    |\n| BreadthFirstSearch    | A -> D -> G                 | 6              | 2    |\n| HillClimbingSearch    | A -> D -> G                 | 2              | 2    |\n| BeamSearch(3 beams)   | A -> D -> G                 | 4              | 2    |\n| BeamSearch(1 beams)   | A -> D -> G                 | 3              | 2    |\n| DijkstraSearch        | A-> D -> G                  | 6              | 2    |","basename":"dijkstra-search"},"disk-stacking":{"title":"Disk Stacking","description":"You're given a non-empty array of arrays where each subarray holds three integers and represents a disk. These integers denote each disk's width, depth, and height, respectively. Your goal is to stack up the disks and to maximize the total height of the stack. A disk must have a strictly smaller width, depth, and height than any other disk below it.","tags":["hard","algoexpert"],"preview":"# Disk Stacking\n\nYou're given a non-empty array of arrays where each subarray holds three integers and represents a disk. These integers denote each disk's width, depth, and height, respectively. Your goal is to stack up the disks and to maximize the total height of the stack. A disk must have a strictly smaller width, depth, and height than any other disk below it.\n\nWrite a function that returns an array of the disks in the final stack, starting with the top disk and ending with the bottom disk. Note that you can't rotate disks; in other words, the integers in each subarray must represent [width, depth, height] at all times.\n\nYou can assume that there will only be one stack with the greatest total height.\n\n## Sample Input\n\n```\ndisks = [[2, 1, 2], [3, 2, 3], [2, 2, 8], [2, 3, 4], [1, 3, 1], [4, 4, 5]]\n```\n\n## Sample Output\n```\n[[2, 1, 2], [3, 2, 3], [4, 4, 5]]\n// 10 (2 + 3 + 5) is the tallest height we can get by\n// stacking disks following the rules laid out above.\n```\n\n### Hints\n\n```\nHint 1\nTry building an array of the same length as the array of disks. At each index i in this new array, store the height of the tallest tower that can be created with the disk located at index i at the bottom.\n```\n\n```\nHint 2\nConsider sorting the disks by width, depth, or height for a slight optimization.\n```\n\n```\nHint 3\nCan you efficiently keep track of potential towers in another array? Instead of storing entire sequences of disks, try storing the indices of previous disks. For example, at index 3 in this other array, store the index of the before-last disk in the tallest tower whose base is the disk at index 3.\n```\n\n```\nOptimal Space & Time Complexity\nO(n^2) time | O(n) space - where n is the number of disks\n```\nCompare this snippet from utils\\dsa-cli\\prompt\\minimum-waiting-time.md:","basename":"disk-stacking"},"domino-and-tromino-tiling":{"title":"Domino and Tromino Tiling","description":"Given an integer n, return the number of ways to tile an 2 x n board. Since the answer may be very large, return it modulo 109 + 7.","tags":["medium","dp","general-1d"],"link":"https://leetcode.com/problems/domino-and-tromino-tiling","images":[],"preview":"### Description\n\nYou have two types of tiles: a 2 x 1 domino shape and a tromino shape. You may rotate these shapes.\n\n![](https://assets.leetcode.com/uploads/2021/07/15/lc-domino.jpg)\n\nGiven an integer n, return the number of ways to tile an 2 x n board. Since the answer may be very large, return it modulo 109 + 7.\n\nIn a tiling, every square must be covered by a tile. Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile.\n\n \n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2021/07/15/lc-domino1.jpg)\n\n```bash\nInput: n = 3\nOutput: 5\nExplanation: The five different ways are show above.\n```\n\n### Example 2\n\n```bash\nInput: n = 1\nOutput: 1\n```\n\n### Constraints:\n\n- 1 <= n <= 1000","basename":"domino-and-tromino-tiling"},"edit-distance":{"title":"Edit Distance","description":"Edit Distance is a classic dynamic programming problem. It is a measure of how similar two strings are to one another. The goal is to find the minimum number of operations required to transform one string into another.","tags":[],"link":null,"images":[],"preview":"### Description\n\nGiven two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.\n\nYou have the following three operations permitted on a word:\n\n- Insert a character\n- Delete a character\n- Replace a character\n\n### Example 1\n\n```bash\nInput: word1 = \"horse\", word2 = \"ros\"\nOutput: 3\nExplanation: \nhorse -> rorse (replace 'h' with 'r')\nrorse -> rose (remove 'r')\nrose -> ros (remove 'e'\n```\n\n### Example 2\n\n```bash\nInput: word1 = \"intention\", word2 = \"execution\"\nOutput: 5\nExplanation: \nintention -> inention (remove 't')\ninention -> enention (replace 'i' with 'e')\nenention -> exention (replace 'n' with 'x')\nexention -> exection (replace 'n' with 'c')\nexection -> execution (insert 'u')\n```\n\n### Constraints:\n\n- 0 <= word1.length, word2.length <= 500\n- word1 and word2 consist of lowercase English letters.","basename":"edit-distance"},"evaluate-division":{"title":"Evaluate Division","description":"Return the answers to all queries. If a single answer cannot be determined, return -1.0.","tags":["graph","medium","standard-traversal"],"link":null,"images":[],"preview":"### Description\n\nYou are given an array of variable pairs equations and an array of real numbers values, where equations[i] = [Ai, Bi] and values[i] represent the equation Ai / Bi = values[i]. Each Ai or Bi is a string that represents a single variable.\n\nYou are also given some queries, where queries[j] = [Cj, Dj] represents the jth query where you must find the answer for Cj / Dj = ?.\n\nReturn the answers to all queries. If a single answer cannot be determined, return -1.0.\n\nNote: The input is always valid. You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.\n\nNote: The variables that do not occur in the list of equations are undefined, so the answer cannot be determined for them.\n\n \n\n### Example 1\n\n```bash\nInput: equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]\nOutput: [6.00000,0.50000,-1.00000,1.00000,-1.00000]\nExplanation: \nGiven: a / b = 2.0, b / c = 3.0\nqueries are: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? \nreturn: [6.0, 0.5, -1.0, 1.0, -1.0 ]\nnote: x is undefined => -1.0\n```\n\n### Example 2\n\n```bash\nInput: equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\nOutput: [3.75000,0.40000,5.00000,0.20000]\n```\n\n### Example 3\n\n```bash\nInput: equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]\nOutput: [0.50000,2.00000,-1.00000,-1.00000]\n```\n\n### Constraints:\n\n- 1 <= equations.length <= 20\n- equations[i].length == 2\n- 1 <= Ai.length, Bi.length <= 5\n- values.length == equations.length\n- 0.0 < values[i] <= 20.0\n- 1 <= queries.length <= 20\n- queries[i].length == 2\n- 1 <= Cj.length, Dj.length <= 5\n- Ai, Bi, Cj, Dj consist of lower case English letters and digits.","basename":"evaluate-division"},"evaluate-polish-reverse-notation":{"title":"Evaluate Reverse Polish Notation","description":"You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation.  Evaluate the expression. Return an integer that represents the value of the expression.","tags":["neetcode","medium","stack"],"link":"https://leetcode.com/problems/evaluate-reverse-polish-notation/","preview":"### Description\n\nYou are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation.\n\nEvaluate the expression. Return an integer that represents the value of the expression.\n\nNote that:\n\n    The valid operators are '+', '-', '*', and '/'.\n    Each operand may be an integer or another expression.\n    The division between two integers always truncates toward zero.\n    There will not be any division by zero.\n    The input represents a valid arithmetic expression in a reverse polish notation.\n    The answer and all the intermediate calculations can be represented in a 32-bit integer.\n\n\n### Example 1\n\n```bash\nInput: tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"]\nOutput: 9\nExplanation: ((2 + 1) * 3) = 9\n```\n\n### Example 2\n\n```bash\nInput: tokens = [\"4\",\"13\",\"5\",\"/\",\"+\"]\nOutput: 6\nExplanation: (4 + (13 / 5)) = 6\n```\n\n### Constraints:\n\n- 1 <= tokens.length <= 104\n- tokens[i] is either an operator: \"+\", \"-\", \"*\", or \"/\", or an integer in the range [-200, 200].","basename":"evaluate-polish-reverse-notation"},"factorial-trailing-zeroes":{"title":"Factorial Trailing Zeroes","description":"Given an integer n, return the number of trailing zeroes in n!.","tags":["mid","math"],"link":"https://leetcode.com/problems/factorial-trailing-zeroes","images":[],"preview":"### Description\n\n\n\n### Example 1\n\n```bash\nInput: n = 3\nOutput: 0\nExplanation: 3! = 6, no trailing zero.\n```\n\n### Example 2\n\n```bash\nInput: n = 5\nOutput: 1\nExplanation: 5! = 120, one trailing zero.\n```\n\n### Example 3\n\n```bash\nInput: n = 0\nOutput: 0\n```\n\n\n### Constraints:\n\n- 0 <= n <= 104","basename":"factorial-trailing-zeroes"},"find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree":{"title":"Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree","description":"Find all the critical and pseudo-critical edges in the given graph's minimum spanning tree (MST). An MST edge whose deletion from the graph would cause the MST weight to increase is called a critical edge. On the other hand, a pseudo-critical edge is that which can appear in some MSTs but not all.","tags":["hard","graph","minimum-spanning-tree"],"link":"https://leetcode.com/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree","images":[],"preview":"### Description\n\nGiven a weighted undirected connected graph with n vertices numbered from 0 to n - 1, and an array edges where edges[i] = [ai, bi, weighti] represents a bidirectional and weighted edge between nodes ai and bi. A minimum spanning tree (MST) is a subset of the graph's edges that connects all vertices without cycles and with the minimum possible total edge weight.\n\nFind all the critical and pseudo-critical edges in the given graph's minimum spanning tree (MST). An MST edge whose deletion from the graph would cause the MST weight to increase is called a critical edge. On the other hand, a pseudo-critical edge is that which can appear in some MSTs but not all.\n\nNote that you can return the indices of the edges in any order.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2020/06/04/ex1.png)\n\n```bash\nInput: n = 5, edges = [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]]\nOutput: [[0,1],[2,3,4,5]]\nExplanation: The figure above describes the graph.\nThe following figure shows all the possible MSTs:\n```\n\n![](https://assets.leetcode.com/uploads/2020/06/04/msts.png)\n\n```bash\nNotice that the two edges 0 and 1 appear in all MSTs, therefore they are critical edges, so we return them in the first list of the output.\nThe edges 2, 3, 4, and 5 are only part of some MSTs, therefore they are considered pseudo-critical edges. We add them to the second list of the output.\n```\n\n### Example 2\n\n![](https://assets.leetcode.com/uploads/2020/06/04/ex2.png)\n\n```bash\nInput: n = 4, edges = [[0,1,1],[1,2,1],[2,3,1],[0,3,1]]\nOutput: [[],[0,1,2,3]]\nExplanation: We can observe that since all 4 edges have equal weight, choosing any 3 edges from the given 4 will yield an MST. Therefore all 4 edges are pseudo-critical.\n```\n\n### Constraints:\n\n- 2 <= n <= 100\n- 1 <= edges.length <= min(200, n * (n - 1) / 2)\n- edges[i].length == \n- 0 <= ai < bi < n\n- 1 <= weighti <= 1000\n- All pairs (ai, bi) are distinct.","basename":"find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree"},"find-duplicate":{"title":"Find the Duplicate Number","description":"Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.","tags":["neetcode","medium","linked-list"],"link":"https://leetcode.com/problems/find-the-duplicate-number/","preview":"### Description\n\nGiven an array of integers nums containing `n + 1` integers where each integer is in the range `[1, n]` inclusive.\n\nThere is only **one repeated number** in nums, return this repeated number.\n\nYou must solve the problem **without** modifying the array nums and uses only constant extra space.\n\n### Example 1\n\n```bash\nInput: nums = [1,3,4,2,2]\nOutput: 2\n```\n\n### Example 2\n\n```bash\nInput: nums = [3,1,3,4,2]\nOutput: 3\n```\n\n### Constraints:\n\n- 1 <= n <= 10^5 \n- nums.length == n + 1 \n- 1 <= nums[i] <= n \n- All the integers in nums appear only **once** except for **precisely one** **integer** which appears **two or more** times.","basename":"find-duplicate"},"find-eventual-safe-states":{"title":"Find Eventual Safe States","description":"Return an array containing all the safe nodes of the graph. The answer should be sorted in ascending order.","tags":["medium","graph","standard-traversal"],"link":"https://leetcode.com/problems/shortest-path-with-alternating-colors","images":[],"preview":"### Description\n\nYou are given an integer n, the number of nodes in a directed graph where the nodes are labeled from 0 to n - 1. Each edge is red or blue in this graph, and there could be self-edges and parallel edges.\n\nYou are given two arrays redEdges and blueEdges where:\n\nredEdges[i] = [ai, bi] indicates that there is a directed red edge from node ai to node bi in the graph, and\nblueEdges[j] = [uj, vj] indicates that there is a directed blue edge from node uj to node vj in the graph.\nReturn an array answer of length n, where each answer[x] is the length of the shortest path from node 0 to node x such that the edge colors alternate along the path, or -1 if such a path does not exist.\n\n### Example 1\n\n```bash\nInput: n = 3, redEdges = [[0,1],[1,2]], blueEdges = []\nOutput: [0,1,-1]\n```\n\n### Example 2\n\n```bash\nInput: n = 3, redEdges = [[0,1]], blueEdges = [[2,1]]\nOutput: [0,1,-1]\n```\n\n### Constraints:\n\n- 1 <= n <= 100\n- 0 <= redEdges.length, blueEdges.length <= 400\n- redEdges[i].length == blueEdges[j].length == 2\n- 0 <= ai, bi, uj, vj < n","basename":"find-eventual-safe-states"},"find-first-and-last-position-of-element-in-sorted-array":{"title":"Find First and Last Position of Element in Sorted Array","description":"You must write an algorithm with O(log n) runtime complexity.","tags":["medium","binary-search"],"link":"https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array","images":[],"preview":"### Description\n\nGiven an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.\n\nIf target is not found in the array, return [-1, -1].\n\nYou must write an algorithm with O(log n) runtime complexity.\n\n### Example 1\n\n```bash\nInput: nums = [5,7,7,8,8,10], target = 8\nOutput: [3,4]\n```\n\n### Example 2\n\n```bash\nInput: nums = [5,7,7,8,8,10], target = 6\nOutput: [-1,-1]\n```\n\n### Example 3\n\n```bash\nInput: nums = [], target = 0\nOutput: [-1,-1]\n```\n\n### Constraints:\n\n- 0 <= nums.length <= 105\n- -109 <= nums[i] <= 109\n- nums is a non-decreasing array.\n- -109 <= target <= 109","basename":"find-first-and-last-position-of-element-in-sorted-array"},"find-k-pairs-with-smallest-sums":{"title":"Find K Pairs with Smallest Sums","description":"Return the k pairs (u1, v1), (u2, v2), ..., (uk, vk) with the smallest sums.","tags":["medium","heap"],"link":"https://leetcode.com/problems/find-k-pairs-with-smallest-sums","images":[],"preview":"### Description\n\nYou are given two integer arrays nums1 and nums2 sorted in non-decreasing order and an integer k.\n\nDefine a pair (u, v) which consists of one element from the first array and one element from the second array.\n\nReturn the k pairs (u1, v1), (u2, v2), ..., (uk, vk) with the smallest sums.\n\n### Example 1\n\n```bash\nInput: nums1 = [1,7,11], nums2 = [2,4,6], k = 3\nOutput: [[1,2],[1,4],[1,6]]\nExplanation: The first 3 pairs are returned from the sequence: [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]\n```\n\n### Example 2\n\n```bash\nInput: nums1 = [1,1,2], nums2 = [1,2,3], k = 2\nOutput: [[1,1],[1,1]]\nExplanation: The first 2 pairs are returned from the sequence: [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\n```\n\n### Example 3\n\n```bash\nInput: nums1 = [1,2], nums2 = [3], k = 3\nOutput: [[1,3],[2,3]]\nExplanation: All possible pairs are returned from the sequence: [1,3],[2,3]\n```\n\n### Constraints:\n\n- 1 <= nums1.length, nums2.length <= 105\n- -109 <= nums1[i], nums2[i] <= 109\n- nums1 and nums2 both are sorted in non-decreasing order.\n- 1 <= k <= 104","basename":"find-k-pairs-with-smallest-sums"},"find-loop":{"title":"find-loop","tags":["hard","algoexpert"],"preview":"# Find Loop\n\nWrite a function that takes in the head of a Singly Linked List that contains a loop (in other words, the list's tail node points to some node in the list instead of None / null). The function should return the node (the actual node--not just its value) from which the loop originates in constant space.\n\nEach LinkedList node has an integer value as well as a next node pointing to the next node in the list.\n\n## Sample Input\n\n``` \nhead = 0 -> 1 -> 2 -> 3 -> 4 -> 5 -> 6 // the head node with value 0\n                           ^         v\n                           9 <- 8 <- 7\n```\n\n## Sample Output\n\n```\n4 -> 5 -> 6 // the node with value 4\n^         v\n9 <- 8 <- 7\n```\n\n### Hints\n\nHint 1\n> Try traversing the linked list with two pointers, one iterating through every single node in the list and another iterating through every other node in the list (skipping a node every time). Eventually, both pointers will point to the same node since there is a loop in the list and since one pointer is moving faster than the other. Stop once the pointers overlap each other. How can you find the origin of the loop from here?\n\nHint 2\n> Can you come up with a mathematical relation between the respective distances traveled by each pointer? How far will the first pointer have traveled when the pointers overlap? What about the second pointer? How can this relation then help you find the actual origin of the loop in the list?\n\nHint 3\n> Let D be the distance between the start of the linked list and the origin of the loop in the list. Let P be distance between the origin of the loop and the node N where the first and second pointers overlap (going in the primary direction of the list). By the time the pointers reach N, the first pointer will have traveled a distance of length D + P, and the second pointer will have traveled a distance of length 2D + 2P, since it will have traveled twice as much as the first pointer. Thus, the distance between N and the origin of the loop (going in the primary direction of the list) can be arithmetically deduced to be 2D + 2P - D - 2P = D. With both pointers D length away from the origin of the loop, how can you find the origin?\n\n```\nOptimal Space & Time Complexity\nO(n) time | O(1) space - where n is the number of nodes in the Linked List\n```","basename":"find-loop"},"find-median-from-data-stream":{"title":"Find Median from Data Stream","description":"The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.","tags":["neetcode","hard","heap"],"link":"https://leetcode.com/problems/find-median-from-data-stream/","images":[],"hints":"https://wngnelson.com/assets/img_src/dsa/mediandata.gif","preview":"### Description\n\nThe **median** is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.\n\n- For example, for arr = [2,3,4], the median is 3.\n- For example, for arr = [2,3], the median is (2 + 3) / 2 = 2.5.\n\nImplement the MedianFinder class:\n\n- MedianFinder() initializes the MedianFinder object.\n- void addNum(int num) adds the integer num from the data stream to the data structure.\n- double findMedian() returns the median of all elements so far. Answers within 10-5 of the actual answer will be accepted.\n\n### Example 1\n\n```bash\nInput\n[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"]\n[[], [1], [2], [], [3], []]\nOutput\n[null, null, null, 1.5, null, 2.0]\n\nExplanation\nMedianFinder medianFinder = new MedianFinder();\nmedianFinder.addNum(1);    // arr = [1]\nmedianFinder.addNum(2);    // arr = [1, 2]\nmedianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2)\nmedianFinder.addNum(3);    // arr[1, 2, 3]\nmedianFinder.findMedian(); // return 2.0\n```\n\n\n### Constraints:\n\n- -10^5 <= num <= 10^5 \n- There will be at least one element in the data structure before calling findMedian. \n- At most 5 * 10^4 calls will be made to addNum and findMedian.\n\n\n### Follow up:\n\n- If all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?\n- If 99% of all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?","basename":"find-median-from-data-stream"},"find-min":{"title":"Find Minimum in Rotated Sorted Array","description":"Given the sorted rotated array nums of unique elements, return the minimum element of this array.","tags":["neetcode","medium","binary-search"],"link":"https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/","preview":"### Description\n\nSuppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:\n\n    `[4,5,6,7,0,1,2]` if it was rotated 4 times.\n    `[0,1,2,4,5,6,7]` if it was rotated 7 times.\n\nNotice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].\n\nGiven the sorted rotated array nums of unique elements, return the minimum element of this array.\n\nYou must write an algorithm that runs in O(log n) time.\n\n### Example 1\n\n```bash\nInput: nums = [3,4,5,1,2]\nOutput: 1\nExplanation: The original array was [1,2,3,4,5] rotated 3 times.\n```\n\n### Example 2\n\n```bash\nInput: nums = [4,5,6,7,0,1,2]\nOutput: 0\nExplanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.\n```\n\n### Constraints:\n\n-      n == nums.length     \n-      1 <= n <= 5000     \n-      -5000 <= nums[i] <= 5000     \n-      All the integers of nums are unique.     \n-      nums is sorted and rotated between 1 and n times.","basename":"find-min"},"find-minimum-in-rotated-sorted-array":{"title":"Find Minimum in Rotated Sorted Array","description":"Given the sorted rotated array nums of unique elements, return the minimum element of this array. You must write an algorithm that runs in O(log n) time.","tags":["medium","binary-search"],"link":"https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/","images":[],"preview":"### Description\n\nSuppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:\n\n[4,5,6,7,0,1,2] if it was rotated 4 times.\n[0,1,2,4,5,6,7] if it was rotated 7 times.\nNotice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].\n\nGiven the sorted rotated array nums of unique elements, return the minimum element of this array.\n\nYou must write an algorithm that runs in O(log n) time.\n\n### Example 1\n\n```bash\nInput: nums = [3,4,5,1,2]\nOutput: 1\nExplanation: The original array was [1,2,3,4,5] rotated 3 times.\n```\n\n### Example 2\n\n```bash\nInput: nums = [4,5,6,7,0,1,2]\nOutput: 0\nExplanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.\n```\n\n### Example 3\n\n```bash\nInput: nums = [11,13,15,17]\nOutput: 11\nExplanation: The original array was [11,13,15,17] and it was rotated 4 times. \n```\n\n### Constraints:\n\n- n == nums.length\n- 1 <= n <= 5000\n- -5000 <= nums[i] <= 5000\n- All the integers of nums are unique.\n- nums is sorted and rotated between 1 and n times.","basename":"find-minimum-in-rotated-sorted-array"},"find-nodes-distance-k":{"title":"Find Nodes Distance K","description":"Find Nodes Distance","tags":["hard","algoexpert"],"link":null,"images":[],"preview":"# Find Nodes Distance K\n\nYou're given the root node of a Binary Tree, a target value of a node that's contained in the tree, and a positive integer k. Write a function that returns the values of all the nodes that are exactly distance k from the node with target value.\n\nThe distance between two nodes is defined as the number of edges that must be traversed to go from one node to the other. For example, the distance between a node and its immediate left or right child is 1. The same holds in reverse: the distance between a node and its parent is 1. In a tree of three nodes where the root node has a left and right child, the left and right children are distance 2 from each other.\n\nEach BinaryTree node has an integer value, a left child node, and a right child node. Children nodes can either be BinaryTree nodes themselves or None / null.\n\nNote that all BinaryTree node values will be unique, and your function can return the output values in any order.\n\n## Sample Input\n\n``` \ntree = 1\n     /   \\\n    2     3\n  /   \\     \\\n 4     5     6\n           /   \\\n          7     8\ntarget = 3\nk = 2\n```\n\n## Sample Output\n\n```\n[2, 7, 8] // These values could be ordered differently.\n```\n\n### Hints\n\nHint 1\n> Would it be easier to solve this problem if you had information about every node's parent node?\n\nHint 2\n> One approach to this problem is to find the parent nodes of all nodes in the tree. With this information you can perform a breadth-first search starting at the target node and traverse through each neighbor (left, right, and parent node) of every node, keeping track of your distance from the target node at each iteration. Once you reach a node that is distance k from the target node, you can add it to your output array. You'll have to also keep track of which nodes you've visited so as to avoid visiting the same nodes over and over again.\n\nHint 3\n> Another approach is to use a recursive depth-first-search algorithm as follows:\n>   1. Case #1: when currentNode == target, search the subtree rooted at currentNode for all nodes that are k distance from currentNode.\n>   2. Case #2: when target is in the left subtree of currentNode at distance L + 1, look for nodes that are distance k - L - 1 in the right subtree of currentNode. \n>   3. Case #3: when target is in the right subtree of currentNode at distance L + 1, do the same thing as in case #2 but in the opposite subtree. \n>   4. Case #4: when target is neither in the left nor in right subtree of currentNode, stop recursing.\n\n```\nOptimal Space & Time Complexity\nO(n) time | O(n) space - where n is the number of nodes in the tree\n```","basename":"find-nodes-distance-k"},"find-peak-element":{"title":"Find Peak Element","description":"You must write an algorithm that runs in O(log n) time.","tags":["medium","binary-search"],"link":"https://leetcode.com/problems/find-peak-element","images":[],"preview":"### Description\n\nA peak element is an element that is strictly greater than its neighbors.\n\nGiven a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.\n\nYou may imagine that nums[-1] = nums[n] = -. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.\n\nYou must write an algorithm that runs in O(log n) time.\n\n### Example 1\n\n```bash\nInput: nums = [1,2,3,1]\nOutput: 2\nExplanation: 3 is a peak element and your function should return the index number 2.\n```\n\n### Example 2\n\n```bash\nInput: nums = [1,2,1,3,5,6,4]\nOutput: 5\nExplanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.\n```\n\n### Constraints:\n\n- 1 <= nums.length <= 1000\n- -231 <= nums[i] <= 231 - 1\n- nums[i] != nums[i + 1] for all valid i.","basename":"find-peak-element"},"find-the-celebrity":{"title":"Find The Celebrity","description":"Return the celebrity's label if there is a celebrity at the party. If there is no celebrity, return -1","tags":["medium"],"link":"https://leetcode.com/problems/find-the-celebrity/description/","images":[],"preview":"### Description\n\nSuppose you are at a party with n people labeled from 0 to n - 1 and among them, there may exist one celebrity. The definition of a celebrity is that all the other n - 1 people know the celebrity, but the celebrity does not know any of them.\n\nNow you want to find out who the celebrity is or verify that there is not one. You are only allowed to ask questions like: \"Hi, A. Do you know B?\" to get information about whether A knows B. You need to find out the celebrity (or verify there is not one) by asking as few questions as possible (in the asymptotic sense).\n\nYou are given a helper function bool knows(a, b) that tells you whether a knows b. Implement a function int findCelebrity(n). There will be exactly one celebrity if they are at the party.\n\nReturn the celebrity's label if there is a celebrity at the party. If there is no celebrity, return -1.\n\n### Example 1\n\n```bash\nInput: graph = [[1,1,0],[0,1,0],[1,1,1]]\nOutput: 1\nExplanation: There are three persons labeled with 0, 1 and 2. graph[i][j] = 1 means person i knows person j, otherwise graph[i][j] = 0 means person i does not know person j. The celebrity is the person labeled as 1 because both 0 and 2 know him but 1 does not know anybody.\n```\n\n### Example 2\n\n```bash\nInput: graph = [[1,0,1],[1,1,0],[0,1,1]]\nOutput: -1\nExplanation: There is no celebrity.\n```\n\n### Constraints:\n\n- n == graph.length == graph[i].length\n- 2 <= n <= 100\n- graph[i][j] is 0 or 1.\n- graph[i][i] == 1","basename":"find-the-celebrity"},"find-the-duplicate-number":{"title":"Find the Duplicate Number","description":"Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.","tags":["neetcode","medium","linked-list"],"link":"https://leetcode.com/problems/find-the-duplicate-number/","preview":"### Description\n\nGiven an array of integers nums containing `n + 1` integers where each integer is in the range `[1, n]` inclusive.\n\nThere is only **one repeated number** in nums, return this repeated number.\n\nYou must solve the problem **without** modifying the array nums and uses only constant extra space.\n\n### Example 1\n\n```bash\nInput: nums = [1,3,4,2,2]\nOutput: 2\n```\n\n### Example 2\n\n```bash\nInput: nums = [3,1,3,4,2]\nOutput: 3\n```\n\n### Constraints:\n\n- 1 <= n <= 10^5 \n- nums.length == n + 1 \n- 1 <= nums[i] <= n \n- All the integers in nums appear only **once** except for **precisely one** **integer** which appears **two or more** times.","basename":"find-the-duplicate-number"},"find-the-longest-valid-obstacle-course-at-each-position":{"title":"Find the Longest Valid Obstacle Course at Each Position","description":"Return an array ans of length n, where ans[i] is the length of the longest obstacle course for index i as described above.","tags":["hard","dp","longest-increasing-subsequence"],"link":"https://leetcode.com/problems/find-the-longest-valid-obstacle-course-at-each-position","images":[],"preview":"### Description\n\nYou want to build some obstacle courses. You are given a 0-indexed integer array obstacles of length n, where obstacles[i] describes the height of the ith obstacle.\n\nFor every index i between 0 and n - 1 (inclusive), find the length of the longest obstacle course in obstacles such that:\n\n- You choose any number of obstacles between 0 and i inclusive.\n- You must include the ith obstacle in the course.\n- You must put the chosen obstacles in the same order as they appear in obstacles.\n\nEvery obstacle (except the first) is taller than or the same height as the obstacle immediately before it.\nReturn an array ans of length n, where ans[i] is the length of the longest obstacle course for index i as described above.\n\n### Example 1\n\n```bash\nInput: obstacles = [1,2,3,2]\nOutput: [1,2,3,3]\nExplanation: The longest valid obstacle course at each position is:\n- i = 0: [1], [1] has length 1.\n- i = 1: [1,2], [1,2] has length 2.\n- i = 2: [1,2,3], [1,2,3] has length 3.\n- i = 3: [1,2,3,2], [1,2,2] has length 3.\n```\n\n### Example 2\n\n```bash\nInput: obstacles = [2,2,1]\nOutput: [1,2,1]\nExplanation: The longest valid obstacle course at each position is:\n- i = 0: [2], [2] has length 1.\n- i = 1: [2,2], [2,2] has length 2.\n- i = 2: [2,2,1], [1] has length 1.\n```\n\n### Example 3\n\n```bash\nInput: obstacles = [3,1,5,6,4,2]\nOutput: [1,1,2,3,2,2]\nExplanation: The longest valid obstacle course at each position is:\n- i = 0: [3], [3] has length 1.\n- i = 1: [3,1], [1] has length 1.\n- i = 2: [3,1,5], [3,5] has length 2. [1,5] is also valid.\n- i = 3: [3,1,5,6], [3,5,6] has length 3. [1,5,6] is also valid.\n- i = 4: [3,1,5,6,4], [3,4] has length 2. [1,4] is also valid.\n- i = 5: [3,1,5,6,4,2], [1,2] has length 2.\n```\n\n\n### Constraints:\n\n- n == obstacles.length\n- 1 <= n <= 105\n- 1 <= obstacles[i] <= 107","basename":"find-the-longest-valid-obstacle-course-at-each-position"},"find-the-town-judge":{"title":"Find the Town Judge","description":"Return the label of the town judge if the town judge exists and can be identified, or return -1 otherwise.","tags":["easy","graph","graph-theory"],"link":"https://leetcode.com/problems/find-the-town-judge","images":[],"preview":"### Description\n\nIn a town, there are n people labeled from 1 to n. There is a rumor that one of these people is secretly the town judge.\n\nIf the town judge exists, then:\n\n1. The town judge trusts nobody.\n2. Everybody (except for the town judge) trusts the town judge.\n3. There is exactly one person that satisfies properties 1 and 2.\n\nYou are given an array trust where trust[i] = [ai, bi] representing that the person labeled ai trusts the person labeled bi. If a trust relationship does not exist in trust array, then such a trust relationship does not exist.\n\nReturn the label of the town judge if the town judge exists and can be identified, or return -1 otherwise.\n\n### Example 1\n\n```bash\nInput: n = 2, trust = [[1,2]]\nOutput: 2\n```\n\n### Example 2\n\n```bash\nInput: n = 3, trust = [[1,3],[2,3]]\nOutput: 3\n```\n\n### Example 3 \n\n```bash\nInput: n = 3, trust = [[1,3],[2,3],[3,1]]\nOutput: -1\n```\n\n### Constraints:\n\n- 1 <= n <= 1000\n- 0 <= trust.length <= 104\n- trust[i].length == 2\n- All the pairs of trust are unique.\n- ai != bi\n- 1 <= ai, bi <= n","basename":"find-the-town-judge"},"find-unique-binary-string":{"title":"Find Unique Binary String","description":"Given an array of strings nums containing n unique binary strings each of length n, return a binary string of length n that does not appear in nums. If there are multiple answers, you may return any of them.","tags":["medium","daily-leetcode"],"link":"https://leetcode.com/problems/find-unique-binary-string/","images":[],"preview":"### Description\n\nGiven an array of strings nums containing `n` unique binary strings each of length `n`, return a binary string of length `n` that does not appear in nums. If there are multiple answers, you may return any of them.\n\n### Example 1\n\n```bash\nInput: nums = [\"01\",\"10\"]\nOutput: \"11\"\nExplanation: \"11\" does not appear in nums. \"00\" would also be correct.\n```\n\n### Example 2\n\n```bash\nInput: nums = [\"00\",\"01\"]\nOutput: \"11\"\nExplanation: \"11\" does not appear in nums. \"10\" would also be correct.\n```\n\n### Example 3\n\n```bash\nInput: nums = [\"111\",\"011\",\"001\"]\nOutput: \"101\"\nExplanation: \"101\" does not appear in nums. \"000\", \"010\", \"100\", and \"110\" would also be correct.\n```\n\n### Constraints:\n\n- n == nums.length\n- 1 <= n <= 16\n- nums[i].length == n\n- nums[i] is either '0' or '1'.\n- All the strings of nums are unique.","basename":"find-unique-binary-string"},"flatten-binary-tree-to-linked-list":{"title":"Flatten Binary Tree to Linked List","description":"Given the root of a binary tree, flatten the tree into a \"linked list\"","tags":["binary-tree","medium"],"link":null,"images":[],"preview":"### Description\n\nGiven the root of a binary tree, flatten the tree into a \"linked list\"\n\n- The \"linked list\" should use the same TreeNode class where the right child pointer points to the next node in the list and the left child pointer is always null.\n- The \"linked list\" should be in the same order as a pre-order traversal of the binary tree.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg)\n\n```bash\nInput: root = [1,2,5,3,4,null,6]\nOutput: [1,null,2,null,3,null,4,null,5,null,6]\n```\n\n### Example 2\n\n```bash\nInput: root = []\nOutput: []\n```\n\n### Example 3\n\n```bash\nInput: root = [0]\nOutput: [0]\n```\n\n### Constraints:\n\n- The number of nodes in the tree is in the range [0, 2000].\n- -100 <= Node.val <= 100","basename":"flatten-binary-tree-to-linked-list"},"frog-jump":{"title":"Frog Jump","description":"A frog is crossing a river. The river is divided into some number of units, and at each unit, there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water.","tags":["hard","grand-dp","general-multi-d"],"link":"https://leetcode.com/problems/frog-jump","images":[],"preview":"### Description\n\nA frog is crossing a river. The river is divided into some number of units, and at each unit, there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water.\n\nGiven a list of stones positions (in units) in sorted ascending order, determine if the frog can cross the river by landing on the last stone. Initially, the frog is on the first stone and assumes the first jump must be 1 unit.\n\nIf the frog's last jump was k units, its next jump must be either k - 1, k, or k + 1 units. The frog can only jump in the forward direction.\n\n### Example 1\n\n```bash\nInput: stones = [0,1,3,5,6,8,12,17]\nOutput: true\nExplanation: The frog can jump to the last stone by jumping 1 unit to the 2nd stone, then 2 units to the 3rd stone, then 2 units to the 4th stone, then 3 units to the 6th stone, 4 units to the 7th stone, and 5 units to the 8th stone.\n```\n\n### Example 2\n\n```bash\nInput: stones = [0,1,2,3,4,8,9,11]\nOutput: false\nExplanation: There is no way to jump to the last stone as the gap between the 5th and 6th stone is too large.\n```\n\n### Constraints:\n\n- 2 <= stones.length <= 2000\n- 0 <= stones[i] <= 231 - 1\n- stones[0] == 0\n- stones is sorted in a strictly increasing order.","basename":"frog-jump"},"game-of-life":{"title":"Game of Life","description":"The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.","tags":["matrix","leetcode"],"link":"https://leetcode.com/problems/game-of-life/","images":[],"preview":"### Description\n\nAccording to Wikipedia's article: \"The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.\"\n\nThe board is made up of an m x n grid of cells, where each cell has an initial state: live (represented by a 1) or dead (represented by a 0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):\n\nAny live cell with fewer than two live neighbors dies as if caused by under-population.\nAny live cell with two or three live neighbors lives on to the next generation.\nAny live cell with more than three live neighbors dies, as if by over-population.\nAny dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.\nThe next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. Given the current state of the m x n grid board, return the next state.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2020/12/26/grid1.jpg)\n\n```bash\nInput: board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]\nOutput: [[0,0,0],[1,0,1],[0,1,1],[0,1,0]]\n```\n\n### Example 2\n\n![](https://assets.leetcode.com/uploads/2020/12/26/grid2.jpg)\n\n```bash\nInput: board = [[1,1],[1,0]]\nOutput: [[1,1],[1,1]]\n```\n\n### Constraints:\n\n- m == board.length\n- n == board[i].length\n- 1 <= m, n <= 25\n- board[i][j] is 0 or 1","basename":"game-of-life"},"gas-station":{"title":"Gas Station","description":"There are n gas stations along a circular route, where the amount of gas at the ith station is gas[i].","tags":["greedy","medium","neetcode","solved"],"link":"https://leetcode.com/problems/gas-station/","hints":["https://wiki.anviltech.net/images/Gasstation.gif"],"preview":"### Description\n\nThere are `n` gas stations along a circular route, where the amount of gas at the `ith` station is `gas[i]`.\n\nYou have a car with an unlimited gas tank and it costs `cost[i]` of gas to travel from the `ith` station to its next (i + 1)th station. You begin the journey with an empty tank at one of the gas stations.\n\nGiven two integer arrays `gas` and `cost`, return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return `-1`. If there exists a solution, it is guaranteed to be unique\n\n### Example 1\n\n```bash\nInput: gas = [1,2,3,4,5], cost = [3,4,5,1,2]\nOutput: 3\nExplanation:\nStart at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 4. Your tank = 4 - 1 + 5 = 8\nTravel to station 0. Your tank = 8 - 2 + 1 = 7\nTravel to station 1. Your tank = 7 - 3 + 2 = 6\nTravel to station 2. Your tank = 6 - 4 + 3 = 5\nTravel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.\nTherefore, return 3 as the starting index.\n```\n\n### Example 2\n\n```bash\nInput: gas = [2,3,4], cost = [3,4,3]\nOutput: -1\nExplanation:\nYou can't start at station 0 or 1, as there is not enough gas to travel to the next station.\nLet's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 0. Your tank = 4 - 3 + 2 = 3\nTravel to station 1. Your tank = 3 - 3 + 3 = 3\nYou cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.\nTherefore, you can't travel around the circuit once no matter where you start.\n```\n\n### Constraints:\n\n- n == gas.length == cost.length\n- 1 <= n <= 10^5\n- 0 <= gas[i], cost[i] <= 10^4","basename":"gas-station"},"generate-div-tags":{"title":"Generate Div Tags","tags":["hard","algoexpert"],"preview":"# Generate Div Tags\n\nWrite a function that takes in a positive integer numberOfTags and returns a list of all the valid strings that you can generate with that number of matched <div></div> tags.\n\nA string is valid and contains matched <div></div> tags if for every opening tag <div>, there is a closing tag </div> that comes after the opening tag and that isn't used as a closing tag for another opening tag. Each output string should contain exactly numberOfTags opening tags and numberOfTags closing tags.\n\nFor example, given numberOfTags = 2, the valid strings to return would be: [\"<div></div><div></div>\",\n```\n\"<div><div></div></div>\"].\n```\n\nNote that the output strings don't need to be in any particular order.\n\n## Sample Input\n\n```\nnumberOfTags = 3\n```\n\n## Sample Output\n\n```\n[\n    \"<div><div><div></div></div></div>\",\n    \"<div><div></div><div></div></div>\",\n    \"<div><div></div></div><div></div>\",\n    \"<div></div><div><div></div></div>\",\n    \"<div></div><div></div><div></div>\",\n] \n// The strings could be ordered differently.\n```\n\n### Hints\n\nHint 1\n> The brute-force approach to solve this problem is to generate every single possible string that contains numberOfTags tags and to then check all of those strings to see if they're valid. Can you think of a better way to do this?\n\nHint 2\n> To solve this problem optimally, you'll have to incrementally build valid strings by adding <div> and </div> tags to already valid partial strings. While doing this, you can avoid creating strings that will never lead to a valid final string by following two rules:\n>  - If a string has fewer opening tags than numberOfTags, it's valid to add an opening tag to the end of it.\n>  - If a string has fewer closing tags than opening tags, it's valid to add a closing tag to the end of it.\n\nHint 3\n> Using the rules defined in Hint #2, write a recursive algorithm that generates all possible valid strings. You'll need to keep track of how many opening and closing tags each partial string has available (at each recursive call), and you'll simply follow the rules outlined in Hint #2. Once a string has no more opening and closing tags available, you can add it to your final list of strings. Your first call to the function will start with an empty string as the partial string and with numberOfTags as the number of opening and closing tags available. For example, after you add an opening tag to a partial string, you'll recursively call the function like this: recursiveFunction(partialStringWithExtraOpeningTag, openingTags - 1,\nclosingTags)\n\n```\nOptimal Space & Time Complexity\nO((2n)!/((n!((n + 1)!)))) time | O((2n)!/((n!((n + 1)!)))) space - where n is the input number\n```\n\n![solution](time.png)","basename":"generate-div-tags"},"generate-parenthesis":{"title":"Generate Parentheses","description":"Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.","tags":["neetcode","medium","stack","backtracking"],"link":"https://leetcode.com/problems/generate-parentheses/","preview":"### Description\n\nGiven n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\n\n### Example 1\n\n```bash\nInput: n = 3\nOutput: [\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\n```\n\n### Example 2\n\n```bash\nInput: n = 1\nOutput: [\"()\"]\n```\n\n### Constraints:\n\n- 1 <= n <= 8","basename":"generate-parenthesis"},"graph-valid-tree":{"title":"Graph Valid Tree","description":"Return true if the edges of the given graph make up a valid tree, and false otherwise.","tags":["medium","graph","graph-theory"],"link":"https://leetcode.com/problems/graph-valid-tree/","images":[],"preview":"### Description\n\nYou have a graph of n nodes labeled from 0 to n - 1. You are given an integer n and a list of edges where edges[i] = [ai, bi] indicates that there is an undirected edge between nodes ai and bi in the graph.\n\nReturn true if the edges of the given graph make up a valid tree, and false otherwise.\n\n \n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2021/03/12/tree1-graph.jpg)\n\n```bash\nInput: n = 5, edges = [[0,1],[0,2],[0,3],[1,4]]\nOutput: true\n```\n\n### Example 2\n\n![](https://assets.leetcode.com/uploads/2021/03/12/tree2-graph.jpg)\n\n```bash\nInput: n = 5, edges = [[0,1],[1,2],[2,3],[1,3],[1,4]]\nOutput: false\n```\n\n### Constraints:\n\n- 1 <= n <= 2000\n- 0 <= edges.length <= 5000\n- edges[i].length == 2\n- 0 <= ai, bi < n\n- ai != bi\n- There are no self-loops or repeated edges.","basename":"graph-valid-tree"},"greedy-search":{"title":"Greedy Search","description":"AI Search Problem","tags":["medium","search","ai"],"preview":"### Description\n\nGreedy Search is a graph search algorithm that is often used in pathfinding and graph traversal, which is the process of visiting (checking and/or updating) each vertex in a graph.\n\nIt uses a priority queue to decide which node to take on next\n\n- The difference between Greedy Search and A* Search is that Greedy Search accounts only for the Heuristic function, while A* Search accounts for both the Heuristic function and the cost of the path.\n- The difference between Greedy Search and Greedy Search and Hill Climbing is that Hill Climbing grabs the next closes heuristically, while Greedy First grabs the considers all alternatives by putting them all into a priority queue.\n\n\n\n\n| Algorithm             | Comp. | Time    | Space   | Informed | Optimal |\n| --------------------- | ----- | ------- | ------- | -------- | ------- |\n| GreedyBestFirstSearch | No    | O(b^d)* | O(b^d)* | Yes      | No      |\n\n### Example 1\n\n\nGiven: \n\n```js\n\n        //   A____B____C\n        //   |\\   |   /\n        //   | \\  |  /\n        //   |  \\ | /\n        //   D___\\E\n        //   |\\  |\n        //   | \\ |\n        //   |__\\|\n        //   F    G\n\n        const A = new Node('A', 0, 2);\n        const B = new Node('B', 1, 2);\n        const C = new Node('C', 2, 2);\n        const D = new Node('D', 0, 1);\n        const E = new Node('E', 1, 1);\n        const G = new Node('G', 0, 0);\n        const F = new Node('F', 1, 0);\n\n        const graph = new Graph();\n        graph.addEdge(A, B);\n        graph.addEdge(A, D);\n        graph.addEdge(B, C);\n        graph.addEdge(B, E);\n        graph.addEdge(C, E);\n        graph.addEdge(D, G);\n        graph.addEdge(D, F);\n        graph.addEdge(D, E);\n        graph.addEdge(E, G);\n        graph.addEdge(G, G);\n\n        const nodes = { A, B, C, D, E, G, F };\n        return { graph: graph, nodes: nodes };\n```\n\nShould be able to find it it using depth First Search.\n\n\n```js\n{\n  path: [\n    Node { id: 'A', x: 0, y: 2 },\n    Node { id: 'D', x: 0, y: 1, heuristic: 1 },\n    Node { id: 'G', x: 0, y: 0, heuristic: 0 }\n  ],\n  cost: null,\n  count_searches: 3,\n  formatted_path: 'A -> D -> G',\n  exploration_path: [\n    Node { id: 'A', x: 0, y: 2 },\n    Node { id: 'D', x: 0, y: 1, heuristic: 1 },\n    Node { id: 'G', x: 0, y: 0, heuristic: 0 }\n  ],\n  queue_snapshot: [\n    [ { id: 'A', priority: 0 } ],\n    [ { id: 'D', priority: 1 }, { id: 'B', priority: 3 } ],\n    [\n      { id: 'G', priority: 0 },\n      { id: 'F', priority: 1 },\n      { id: 'E', priority: 2 },\n      { id: 'B', priority: 3 }\n    ]\n  ]\n}\n```\n\n\n### t_graph_1\n\n\n```js\n        A----B\n       |  \\ | \\\n       D   \\|  H\n       |  \\ | /|\n       |    C  |\n        \\    \\ G\n         \\    /\n          \\  /\n           E\n           |\n           F\n\n\nconst A = new Node('A', 0, 1);\nconst B = new Node('B', 2, 1);\nconst C = new Node('C', 2, -1);\nconst D = new Node('D', 0, 0);\nconst E = new Node('E', 1, -5);\nconst F = new Node('F', 1, -2);\nconst G = new Node('G', 3, -2);\nconst H = new Node('H', 3, 0);\n\nconst nodes = {A, B, C, D, E, F, G, H};\n\n\nconst graph = new Graph();\ngraph.addEdge(A, B);\ngraph.addEdge(A, D);\ngraph.addEdge(A, C);\ngraph.addEdge(B, C);\ngraph.addEdge(B, H);\ngraph.addEdge(C, H);\ngraph.addEdge(C, G);\ngraph.addEdge(C, D);\ngraph.addEdge(D, E);\ngraph.addEdge(D, G);\ngraph.addEdge(E, G);\ngraph.addEdge(E, F);\n\n```\n\nResults:\n\n```bash\nnodes {\n  A: Node { id: 'A', x: 0, y: 1 },\n  B: Node { id: 'B', x: 2, y: 1 },\n  C: Node { id: 'C', x: 2, y: -1 },\n  D: Node { id: 'D', x: 0, y: 0 },\n  E: Node { id: 'E', x: 1, y: -5 },\n  F: Node { id: 'F', x: 1, y: -2 },\n  G: Node { id: 'G', x: 3, y: -2 },\n  H: Node { id: 'H', x: 3, y: 0 }\n} start Node { id: 'A', x: 0, y: 1 } goal Node { id: 'F', x: 1, y: -2 }\n{\n  path: [\n    Node { id: 'A', x: 0, y: 1 },\n    Node { id: 'D', x: 0, y: 0, heuristic: 3 },\n    Node { id: 'E', x: 1, y: -5, heuristic: 3 },\n    Node { id: 'F', x: 1, y: -2, heuristic: 0 }\n  ],\n  cost: null,\n  count_searches: 6,\n  formatted_path: 'A -> D -> E -> F',\n  exploration_path: [\n    Node { id: 'A', x: 0, y: 1 },\n    Node { id: 'C', x: 2, y: -1, heuristic: 2 },\n    Node { id: 'G', x: 3, y: -2, heuristic: 2 },\n    Node { id: 'D', x: 0, y: 0, heuristic: 3 },\n    Node { id: 'E', x: 1, y: -5, heuristic: 3 },\n    Node { id: 'F', x: 1, y: -2, heuristic: 0 }\n  ],\n  queue_snapshot: [\n    [ { id: 'A', priority: 0 } ],\n    [\n      { id: 'C', priority: 2 },\n      { id: 'D', priority: 3 },\n      { id: 'B', priority: 4 }\n    ],\n    [\n      { id: 'G', priority: 2 },\n      { id: 'D', priority: 3 },\n      { id: 'B', priority: 4 },\n      { id: 'H', priority: 4 }\n    ],\n    [\n      { id: 'D', priority: 3 },\n      { id: 'B', priority: 4 },\n      { id: 'H', priority: 4 }\n    ],\n    [\n      { id: 'E', priority: 3 },\n      { id: 'B', priority: 4 },\n      { id: 'H', priority: 4 }\n    ],\n    [\n      { id: 'F', priority: 0 },\n      { id: 'B', priority: 4 },\n      { id: 'H', priority: 4 }\n    ]\n  ]\n\n  ```","basename":"greedy-search"},"h-index":{"title":"H-Index","description":"Given an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper, return compute the researcher's h-index.","tags":["mid","array","solved"],"link":"https://leetcode.com/problems/h-index/","preview":"### Description\n\nGiven an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper, return the researcher's h-index.\n\nAccording to the definition of h-index on Wikipedia: The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times.\n\n### Example 1\n\n```bash\nInput: citations = [3,0,6,1,5]\nOutput: 3\nExplanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively.\nSince the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3.\n```\n\n\n### Example 2\n\n```bash\nInput: citations = [1,3,1]\nOutput: 1\n```\n\n## Umpire\n\n### Understand\n\nSince we know that the smallest elemnt will have all the count of numbers largr than it counting as index counts. We know also that in reverse (larger -> smaller) sort the largest element will only have itself as count, if the count is larger equal than the value of that elment it would make it the h-index and all consecutive h-indexes would be smaller than it.\n\n![](./../../../img/2023-09-19-21-21-52.png)\n\nBy sorting them in reverse you can eventually go finding up the counts.\n\n### Implement\n\n<iframe src=\"\" width=\"100%\" height=\"600\" frameborder=\"0\" marginwidth=\"0\" marginheight=\"0\" allowfullscreen></iframe>\n\n<Tabs>\n<TabItem value=\"Javascript Naive\" label=\"JavaScript\">\n\n```js\n/**\n * @param {number[]} citations\n * @return {number}\n */\nvar hIndex = function(citations) {\n    \n    citations.sort((a, b) => b - a)\n    let i = 0\n    while (i<citations.length && i < citations[i] ){\n        i++;\n    }\n    return i;\n    \n};\n\n```\n\n</TabItem>\n<TabItem value=\"Javascript Optimized\" label=\"Javascript Optimized\">\n\n```js\n\n```\n\n</TabItem>\n<TabItem value=\"Python\" label=\"Java\">\n\n```java\n\n```\n\n</TabItem>\n</Tabs>\n\n### Review if your code is ok\n\n### Evaluate\n\n- [ ] Time Complexity\n- [ ] Space Complexity","basename":"h-index"},"hand-of-straights":{"title":"Hand of Straights","description":"Given an integer array hand where hand[i] is the value written on the ith card and an integer groupSize, return true if she can rearrange the cards, or false otherwise.","tags":["medium","greedy","neetcode"],"preview":"### Description\n\nAlice has some number of cards and she wants to rearrange the cards into groups so that each group is of size `groupSize`, and consists of `groupSize` consecutive cards.\n\nGiven an integer array `hand` where `hand[i]` is the value written on the ith card and an integer `groupSize`, return `true` if she can rearrange the cards, or `false` otherwise.\n\n### Example 1\n\n```bash\nInput: hand = [1,2,3,6,2,3,4,7,8], groupSize = 3\nOutput: true\nExplanation: Alice's hand can be rearranged as [1,2,3],[2,3,4],[6,7,8]\n```\n\n### Example 2\n\n```bash\nInput: hand = [1,2,3,4,5], groupSize = 4\nOutput: false\nExplanation: Alice's hand can not be rearranged into groups of 4.\n```\n\n### Constraints:\n\n- 1 <= hand.length <= 104\n- 0 <= hand[i] <= 109\n- 1 <= groupSize <= hand.length","basename":"hand-of-straights"},"handshakes-that-dont-cross":{"title":"Handshakes That Don't Cross","description":"Return the number of ways these handshakes could occur such that none of the handshakes cross.","tags":["hard","dp","general-1d"],"link":"https://leetcode.com/problems/handshakes-that-dont-cross/","images":[],"preview":"### Description\n\nYou are given an even number of people numPeople that stand around a circle and each person shakes hands with someone else so that there are numPeople / 2 handshakes total.\n\nReturn the number of ways these handshakes could occur such that none of the handshakes cross.\n\nSince the answer could be very large, return it modulo `10^9 + 7`.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2019/07/11/5125_example_2.png)\n\n```bash\nInput: numPeople = 4\nOutput: 2\nExplanation: There are two ways to do it, the first way is [(1,2),(3,4)] and the second one is [(2,3),(4,1)].\n```\n\n### Example 2\n\n![](https://assets.leetcode.com/uploads/2019/07/11/5125_example_3.png)\n\n```bash\nInput: numPeople = 6\nOutput: 5\n```\n\n### Constraints:\n\n- 2 <= numPeople <= 1000\n- numPeople is even.","basename":"handshakes-that-dont-cross"},"happy-number":{"title":"Happy Number","description":"Write an algorithm to determine if a number n is happy.","tags":["easy","happy-number"],"link":"https://leetcode.com/problems/happy-number/","images":[],"preview":"### Description\n\nWrite an algorithm to determine if a number `n` is happy.\n\nA **happy number** is a number defined by the following process:\n\n- Starting with any positive integer, replace the number by the sum of the squares of its digits.\n- Repeat the process until the number equals 1 (where it will stay), or it **loops endlessly in a cycle** which does not include 1.\n- Those numbers for which this process **ends in 1** are happy.\n\nReturn `true` if `n` is a happy number, and `false` if not.\n\n### Example 1\n\n```bash\nInput: n = 19\nOutput: true\nExplanation:\n12 + 92 = 82\n82 + 22 = 68\n62 + 82 = 100\n12 + 02 + 02 = 1\n```\n\n### Example 2\n\n```bash\nInput: n = 2\nOutput: false\n```\n\n### Constraints:\n\n- 1 <= n <= 2^31 - 1","basename":"happy-number"},"hello-world":{"title":"Hello World","description":"A simple hello world example","tags":["neetcode","sample","easy"],"hints":["1","2","3","https://wngnelson.com/assets/img_src/oct/images/4804295.jpg"],"preview":"This is  a simple hello world example.\n\n```bash\n$ dsa run hello-world.js\n```","basename":"hello-world"},"hill-climbing-search":{"title":"Hill Climbing Search","description":"AI Search Problem","tags":["medium","search","ai"],"preview":"### Description\n\nHill climbing is a simple optimization algorithm used in Artificial Intelligence (AI) to find the best possible solution for a given problem. It belongs to the family of local search algorithms and is often used in optimization problems where the goal is to find the best solution from a set of possible solutions.\n\nIn Hill Climbing, the algorithm starts with an initial solution and then iteratively makes small changes to it in order to improve the solution. These changes are based on a heuristic function that evaluates the quality of the solution. The algorithm continues to make these small changes until it reaches a local maximum, meaning that no further improvement can be made with the current set of moves.\n\nHill Climbing can be useful in a variety of optimization problems, such as scheduling, route planning, and resource allocation. However, it has some limitations, such as the tendency to get stuck in local maxima and the lack of diversity in the search space. Therefore, it is often combined with other optimization techniques, such as genetic algorithms or simulated annealing, to overcome these limitations and improve the search results.\n\n\n### Example 1\n\n\nGiven: \n\n\n```js\n\n        //   A____B____C\n        //   |   |   /\n        //   |   |  /\n        //   |   | /\n        //   D___E\n        //   |\\  |\n        //   | \\ |\n        //   |__\\|\n        //   F    G\n\n        const A = new Node('A', 0, 2);\n        const B = new Node('B', 1, 2);\n        const C = new Node('C', 2, 2);\n        const D = new Node('D', 0, 1);\n        const E = new Node('E', 1, 1);\n        const G = new Node('G', 0, 0);\n        const F = new Node('F', 1, 0);\n\n        const graph = new Graph();\n        graph.addEdge(A, B);\n        graph.addEdge(A, D);\n        graph.addEdge(B, C);\n        graph.addEdge(B, E);\n        graph.addEdge(C, E);\n        graph.addEdge(D, G);\n        graph.addEdge(D, F);\n        graph.addEdge(D, E);\n        graph.addEdge(D,  G);\n        graph.addEdge(E, G);\n        graph.addEdge(G, G);\n\n        const nodes = { A, B, C, D, E, G, F };\n        return { graph: graph, nodes: nodes };\n```\n\nShould be able to find it it using depth First Search.\n\nTraversal:\n\n```js\n______________________________________________\nResults from create_graph_5, Hill Climbing Search\nneighbors [\n  { id: 'B', x: 1, y: 2, heuristic: 3 },\n  { id: 'D', x: 0, y: 1, heuristic: 1 }\n]\nbestNext selected:  Node { id: 'D', x: 0, y: 1 }\nneighbors [\n  { id: 'G', x: 0, y: 0, heuristic: 0 },\n  { id: 'F', x: 1, y: 0, heuristic: 1 },\n  { id: 'E', x: 1, y: 1, heuristic: 2 },\n  { id: 'G', x: 0, y: 0, heuristic: 0 }\n]\nbestNext selected:  Node { id: 'G', x: 0, y: 0 }\n{\n  path: [\n    Node { id: 'A', x: 0, y: 2 },\n    Node { id: 'D', x: 0, y: 1 },\n    Node { id: 'G', x: 0, y: 0 }\n  ],\n  cost: 3,\n  count_searches: 2,\n  formatted_path: 'A -> D -> G',\n  exploration_path: [ Node { id: 'A', x: 0, y: 2 }, Node { id: 'D', x: 0, y: 1 } ]\n}\n```\n\n### create_long_ass_graph\n\nHere it should get stuck, given a a local minima (despite following the right heurisitcs)\n\n\nHill climbing algorithm is a local search algorithm that can get stuck in a local maximum if the search space has many peaks and valleys, or if the heuristic function is not well-designed. When hill climbing gets stuck in a local maximum, it cannot find a better solution without backtracking to a previous state and exploring a different path.\n\nTherefore, backtracking is a technique commonly used to escape from local maxima in hill climbing. When the algorithm reaches a local maximum, it backtracks to a previous state and explores a different path. This process continues until the algorithm finds the global maximum or reaches a predefined stopping criterion.\n\nHowever, not all variants of hill climbing use backtracking. Some variants, such as Simulated Annealing and Tabu Search, use randomization or diversification to escape from local maxima. These variants may not backtrack but instead explore the search space in a more stochastic manner to avoid getting stuck in local maxima.\n\n```js\n\n______________________________________________\n\nResults from create_long_ass_graph, Hill Climbing Search\n\nneighbors [\n  { id: 'B', x: 1, y: -1, 'heuristic (distance)': 14 },\n  { id: 'C', x: 1, y: 1, 'heuristic (distance)': 16 }\n]\nbestNext selected:  Node { id: 'B', x: 1, y: -1 }\nneighbors [\n  { id: 'D', x: 2, y: -2, 'heuristic (distance)': 12 },\n  { id: 'E', x: 2, y: 0, 'heuristic (distance)': 14 }\n]\nbestNext selected:  Node { id: 'D', x: 2, y: -2 }\nneighbors [\n  { id: 'H', x: 3, y: -1, 'heuristic (distance)': 12 },\n  { id: 'I', x: 3, y: 1, 'heuristic (distance)': 14 }\n]\nbestNext selected:  Node { id: 'H', x: 3, y: -1 }\nneighbors [\n  { id: 'P', x: 5, y: -5, 'heuristic (distance)': 6 },\n  { id: 'Q', x: 5, y: -3, 'heuristic (distance)': 8 }\n]\nbestNext selected:  Node { id: 'P', x: 5, y: -5 }\nneighbors [\n  { id: 'AF', x: 7, y: -1, 'heuristic (distance)': 8 },\n  { id: 'AG', x: 7, y: 1, 'heuristic (distance)': 10 }\n]\nbestNext selected:  Node { id: 'AF', x: 7, y: -1 }\nError: The algorithm got stuck and could not find a solution.\n```\n\n> Note how the Hill Climbing Search gets stuck at the local Minimum, and does not backtrack to find the global minimum.\n\n\n\n### t_graph_1\n\n\n```js\n        A----B\n       |  \\ | \\\n       D   \\|  H\n       |  \\ | /|\n       |    C  |\n        \\    \\ G\n         \\    /\n          \\  /\n           E\n           |\n           F\n\n\nconst A = new Node('A', 0, 1);\nconst B = new Node('B', 2, 1);\nconst C = new Node('C', 2, -1);\nconst D = new Node('D', 0, 0);\nconst E = new Node('E', 1, -5);\nconst F = new Node('F', 1, -6);\nconst G = new Node('G', 3, -2);\nconst H = new Node('H', 3, 0);\n\nconst nodes = {A, B, C, D, E, F, G, H};\n\n\nconst graph = new Graph();\ngraph.addEdge(A, B);\ngraph.addEdge(A, D);\ngraph.addEdge(A, C);\ngraph.addEdge(B, C);\ngraph.addEdge(B, H);\ngraph.addEdge(C, H);\ngraph.addEdge(C, G);\ngraph.addEdge(C, D);\ngraph.addEdge(D, E);\ngraph.addEdge(D, G);\ngraph.addEdge(E, G);\ngraph.addEdge(E, F);\n\n```\n\n\nExpected to fail, as the algorithm should get stuck with the local maximum at node C. (Throw an error)\n\n```js\nneighbors [\n  { id: 'B', x: 2, y: 1, 'heuristic (distance)': 8 },\n  { id: 'D', x: 0, y: 0, 'heuristic (distance)': 7 },\n  { id: 'C', x: 2, y: -1, 'heuristic (distance)': 6 }\n]\nbestNext selected:  Node { id: 'C', x: 2, y: -1 }\nneighbors [\n  { id: 'A', x: 0, y: 1, 'heuristic (distance)': 8 },\n  { id: 'B', x: 2, y: 1, 'heuristic (distance)': 8 },\n  { id: 'H', x: 3, y: 0, 'heuristic (distance)': 8 },\n  { id: 'G', x: 3, y: -2, 'heuristic (distance)': 6 },\n  { id: 'D', x: 0, y: 0, 'heuristic (distance)': 7 }\n]\nbestNext selected:  Node { id: 'G', x: 3, y: -2 }\nneighbors [\n  { id: 'C', x: 2, y: -1, 'heuristic (distance)': 6 },\n  { id: 'D', x: 0, y: 0, 'heuristic (distance)': 7 },\n  { id: 'E', x: 1, y: -5, 'heuristic (distance)': 1 }\n]\nbestNext selected:  Node { id: 'E', x: 1, y: -5 }\nneighbors [\n  { id: 'D', x: 0, y: 0, 'heuristic (distance)': 7 },\n  { id: 'G', x: 3, y: -2, 'heuristic (distance)': 6 },\n  { id: 'F', x: 1, y: -6, 'heuristic (distance)': 0 }\n]\nbestNext selected:  Node { id: 'F', x: 1, y: -6 }\n______________________________________________\nResults from t_graph_1, Hill Climbing Search\n{\n  path: [\n    Node { id: 'A', x: 0, y: 1 },\n    Node { id: 'C', x: 2, y: -1 },\n    Node { id: 'G', x: 3, y: -2 },\n    Node { id: 'E', x: 1, y: -5 },\n    Node { id: 'F', x: 1, y: -6 }\n  ],\n  cost: 5,\n  count_searches: 4,\n  formatted_path: 'A -> C -> G -> E -> F',\n  exploration_path: [\n    Node { id: 'A', x: 0, y: 1 },\n    Node { id: 'C', x: 2, y: -1 },\n    Node { id: 'G', x: 3, y: -2 },\n    Node { id: 'E', x: 1, y: -5 }\n  ]\n}\n t_graph_1 Hill Climbing Search: 4\n```","basename":"hill-climbing-search"},"house-robber-ii":{"title":"House Robber II","description":"Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.","tags":["medium","dp","neetcode"],"link":"https://leetcode.com/problems/house-robber-ii/","images":[],"preview":"### Description\n\nYou are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are **arranged in a circle**. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\n\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight **without alerting the police**.\n\n \n\n### Example 1\n\n```bash\nInput: nums = [2,3,2]\nOutput: 3\nExplanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.\n```\n\n### Example 2\n\n```bash\nInput: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n```\n\n### Example 3\n\n```bash\nInput: nums = [1,2,3]\nOutput: 3\n```\n\n### Constraints:\n\n- 1 <= nums.length <= 100\n- 0 <= nums[i] <= 1000","basename":"house-robber-ii"},"house-robber-iii":{"title":"House Robber III","description":"The thief has found himself a new place for his thievery again. There is only one entrance to this area, called root.","tags":[],"link":"https://leetcode.com/problems/house-robber-iii","images":[],"preview":"### Description\n\nThe thief has found himself a new place for his thievery again. There is only one entrance to this area, called root.\n\nBesides the root, each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place form a binary tree. It will automatically contact the police if two directly-linked houses were broken into on the same night.\n\nGiven the root of the binary tree, return the maximum amount of money the thief can rob without alerting the police.\n\n### Example 1\n\n```bash\nInput: root = [3,2,3,null,3,null,1]\nOutput: 7\nExplanation: Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.\n```\n\n![](https://assets.leetcode.com/uploads/2021/03/10/rob1-tree.jpg)\n\n### Example 2\n\n![](https://assets.leetcode.com/uploads/2021/03/10/rob2-tree.jpg)\n\n```bash\nInput: root = [3,4,5,1,3,null,1]\nOutput: 9\nExplanation: Maximum amount of money the thief can rob = 4 + 5 = 9.\n```\n\n### Constraints:\n\n- The number of nodes in the tree is in the range [1, 104].\n- 0 <= Node.val <= 104","basename":"house-robber-iii"},"house-robber":{"title":"House Robber","description":"Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.","tags":["medium","dp","neetcode"],"link":"https://leetcode.com/problems/house-robber/","images":[],"hints":["https://wngnelson.com/assets/img_src/dsa/house-robber.gif"],"preview":"### Description\n\nYou are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\n\nGiven an integer array `nums` representing the amount of money of each house, return the maximum amount of money you can rob tonight **without alerting the police**.\n\n### Example 1\n\n```bash\nInput: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n```\n\n### Example 2\n\n```bash\nInput: nums = [2,7,9,3,1]\nOutput: 12\nExplanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\n```\n\n### Constraints:\n\n-     1 <= nums.length <= 100\n-     0 <= nums[i] <= 400","basename":"house-robber"},"implement-trie-prefix-tree":{"title":"Trie","description":"A trie (pronounced as \"try\") or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.","tags":["neetcode","medium","trie"],"link":"https://leetcode.com/problems/implement-trie-prefix-tree/","images":[],"preview":"### Description\n\nA trie (pronounced as \"try\") or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.\n\nImplement the Trie class:\n\n- Trie() Initializes the trie object.\n- void insert(String word) Inserts the string word into the trie.\n- boolean search(String word) Returns true if the string word is in the trie (i.e., was inserted before), and false otherwise.\n- boolean startsWith(String prefix) Returns true if there is a previously nserted string word that has the prefix prefix, and false otherwise.\n\n### Example 1\n\n```bash\nInput\n[\"Trie\", \"insert\", \"search\", \"search\", \"startsWith\", \"insert\", \"search\"]\n[[], [\"apple\"], [\"apple\"], [\"app\"], [\"app\"], [\"app\"], [\"app\"]]\nOutput\n[null, null, true, false, true, null, true]\n\nExplanation\nTrie trie = new Trie();\ntrie.insert(\"apple\");\ntrie.search(\"apple\");   // return True\ntrie.search(\"app\");     // return False\ntrie.startsWith(\"app\"); // return True\ntrie.insert(\"app\");\ntrie.search(\"app\");     // return True\n```\n\n### Constraints:\n\n- 1 <= word.length, prefix.length <= 2000 \n- word and prefix consist only of lowercase English letters. \n- At most 3 * 104 calls in total will be made to insert, search, and startsWith.","basename":"implement-trie-prefix-tree"},"index":{"preview":"const { getFilesInDirectory, getDirAbsoluteUri } = require('../functions');\nconst md2json = require('markdown-to-json');\nconst fs = require('fs');\n\nconst DEBUG = false;\nconst PROMPT_FILE = 'prompt.json';\n\nconst options = {\n    minify: false,\n    width: DEBUG ? 0 : 9000000,\n    outfile: null,\n};\n\n\n/**\n * Creates a compiled json file from all the markdown files in the prompt directory\n */\nconst createCompiledJson = () => {\n    let parsed_prompt_dict = {};\n\n    getFilesInDirectory('./prompt/')\n        .then((files) => {\n            const absolutePathForFiles = files.map((file) => {\n                return getDirAbsoluteUri(file, './prompt/');\n            });\n            if (DEBUG) console.log(\"absolutePathForFiles: \", absolutePathForFiles);\n            const promptsData = md2json.parse(absolutePathForFiles, options);\n            if (DEBUG) console.log(promptsData);\n            parsed_prompt_dict = JSON.parse(promptsData);\n            // Object.values(parsed_prompt_dict).map((prompt) => {\n\n            //     prompt.preview\n            // });\n            // console.log(\"promptsData: \", parsed_prompt_dict);\n\n\n\n            // Save as a json\n            const json = JSON.stringify(parsed_prompt_dict);\n            const prompt_file_path = getDirAbsoluteUri(PROMPT_FILE, './prompt/');\n            fs.writeFile(prompt_file_path, json, (err) => {\n                if (err) throw err;\n                // console.log('The file has been saved!');\n            });\n        })\n        .catch((error) => {\n            console.error(error);\n        });\n};\n\n\nconst getLatestModified = async () => {\n    const files = await getFilesInDirectory('./prompt/');\n    let latestModified = null;\n    let latestFile = null;\n\n    const absolutePathForFiles = files.map((file) => {\n        return getDirAbsoluteUri(file, './prompt/');\n    });\n    for (const file of absolutePathForFiles) {\n        const stats = await fs.promises.stat(file);\n        if (!latestModified || stats.mtime > latestModified) {\n            latestModified = stats.mtime;\n            latestFile = file;\n        }\n    }\n\n    return latestFile;\n};\n\n/**\n * Checks if prompt.json exists, if not, creates it, then returns the parsed json\n * @param {String} prompt_slug - The slug of the prompt to return, if empty, returns all prompts\n * @returns {Object} parsed_prompt_dict\n */\nconst getPromptDict = async (prompt_slug = \"\") => {\n    // check if prompt.json exists\n    const prompt_file_path = getDirAbsoluteUri(PROMPT_FILE, './prompt/');\n    if (!fs.existsSync(prompt_file_path)) {\n        createCompiledJson();\n    }\n\n    // If exists, check if it's the latest modified file, if not, update the prompt.json\n    const latestModified = await getLatestModified();\n\n    let parsed_prompt_dict;\n    if (latestModified !== prompt_file_path) {\n        console.log(\"latestModified: \", latestModified);\n        createCompiledJson();\n    }\n    try {\n        parsed_prompt_dict = require(prompt_file_path);\n    }\n    catch (e) {\n        // Delete the prompt.json file and try again\n        fs.unlinkSync(prompt_file_path);\n        // If it fails this time exit and print\n        try{\n            parsed_prompt_dict = require(prompt_file_path);\n        \n        }\n        catch (e) {\n            console.error(\"Error: \", e);\n            process.exit(1);\n        }\n    }\n\n\n    if (prompt_slug === \"\") {\n        return parsed_prompt_dict;\n    }\n    return parsed_prompt_dict[prompt_slug];\n};\n\n\n\n\n(async () => {\n    const sample = await getPromptDict();\n    if (DEBUG) console.log(\"sample: \", sample);\n}\n)();\n\nmodule.exports = { getPromptDict, createCompiledJson };\n\n\n// const parsed_prompt_dict = require(PROMPT_FILE);\n// module.exports = parsed_prompt_dict;","basename":"index"},"insert-delete-getrandom-o1":{"title":"Insert Delete GetRandom O(1)","description":"Should support insert, remove and getRandom in O(1) time average.","tags":["mid","array"],"link":"https://leetcode.com/problems/insert-delete-getrandom-o1/","images":[],"preview":"### Description\n\nmplement the RandomizedSet class:\n\nRandomizedSet() Initializes the RandomizedSet object.\nbool insert(int val) Inserts an item val into the set if not present. Returns true if the item was not present, false otherwise.\nbool remove(int val) Removes an item val from the set if present. Returns true if the item was present, false otherwise.\nint getRandom() Returns a random element from the current set of elements (it's guaranteed that at least one element exists when this method is called). Each element must have the same probability of being returned.\nYou must implement the functions of the class such that each function works in average O(1) time complexity.\n\n \n\n### Example 1\n\n```bash\nInput\n[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"]\n[[], [1], [2], [2], [], [1], [2], []]\nOutput\n[null, true, false, true, 2, true, false, 2]\n\nExplanation\nRandomizedSet randomizedSet = new RandomizedSet();\nrandomizedSet.insert(1); // Inserts 1 to the set. Returns true as 1 was inserted successfully.\nrandomizedSet.remove(2); // Returns false as 2 does not exist in the set.\nrandomizedSet.insert(2); // Inserts 2 to the set, returns true. Set now contains [1,2].\nrandomizedSet.getRandom(); // getRandom() should return either 1 or 2 randomly.\nrandomizedSet.remove(1); // Removes 1 from the set, returns true. Set now contains [2].\nrandomizedSet.insert(2); // 2 was already in the set, so return false.\nrandomizedSet.getRandom(); // Since 2 is the only number in the set, getRandom() will always return 2.\n```\n\n### Constraints:\n\n- -231 <= val <= 231 - 1\n-  At most 2 * 105 calls will be made to insert, remove, and getRandom.\n-  There will be at least one element in the data structure when getRandom is called.","basename":"insert-delete-getrandom-o1"},"insert-interval":{"title":"Insert Interval","description":"Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).","tags":["neetcode","medium","intervals"],"link":"https://leetcode.com/problems/insert-interval/","images":[],"preview":"### Description\n\nYou are given an array of non-overlapping `intervals` intervals where `intervals[i]` =` [starti, endi]` represent the start and the end of the `ith` interval and intervals is sorted in ascending order by starti. You are also given an interval `newInterval = [start, end]` that represents the start and end of another interval.\n\nInsert `newInterval` into `intervals` such that `intervals` is still sorted in ascending order by `starti` and `intervals` still does not have any overlapping intervals (merge overlapping intervals if necessary).\n\nReturn intervals after the insertion.\n\n### Example 1\n\n```bash\nInput: intervals = [[1,3],[6,9]], newInterval = [2,5]\nOutput: [[1,5],[6,9]]\n```\n\n### Example 2\n\n```bash\nInput: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\nOutput: [[1,2],[3,10],[12,16]]\nExplanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].\n\n```\n\n### Constraints:\n\n- 0 <= intervals.length <= 104     \n- intervals[i].length == 2     \n- 0 <= starti <= endi <= 105     \n- intervals is sorted by starti in ascending order.     \n- newInterval.length == 2     \n- 0 <= start <= end <= 105","basename":"insert-interval"},"integer-to-roman":{"title":"Integer to Roman","description":"Given an integer, convert it to a roman numeral.","tags":["array","mid"],"link":"https://leetcode.com/problems/integer-to-roman/","images":[],"preview":"### Description\n\nRoman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n\n\n```bash\nSymbol       Value\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\n```\n\nFor example, 2 is written as II in Roman numeral, just two one's added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\n\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n\nI can be placed before V (5) and X (10) to make 4 and 9. \nX can be placed before L (50) and C (100) to make 40 and 90. \nC can be placed before D (500) and M (1000) to make 400 and 900.\nGiven an integer, convert it to a roman numeral.\n\n### Example 1\n\n```bash\nInput: num = 3\nOutput: \"III\"\nExplanation: 3 is represented as 3 ones.\n```\n\n### Example 2\n\n```bash\nInput: num = 58\nOutput: \"LVIII\"\nExplanation: L = 50, V = 5, III = 3.\n```\n\n### Example 3\n\n```bash\nInput: num = 1994\nOutput: \"MCMXCIV\"\nExplanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n```\n\n### Constraints:\n\n- 1 <= num <= 3999","basename":"integer-to-roman"},"interweaving-strings":{"title":"Interweaving Strings","tags":["hard","algoexpert"],"preview":"# Interweaving Strings\n\nWrite a function that takes in three strings and returns a boolean representing whether the third string can be formed by interweaving the first two strings.\n\nTo interweave strings means to merge them by alternating their letters without any specific pattern. For instance, the strings \"abc\" and \"123\" can be interwoven as \"a1b2c3\", as \"abc123\", and as \"ab1c23\" (this list is nonexhaustive).\n\nLetters within a string must maintain their relative ordering in the interwoven string.\n\n## Sample Input\n\n```\none = \"algoexpert\"\ntwo = \"your-dream-job\"\nthree = \"your-algodream-expertjob\"\n```\n\n## Sample Output\n\n```\ntrue\n```\n\n### Hints\n\nHint 1\n> Try traversing the three strings with three different pointers to solve this problem.\n\nHint 2\n> Declare three variables (i, j, and k, for instance) pointing to indices in the three strings, respectively, and starting at 0. At any given combination of indices, if neither the character at i in the first string nor the character at j in the second string is equal to the character at k in the third string, then the first two strings can't interweave to form the third one (at least not in whatever way led to the values of i, j, and k in question).\n\nHint 3\n> If at any given combination of the indices i, j, and k mentioned in Hint #2, the character at i in the first string or the character at j in the second string is equal to the character at k in the third string, then you can potentially interweave the first two strings to get the third one. In such a case, try incrementing the two relevant indices (i and k or j and k) and repeating this process until you confirm whether or not the first two strings can be interwoven to form the third one. Try using recursion to implement this algorithm.\n\nHint 4\n> By following Hint #3, you'll perform, in some cases, many computations multiple times. How can you use caching to improve the time complexity of this algorithm?\n\n```\nOptimal Space & Time Complexity\nO(nm) time | O(nm) space - where n is the length of the first string and m is the length of the second string\n```\n\n![solution](answer.png)\n\n![solution](answer1.png)","basename":"interweaving-strings"},"invert-binary-tree":{"title":"Invert Binary Tree","description":"Given the `root` of a binary tree, invert the tree, and return its root.","tags":["neetcode","easy","binary-tree"],"link":"https://leetcode.com/problems/invert-binary-tree/","images":["https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg","https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg"],"preview":"### Description\n\nGiven the root of a binary tree, invert the tree, and return its root.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg)\n\n```bash\nInput: root = [4,2,7,1,3,6,9]\nOutput: [4,7,2,9,6,3,1]\n```\n\n### Example 2\n\n![](https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg)\n\n```bash\nInput: root = [2,1,3]\nOutput: [2,3,1]\n```\n\n### Example 3\n\n```bash\nInput: root = []\nOutput: []\n```\n\n### Constraints:\n\n- The number of nodes in the tree is in the range [0, 100]. \n- -100 <= Node.val <= 100","basename":"invert-binary-tree"},"ipo":{"title":"IPO","description":"Suppose LeetCode will start its IPO soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the IPO. Since it has limited resources, it can only finish at most k distinct projects before the IPO. Help LeetCode design the best way to maximize its total capital after finishing at most k distinct projects.","tags":["heap","hard"],"link":"https://leetcode.com/problems/ipo","images":[],"preview":"### Description\n\nSuppose LeetCode will start its IPO soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the IPO. Since it has limited resources, it can only finish at most k distinct projects before the IPO. Help LeetCode design the best way to maximize its total capital after finishing at most k distinct projects.\n\nYou are given n projects where the ith project has a pure profit profits[i] and a minimum capital of capital[i] is needed to start it.\n\nInitially, you have w capital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital.\n\nPick a list of at most k distinct projects from given projects to maximize your final capital, and return the final maximized capital.\n\nThe answer is guaranteed to fit in a 32-bit signed integer.\n\n \n\n### Example 1\n\n```bash\nInput: k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]\nOutput: 4\nExplanation: Since your initial capital is 0, you can only start the project indexed 0.\nAfter finishing it you will obtain profit 1 and your capital becomes 1.\nWith capital 1, you can either start the project indexed 1 or the project indexed 2.\nSince you can choose at most 2 projects, you need to finish the project indexed 2 to get the maximum capital.\nTherefore, output the final maximized capital, which is 0 + 1 + 3 = 4.\n```\n\n### Example 2\n\n```bash\nInput: k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]\nOutput: 6\n```\n\n### Constraints:\n\n- 1 <= k <= 105\n- 0 <= w <= 109\n- n == profits.length\n- n == capital.length\n- 1 <= n <= 105\n- 0 <= profits[i] <= 104\n- 0 <= capital[i] <= 109","basename":"ipo"},"is-graph-bipartite":{"title":"Is Graph Bipartite?","description":"A graph is bipartite if the nodes can be partitioned into two independent sets A and B such that every edge in the graph connects a node in set A and a node in set B.","tags":["medium","graph","graph-theory"],"link":"https://leetcode.com/problems/is-graph-bipartite/","images":["https://assets.leetcode.com/uploads/2020/10/21/bi2.jpg","https://assets.leetcode.com/uploads/2020/10/21/bi1.jpg"],"preview":"### Description\n\nThere is an undirected graph with n nodes, where each node is numbered between 0 and n - 1. You are given a 2D array graph, where graph[u] is an array of nodes that node u is adjacent to. More formally, for each v in graph[u], there is an undirected edge between node u and node v. The graph has the following properties:\n\n- There are no self-edges (graph[u] does not contain u).\n- There are no parallel edges (graph[u] does not contain duplicate values).\n- If v is in graph[u], then u is in graph[v] (the graph is undirected).\n\nThe graph may not be connected, meaning there may be two nodes u and v such that there is no path between them.\nA graph is bipartite if the nodes can be partitioned into two independent sets A and B such that every edge in the graph connects a node in set A and a node in set B.\n\nReturn true if and only if it is bipartite.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2020/10/21/bi2.jpg)\n\n```bash\nInput: graph = [[1,2,3],[0,2],[0,1,3],[0,2]]\nOutput: false\nExplanation: There is no way to partition the nodes into two independent sets such that every edge connects a node in one and a node in the other.\n```\n\n### Example 2\n\n![](https://assets.leetcode.com/uploads/2020/10/21/bi1.jpg)\n\n```bash\nInput: graph = [[1,3],[0,2],[1,3],[0,2]]\nOutput: true\nExplanation: We can partition the nodes into two sets: {0, 2} and {1, 3}.\n```\n\n### Constraints:\n\n- graph.length == n\n- 1 <= n <= 100\n- 0 <= graph[u].length < n\n- 0 <= graph[u][i] <= n - 1\n- graph[u] does not contain u.\n- All the values of graph[u] are unique.\n- If graph[u] contains v, then graph[v] contains u.","basename":"is-graph-bipartite"},"juice-bottling":{"title":"Juice Bottling","tags":["hard","algoexpert"],"preview":"","basename":"juice-bottling"},"jump-game-ii":{"title":"Jump Game II","description":"You are given a 0-indexed array of integers nums of length n. You are initially positioned at nums[0].","tags":["medium","dp","interval","neetcode"],"link":"https://leetcode.com/problems/jump-game-ii/","images":[],"preview":"### Description\n\nYou are given a **0-indexed** array of integers `nums` of length `n`. You are initially positioned at `nums[0]`.\n\nEach element `nums[i]` represents the maximum length of a forward jump from index `i`. In other words, if you are at `nums[i]`, you can jump to any `nums[i + j]` where:\n\n```js\n    0 <= j <= nums[i] and\n    i + j < n\n```\n\nReturn the minimum number of jumps to reach `nums[n - 1]`. The test cases are generated such that you can reach `nums[n - 1]`.\n\n### Example 1\n\n```bash\nInput: nums = [2,3,1,1,4]\nOutput: 2\nExplanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\n```\n\n### Example 2\n\n```bash\nInput: nums = [2,3,0,1,4]\nOutput: 2\n```\n\n### Constraints:\n\n- 1 <= nums.length <= 104\n- 0 <= nums[i] <= 1000\n- It's guaranteed that you can reach nums[n - 1].","basename":"jump-game-ii"},"jump-game-iii":{"title":"Jump Game III","description":"Given an array of non-negative integers arr, you are initially positioned at start index of the array. When you are at index i, you can jump to i + arr[i] or i - arr[i], check if you can reach any index with value 0.","tags":["medium","graph","dfs"],"link":"https://leetcode.com/problems/jump-game-iii/","images":[],"preview":"### Description\n\nGiven an array of non-negative integers arr, you are initially positioned at start index of the array. When you are at index i, you can jump to i + arr[i] or i - arr[i], check if you can reach any index with value 0.\n\nNotice that you can not jump outside of the array at any time.\n\n### Example 1\n\n```bash\nOutput: true\nExplanation: \nAll possible ways to reach at index 3 with value 0 are: \nindex 5 -> index 4 -> index 1 -> index 3 \nindex 5 -> index 6 -> index 4 -> index 1 -> index 3 \n```\n\n### Example 2\n\n```bash\nInput: arr = [4,2,3,0,3,1,2], start = 0\nOutput: true \nExplanation: \nOne possible way to reach at index 3 with value 0 is: \nindex 0 -> index 4 -> index 1 -> index 3\n```\n\n### Example 3\n\n```bash\nInput: arr = [3,0,2,1,2], start = 2\nOutput: false\nExplanation: There is no way to reach at index 1 with value 0.\n```\n\n\n### Constraints:\n\n- 1 <= arr.length <= 5 * 104\n- 0 <= arr[i] < arr.length\n- 0 <= start < arr.length","basename":"jump-game-iii"},"jump-game":{"title":"Jump Game","description":"You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position.","tags":["medium","dp","interval","neetcode"],"link":"https://leetcode.com/problems/jump-game/","preview":"### Description\n\nYou are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position.\n\nReturn true if you can reach the last index, or false otherwise.\n\n### Example 1\n\n```bash\nInput: nums = [2,3,1,1,4]\nOutput: true\nExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.\n```\n\n### Example 2\n\n```bash\nInput: nums = [3,2,1,0,4]\nOutput: false\nExplanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.\n```\n\n### Constraints:\n\n- 1 <= nums.length <= 104\n- 0 <= nums[i] <= 105","basename":"jump-game"},"k-closest":{"title":"k closest points to origin","description":"Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane and an integer k, return the k closest points to the origin (0, 0).","tags":["neetcode","medium","heap"],"link":"https://leetcode.com/problems/k-closest-points-to-origin/","images":["https://assets.leetcode.com/uploads/2021/03/03/closestplane1.jpg"],"preview":"### Description\n\nGiven an array of points where `points[i] = [xi, yi]` represents a point on the **X-Y** plane and an integer k, return the k closest points to the origin (0, 0).\n\nThe distance between two points on the X-Y plane is the Euclidean distance (i.e., (x1 - x2)2 + (y1 - y2)2).\n\nYou may return the answer in **any order**. The answer is **guaranteed** to be **unique** (except for the order that it is in).\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2021/03/03/closestplane1.jpg)\n\n```bash\nInput: points = [[1,3],[-2,2]], k = 1\nOutput: [[-2,2]]\nExplanation:\nThe distance between (1, 3) and the origin is sqrt(10).\nThe distance between (-2, 2) and the origin is sqrt(8).\nSince sqrt(8) < sqrt(10), (-2, 2) is closer to the origin.\nWe only want the closest k = 1 points from the origin, so the answer is just [[-2,2]].\n```\n\n### Example 2\n\n```bash\nInput: points = [[3,3],[5,-1],[-2,4]], k = 2\nOutput: [[3,3],[-2,4]]\nExplanation: The answer [[-2,4],[3,3]] would also be accepted.\n```\n\n### Constraints:\n\n- 1 <= k <= points.length <= 104\n- -104 < xi, yi < 104","basename":"k-closest"},"key-based-value-store":{"title":"Time Based Key-value Store","description":"Design a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the key's value at a certain timestamp.","tags":["neetcode","medium","binary-search"],"link":"https://leetcode.com/problems/time-based-key-value-store/","preview":"### Description\n\nDesign a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the key's value at a certain timestamp.\n\nImplement the TimeMap class:\n\n- `TimeMap()` Initializes the object of the data structure\n- `void set(String key, String value, int timestamp)` Stores the key `key` with the value `value` at the given time timestamp.\n- `String get(String key, int timestamp)` Returns a value such that set was called previously, with `timestamp_prev <= timestamp`. If there are multiple such values, it returns the value associated with the largest `timestamp_prev`. If there are no values, it returns `\"\"`.\n\n\n### Example 1\n\n```bash\nInput\n[\"TimeMap\", \"set\", \"get\", \"get\", \"set\", \"get\", \"get\"]\n[[], [\"foo\", \"bar\", 1], [\"foo\", 1], [\"foo\", 3], [\"foo\", \"bar2\", 4], [\"foo\", 4], [\"foo\", 5]]\nOutput\n[null, null, \"bar\", \"bar\", null, \"bar2\", \"bar2\"]\n\nExplanation\nTimeMap timeMap = new TimeMap();\ntimeMap.set(\"foo\", \"bar\", 1);  // store the key \"foo\" and value \"bar\" along with timestamp = 1.\ntimeMap.get(\"foo\", 1);         // return \"bar\"\ntimeMap.get(\"foo\", 3);         // return \"bar\", since there is no value corresponding to foo at timestamp 3 and timestamp 2, then the only value is at timestamp 1 is \"bar\".\ntimeMap.set(\"foo\", \"bar2\", 4); // store the key \"foo\" and value \"bar2\" along with timestamp = 4.\ntimeMap.get(\"foo\", 4);         // return \"bar2\"\ntimeMap.get(\"foo\", 5);         // return \"bar2\"\n```\n\n\n### Constraints:\n\n-      1 <= key.length, value.length <= 100     \n-      key and value consist of lowercase English letters and digits.     \n-      1 <= timestamp <= 107     \n-      All the timestamps timestamp of set are strictly increasing.     \n-      At most 2 * 105 calls will be made to set and get.","basename":"key-based-value-store"},"keys-and-rooms":{"title":"Keys and Rooms","description":"Given an array rooms where rooms[i] is the set of keys that you can obtain if you visited room i, return true if you can visit all the rooms, or false otherwise.","tags":["medium","graph","standard-traversal"],"link":"https://leetcode.com/problems/keys-and-rooms","images":[],"preview":"### Description\n\nThere are n rooms labeled from 0 to n - 1 and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.\n\nWhen you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\n\nGiven an array rooms where rooms[i] is the set of keys that you can obtain if you visited room i, return true if you can visit all the rooms, or false otherwise.\n\n### Example 1\n\n```bash\nInput: rooms = [[1],[2],[3],[]]\nOutput: true\nExplanation: \nWe visit room 0 and pick up key 1.\nWe then visit room 1 and pick up key 2.\nWe then visit room 2 and pick up key 3.\nWe then visit room 3.\nSince we were able to visit every room, we return true.\n```\n\n### Example 2\n\n```bash\nInput: rooms = [[1,3],[3,0,1],[2],[0]]\nOutput: false\nExplanation: We can not enter room number 2 since the only key that unlocks it is in that room.\n```\n\n### Constraints:\n\n- n == rooms.length\n- 2 <= n <= 1000\n- 0 <= rooms[i].length <= 1000\n- 1 <= sum(rooms[i].length) <= 3000\n- 0 <= rooms[i][j] < n\n- All the values of rooms[i] are unique.","basename":"keys-and-rooms"},"knapsack-problem":{"title":"Knackpack Problem","description":"You're given an array of arrays where each subarray holds two integer values and represents an item; the first integer is the item's value, and the second integer is the item's weight. You're also given an integer representing the maximum capacity of a knapsack that you have.","tags":["hard","algoexpert"],"preview":"### Description\n\n# Knapsack Problem\n\nYou're given an array of arrays where each subarray holds two integer values and represents an item; the first integer is the item's value, and the second integer is the item's weight. You're also given an integer representing the maximum capacity of a knapsack that you have.\n\nYour goal is to fit items in your knapsack without having the sum of their weights exceed the knapsack's capacity, all the while maximizing their combined value. Note that you only have one of each item at your disposal.\n\nWrite a function that returns the maximized combined value of the items that you should pick as well as an array of the indices of each item picked.\n\nIf there are multiple combinations of items that maximize the total value in the knapsack, your function can return any of them.\n\n## Sample Input\n\n```\nitems = [[1, 2], [4, 3], [5, 6], [6, 7]]\ncapacity = 10\n```\n\n## Sample Output\n\n```\n[10, [1, 3]] // items [4, 3] and [6, 7]\n```\n\n### Hints\n\n```\nHint 1\nTry building a two-dimensional array of the maximum values that knapsacks of all capacities between 0 and c inclusive could hold, given one, two, three, etc., items. Let columns represent capacities and rows represent items.\n```\n\n```\nHint 2\nBuild up the array mentioned in Hint #1 one row at a time. In other words, find the maximum values that knapsacks of all capacities between 0 and c can hold with only one item, then with two, etc., until you use all items. Find a formula that relates the maximum value at any given point to previous values.\n```\n\n```\nHint 3\nBacktrack your way through the two-dimensional array mentioned in Hint #1 to find which items are in your knapsack. Start at the final index in the array and check whether or not the value stored at that index is equal to the value located one row above. If it isn't, then the item represented by the current row is in the knapsack.\n```\n\n```\nOptimal Space & Time Complexity\nO(nc) time | O(nc) space - where n is the number of items and c is the capacity\n```","basename":"knapsack-problem"},"knight-probability-in-chessboard":{"title":"Knight Probability in Chessboard","description":"A chess knight has eight possible moves it can make, as illustrated below. Each move is two cells in a cardinal direction, then one cell in an orthogonal direction.","tags":["medium","grand-dp","probability"],"link":"https://leetcode.com/problems/knight-probability-in-chessboard/","images":[],"preview":"### Description\n\nOn an n x n chessboard, a knight starts at the cell (row, column) and attempts to make exactly k moves. The rows and columns are 0-indexed, so the top-left cell is (0, 0), and the bottom-right cell is (n - 1, n - 1).\n\nA chess knight has eight possible moves it can make, as illustrated below. Each move is two cells in a cardinal direction, then one cell in an orthogonal direction.\n\n\n![](https://assets.leetcode.com/uploads/2018/10/12/knight.png)\n\nEach time the knight is to move, it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there.\n\nThe knight continues moving until it has made exactly k moves or has moved off the chessboard.\n\nReturn the probability that the knight remains on the board after it has stopped moving.\n\n### Example 1\n\n```bash\nInput: n = 3, k = 2, row = 0, column = 0\nOutput: 0.06250\nExplanation: There are two moves (to (1,2), (2,1)) that will keep the knight on the board.\nFrom each of those positions, there are also two moves that will keep the knight on the board.\nThe total probability the knight stays on the board is 0.0625.\n```\n\n### Example 2\n\n```bash\nInput: n = 1, k = 0, row = 0, column = 0\nOutput: 1.00000\n```\n\n### Constraints:\n\n- 1 <= n <= 25\n- 0 <= k <= 100\n- 0 <= row, column <= n - 1","basename":"knight-probability-in-chessboard"},"koko-eating-bananas":{"title":"koko-eating-bananas","description":"Return the minimum integer k such that she can eat all the bananas within h hours.","tags":["neetcode","medium","binary-search"],"link":"https://leetcode.com/problems/koko-eating-bananas/","preview":"### Description\n\nKoko loves to eat bananas. There are `n` piles of bananas, the ith pile has `piles[i]` bananas. The guards have gone and will come back in `h` hours.\n\nKoko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.\n\nKoko likes to eat slowly but still wants to finish eating all the bananas before the guards return.\n\nReturn the minimum integer `k` such that she can eat all the bananas within `h` hours.\n\n### Example 1\n\n```bash\nInput: piles = [3,6,7,11], h = 8\nOutput: 4\n```\n\n### Example 2\n\n```bash\nInput: piles = [30,11,23,4,20], h = 5\nOutput: 30\n```\n\n### Example 3\n\n```bash\nInput: piles = [30,11,23,4,20], h = 6\nOutput: 23\n```\n\n### Constraints:\n\n-      1 <= piles.length <= 104     \n-      piles.length <= h <= 109     \n-      1 <= piles[i] <= 109","basename":"koko-eating-bananas"},"kruskals-algorithm":{"title":"kruskals-algorithm","tags":["hard","algoexpert"],"link":"https://leetcode.com/problems/min-cost-to-connect-all-points/solutions/1449213/kruskals-algorithm-for-minimum-cost-spanning-tree/","preview":"While the super-fast implementation of Kruskal's algorithm based on the Union-Find data structure (with union by rank and path compression) runs in time O(m logn), the implementation below runs in time O(n^2) since the bottleneck involves adding points to the priority queue.\n\n\n\n```java\nclass Solution {\n    public int minCostConnectPoints(int[][] points) {\n        if (points == null || points.length == 0) return 0;\n        \n        PriorityQueue<int[]> heap = new PriorityQueue<>((a,b) -> a[0] - b[0]);\n        for (int i = 0; i < points.length - 1; i++) {\n            for (int j = i+1; j < points.length; j++) {\n                heap.add(new int[]{distance(points, i, j), i, j});\n            }\n        }\n        int minCost = 0;\n        UnionFind uf = new UnionFind(points.length);\n        while(!heap.isEmpty()) {\n            int[] edge = heap.poll();\n            if (uf.union(edge[1], edge[2])) {\n                minCost += edge[0];\n            }\n        }\n        \n        return minCost;\n    }\n    \n    public int distance(int[][] points, int a, int b) {\n        return Math.abs(points[a][0] - points[b][0]) + Math.abs(points[a][1] - points[b][1]);\n    }\n}\n\nclass UnionFind {\n    int[] parent;\n    int[] rank;\n    public UnionFind(int n) {\n        this.rank = new int[n];\n        this.parent = new int[n];\n        \n        for (int i = 0; i < n; i++) parent[i] = i;\n    }\n    \n    public int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n    // return true if we do not get a cycle \n    public boolean union(int x, int y) {\n        int parentX = find(x);\n        int parentY = find(y);\n        if (parentX == parentY) return false;\n        if (rank[parentX] == rank[parentY]) {\n            parent[parentX] = parentY;\n            rank[parentY] += 1;\n        } else if (rank[parentX] < rank[parentY]) {\n            parent[parentX] = parentY;\n        } else {\n            parent[parentY] = parentX;\n        }\n        return true;\n    }\n}\n```","basename":"kruskals-algorithm"},"kth-largest-element-in-an-array":{"title":"kth largest elements in a stream","description":"Given an integer array nums and an integer k, return the kth largest element in the array.","tags":["neetcode","medium","heap"],"link":"https://leetcode.com/problems/kth-largest-element-in-an-array/","images":[],"preview":"### Description\n\nGiven an integer array nums and an integer `k`, return the `kth` largest element in the array.\n\nNote that it is the `kth` largest element in the sorted order, not the `kth` distinct element.\n\nYou must solve it in `O(n)` time complexity.\n\n### Example 1\n\n```bash\nInput: nums = [3,2,1,5,6,4], k = 2\nOutput: 5\n```\n\n### Example 2\n\n```bash\nInput: nums = [3,2,3,1,2,4,5,5,6], k = 4\nOutput: 4\n```\n\n### Constraints:\n\n- 1 <= k <= nums.length <= 10^5 \n- -10^4 <= nums[i] <= 10^4","basename":"kth-largest-element-in-an-array"},"kth-smallest-element-in-a-bst":{"title":"Kth Smallest Element in a BST","description":"Given the root of a binary search tree, and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree.","tags":["neetcode","medium","binary-tree"],"link":"https://leetcode.com/problems/kth-smallest-element-in-a-bst/","images":["https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg","https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg"],"hints":["https://wngnelson.com/assets/img_src/dsa/kthsmallest.gif"],"preview":"### Description\n\nGiven the `root` of a binary search tree, and an integer k, return the kth smallest value (**1-indexed**) of all the values of the nodes in the tree.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg)\n\n```bash\nInput: root = [3,1,4,null,2], k = 1\nOutput: 1\n```\n\n### Example 2\n\n![](https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg)\n\n```bash\nInput: root = [5,3,6,2,4,null,null,1], k = 3\nOutput: 3\n```\n\n### Constraints:\n\n- The number of nodes in the tree is n.\n- 1 <= k <= n <= 104\n- 0 <= Node.val <= 104","basename":"kth-smallest-element-in-a-bst"},"laptop-rentals":{"title":"Laptop Rentals","tags":["hard","algoexpert"],"preview":"# Laptop Rentals\n\nYou're given a list of time intervals during which students at a school need a laptop. These time intervals are represented by pairs of integers [start, end], where 0 <= start < end. However, start and end don't represent real times; therefore, they may be greater than 24.\n\nNo two students can use a laptop at the same time, but immediately after a student is done using a laptop, another student can use that same laptop. For example, if one student rents a laptop during the time interval [0, 2], another student can rent the same laptop during any time interval starting with 2.\n\nWrite a function that returns the minimum number of laptops that the school needs to rent such that all students will always have access to a laptop when they need one.\n\n## Sample Input\n\n```\ntimes =\n    [\n    [0, 2],\n    [1, 4],\n    [4, 6],\n    [0, 4],\n    [7, 8],\n    [9, 11],\n    [3, 10],\n]\n```\n\n## Sample Output\n\n```\n3\n```\n\n### Hints\n\nHint 1\n> There are many different ways to solve this problem, but only a few of them run in the optimal time. Can you come up with an algorithm that solves this problem in O(nlog(n)) time?\n\nHint 2\n> Suppose that you're given two time intervals: [s1, e1] and [s2, e2], where s1 < s2. If e1 <= s2, then the second time interval can use the same laptop as the first time interval.\n> One method to solve this problem with an optimal time complexity is to use a Min Heap. If you loop through time intervals that have been sorted by their start times and keep track of the smallest end time of time intervals for laptops that have already been rented out, you can determine how many laptops are required. Use the Min Heap to efficiency determine if any previous rental time intervals have ended as you loop through all the time intervals. If a rental time interval is done and another one starts after it, no extra laptop is required.\n\nHint 3\n> Another way to efficiently solve this problem is to realize that we don't need to know what start time corresponds with what end time. So long as we know all start times and all end times, we can determine the number of laptops required.\n\nHint 4\n> Start by creating two arraysone for start times and one for end timesand sort them both in ascending order. We can simply loop through the start times and end times at the same time and compare the current start time to the current end time. If the current start time is greater than the current end time, then that means a laptop that was previously used is no longer being used and can be given to the student renting a laptop at this starting time. Thus, we can increment both our start-time and end-time pointers and continue without needing an additional laptop. If the current start time is smaller than the current end time, then another rental has started before a previous rental has ended, and we thus require another laptop, so we increment the start pointer and a variable keeping track of the number of laptops required. See the Conceptual Overview section of this question's video explanation for a more in-depth explanation.\n\n```\nOptimal Space & Time Complexity\nO(nlog(n)) time | O(n) space - where n is the number of times\n```","basename":"laptop-rentals"},"largest-color-value-in-a-directed-graph":{"title":"Largest Color Value in a Directed Graph","description":"Return the largest color value of any valid path in the given graph, or -1 if the graph contains a cycle.","tags":["hard","graph","topological-sort"],"link":"https://leetcode.com/problems/largest-color-value-in-a-directed-graph","images":[],"preview":"### Description\n\nThere is a directed graph of n colored nodes and m edges. The nodes are numbered from 0 to n - 1.\n\nYou are given a string colors where colors[i] is a lowercase English letter representing the color of the ith node in this graph (0-indexed). You are also given a 2D array edges where edges[j] = [aj, bj] indicates that there is a directed edge from node aj to node bj.\n\nA valid path in the graph is a sequence of nodes x1 -> x2 -> x3 -> ... -> xk such that there is a directed edge from xi to xi+1 for every 1 <= i < k. The color value of the path is the number of nodes that are colored the most frequently occurring color along that path.\n\nReturn the largest color value of any valid path in the given graph, or -1 if the graph contains a cycle.\n\n\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2021/04/21/leet1.png)\n\n```bash\nInput: colors = \"abaca\", edges = [[0,1],[0,2],[2,3],[3,4]]\nOutput: 3\nExplanation: The path 0 -> 2 -> 3 -> 4 contains 3 nodes that are colored \"a\" (red in the above image).\n```\n\n### Example 2\n\n![](https://assets.leetcode.com/uploads/2021/04/21/leet2.png)\n\n```bash\nInput: colors = \"a\", edges = [[0,0]]\nOutput: -1\nExplanation: There is a cycle from 0 to 0.\n```\n\n### Constraints:\n\n- n == colors.length\n- m == edges.length\n- 1 <= n <= 105\n- 0 <= m <= 105\n- colors consists of lowercase English letters.\n- 0 <= aj, bj < n","basename":"largest-color-value-in-a-directed-graph"},"largest-rectangle-area":{"title":"Largest Rectangle in Histogram","description":"Given an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.","tags":["neetcode","medium","stack"],"link":"https://leetcode.com/problems/largest-rectangle-in-histogram/","hints":["https://wngnelson.com/assets/img_src/dsa/largest_rectangle"],"preview":"### Description\n\nGiven an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.\n\n### Example 1\n\n![image](https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg)\n\n```bash\nInput: heights = [2,1,5,6,2,3]\nOutput: 10\nExplanation: The above is a histogram where width of each bar is 1.\nThe largest rectangle is shown in the red area, which has an area = 10 units.\n```\n\n### Example 2\n\n![image](https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg)\n\n```bash\nInput: heights = [2,4]\nOutput: 4\n```\n\n### Constraints:\n\n-      1 <= heights.length <= 105     \n-      0 <= heights[i] <= 104","basename":"largest-rectangle-area"},"last-stone-weight":{"title":"Last Stone Weight","description":"You are given an array of integers stones where stones[i] is the weight of the ith stone.","tags":["neetcode","easy","heap"],"link":"https://leetcode.com/problems/last-stone-weight/","images":[],"preview":"### Description\n\nYou are given an array of integers stones where `stones[i]` is the weight of the ith stone.\n\nWe are playing a game with the stones. On each turn, we choose the **heaviest two stones** and smash them together. Suppose the heaviest two stones have weights x and y with x <= y. The result of this smash is:\n\n- If x == y, both stones are destroyed, and\n- If x != y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x.\nAt the end of the game, there is **at most one** stone left.\n\nReturn the weight of the last remaining stone. If there are no stones left, return 0.\n\n### Example 1\n\n```bash\nInput: stones = [2,7,4,1,8,1]\nOutput: 1\nExplanation: \nWe combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then,\nwe combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then,\nwe combine 2 and 1 to get 1 so the array converts to [1,1,1] then,\nwe combine 1 and 1 to get 0 so the array converts to [1] then that's the value of the last stone.\n```\n\n### Example 2\n\n```bash\nInput: stones = [1]\nOutput: 1\n```\n\n### Constraints:\n\n- 1 <= stones.length <= 30 \n- 1 <= stones[i] <= 1000","basename":"last-stone-weight"},"length-of-longest-substring":{"title":"Length of Longest Substring","description":"Given a string s, find the length of the longest substring without repeating characters.","tags":["neetcode","medium","sliding-window"],"link":"https://leetcode.com/problems/longest-substring-without-repeating-characters/","preview":"### Description\n\nGiven a string s, find the length of the longest substring without repeating characters.\n\n### Example 1\n\n\n```bash\nInput: s = \"abcabcbb\"\nOutput: 3\nExplanation: The answer is \"abc\", with the length of 3.\n```\n\n### Example 2\n```bash\nInput: s = \"bbbbb\"\nOutput: 1\nExplanation: The answer is \"b\", with the length of 1.\n```\n\n### Example 3\n```bash\nInput: s = \"pwwkew\"\nOutput: 3\nExplanation: The answer is \"wke\", with the length of 3.\nNotice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n```\n\n\n### Constraints:\n\n- 0 <= s.length <= 5 * 104\n- s consists of English letters, digits, symbols and spaces.","basename":"length-of-longest-substring"},"letter-combinations-of-a-phone-number":{"title":"Letter Combinations of a Phone Number","description":"Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.","tags":["neetcode","hard","backtracking"],"link":"https://leetcode.com/problems/letter-combinations-of-a-phone-number/","images":[],"preview":"### Description\n\nGiven a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in **any order**.\nA mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\n\n### Example 1\n\n![Example 1](https://assets.leetcode.com/uploads/2022/03/15/1200px-telephone-keypad2svg.png)\n\n\n```bash\nInput: digits = \"23\"\nOutput: [\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]\n```\n\n### Example 2\n\n```bash\nInput: digits = \"\"\nOutput: []\n```\n\n### Example 3\n\n```bash\nInput: digits = \"2\"\nOutput: [\"a\",\"b\",\"c\"]\n```\n\n\n### Constraints:\n\n- 0 <= digits.length <= 4\n- digits[i] is a digit in the range ['2', '9']","basename":"letter-combinations-of-a-phone-number"},"lexicographically-smallest-equivalent-string":{"title":"Lexicographically Smallest Equivalent String","description":"Return the lexicographically smallest equivalent string of baseStr by using the equivalency information from s1 and s2.","tags":["graph","union-find","medium"],"link":"https://leetcode.com/problems/lexicographically-smallest-equivalent-string","images":[],"preview":"### Description\n\nYou are given two strings of the same length s1 and s2 and a string baseStr.\n\nWe say s1[i] and s2[i] are equivalent characters.\n\nFor example, if s1 = \"abc\" and s2 = \"cde\", then we have 'a' == 'c', 'b' == 'd', and 'c' == 'e'.\nEquivalent characters follow the usual rules of any equivalence relation:\n\nReflexivity: 'a' == 'a'.\nSymmetry: 'a' == 'b' implies 'b' == 'a'.\nTransitivity: 'a' == 'b' and 'b' == 'c' implies 'a' == 'c'.\nFor example, given the equivalency information from s1 = \"abc\" and s2 = \"cde\", \"acd\" and \"aab\" are equivalent strings of baseStr = \"eed\", and \"aab\" is the lexicographically smallest equivalent string of baseStr.\n\nReturn the lexicographically smallest equivalent string of baseStr by using the equivalency information from s1 and s2.\n\n### Example 1\n\n```bash\nInput: s1 = \"parker\", s2 = \"morris\", baseStr = \"parser\"\nOutput: \"makkek\"\nExplanation: Based on the equivalency information in s1 and s2, we can group their characters as [m,p], [a,o], [k,r,s], [e,i].\nThe characters in each group are equivalent and sorted in lexicographical order.\nSo the answer is \"makkek\".\n```\n\n### Example 2\n\n```bash\nInput: s1 = \"hello\", s2 = \"world\", baseStr = \"hold\"\nOutput: \"hdld\"\nExplanation: Based on the equivalency information in s1 and s2, we can group their characters as [h,w], [d,e,o], [l,r].\nSo only the second letter 'o' in baseStr is changed to 'd', the answer is \"hdld\".\n```\n\n### Example 3\n\n```bash\nInput: s1 = \"leetcode\", s2 = \"programs\", baseStr = \"sourcecode\"\nOutput: \"aauaaaaada\"\nExplanation: We group the equivalent characters in s1 and s2 as [a,o,e,r,s,c], [l,p], [g,t] and [d,m], thus all letters in baseStr except 'u' and 'd' are transformed to 'a', the answer is \"aauaaaaada\".\n```\n\n### Constraints:\n\n- 1 <= s1.length, s2.length, baseStr <= 1000\n- s1.length == s2.length\n- s1, s2, and baseStr consist of lowercase English letters.","basename":"lexicographically-smallest-equivalent-string"},"linked-list-cycle":{"title":"Linked List Cycle","description":"Given head, the head of a linked list, determine if the linked list has a cycle in it.","tags":["neetcode","medium","linked-list"],"link":"https://leetcode.com/problems/linked-list-cycle/","preview":"### Description\n\nGiven `head`, the head of a linked list, determine if the linked list has a cycle in it.\n\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. **Note that** pos **is not passed as a parameter**.\n\nReturn `true` if there is a cycle in the linked list. Otherwise, return `false`.\n\n### Example 1\n\n```bash\nInput: head = [3,2,0,-4], pos = 1\nOutput: true\nExplanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).\n```\n\n### Example 2\n\n```bash\nInput: head = [1,2], pos = 0\nOutput: true\nExplanation: There is a cycle in the linked list, where the tail connects to the 0th node.\n```\n\n### Constraints:\n\n- The number of the nodes in the list is in the range [0, 104]. \n- -10^5 <= Node.val <= 10^5 \n- pos is -1 or a valid index in the linked-list.","basename":"linked-list-cycle"},"longest-arithmetic-subsequence-of-given-difference":{"title":"Longest Arithmetic Subsequence of Given Difference","description":"A subsequence is a sequence that can be derived from arr by deleting some or no elements without changing the order of the remaining elements.","tags":["medium","dp","longest-increasing-subsequence"],"link":"https://leetcode.com/problems/longest-arithmetic-subsequence-of-given-difference","images":[],"preview":"### Description\n\nGiven an integer array arr and an integer difference, return the length of the longest subsequence in arr which is an arithmetic sequence such that the difference between adjacent elements in the subsequence equals difference.\n\nA subsequence is a sequence that can be derived from arr by deleting some or no elements without changing the order of the remaining elements.\n\n### Example 1\n\n```bash\nInput: arr = [1,2,3,4], difference = 1\nOutput: 4\nExplanation: The longest arithmetic subsequence is [1,2,3,4].\n```\n\n### Example 2\n\n```bash\nInput: arr = [1,3,5,7], difference = 1\nOutput: 1\nExplanation: The longest arithmetic subsequence is any single element.\n```\n\n\n### Example 3\n\n```bash\nInput: arr = [1,5,7,8,5,3,4,2,1], difference = -2\nOutput: 4\nExplanation: The longest arithmetic subsequence is [7,5,3,1].\n```\n\n### Constraints:\n\n- 1 <= arr.length <= 105\n- -104 <= arr[i], difference <= 104","basename":"longest-arithmetic-subsequence-of-given-difference"},"longest-arithmetic-subsequence":{"title":"Longest Arithmetic Subsequence","description":"Given an array nums of integers, return the length of the longest arithmetic subsequence in nums.","tags":["medium","dp","longest-increasing-subsequence"],"link":"https://leetcode.com/problems/longest-arithmetic-subsequence","images":[],"preview":"### Description\n\nGiven an array nums of integers, return the length of the longest arithmetic subsequence in nums.\n\nNote that:\n\nA subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.\nA sequence seq is arithmetic if seq[i + 1] - seq[i] are all the same value (for 0 <= i < seq.length - 1).\n \n\n### Example 1\n\n```bash\nInput: nums = [3,6,9,12]\nOutput: 4\nExplanation:  The whole array is an arithmetic sequence with steps of length = 3.\n```\n\n### Example 2\n\n```bash\nInput: nums = [9,4,7,2,10]\nOutput: 3\nExplanation:  The longest arithmetic subsequence is [4,7,10].\n```\n\n### Example 3\n\n```bash\nInput: nums = [20,1,15,3,10,5,8]\nOutput: 4\nExplanation:  The longest arithmetic subsequence is [20,15,10,5].\n```\n\n### Constraints:\n\n- 2 <= nums.length <= 1000\n- 0 <= nums[i] <= 500","basename":"longest-arithmetic-subsequence"},"longest-common-sequence":{"title":"Longest Common Sequence","description":"Given two strings text1 and text2, return the length of their longest common subsequence. If there is no common subsequence, return 0.","tags":["medium","dp","neetcode"],"link":"https://leetcode.com/problems/longest-increasing-subsequence/","images":[],"hints":["https://wngnelson.com/assets/img_src/dsa/longest-common-sequence.gif"],"preview":"### Description\nGiven two strings text1 and text2, return the length of their longest common subsequence. If there is no common subsequence, return 0.\n\nA subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.\n\n    For example, \"ace\" is a subsequence of \"abcde\".\n\nA common subsequence of two strings is a subsequence that is common to both strings.\n### Example 1\n\n```bash\nInput: text1 = \"abcde\", text2 = \"ace\" \nOutput: 3  \nExplanation: The longest common subsequence is \"ace\" and its length is 3.\n```\n\n### Example 2\n\n```bash\nInput: text1 = \"abc\", text2 = \"abc\"\nOutput: 3\nExplanation: The longest common subsequence is \"abc\" and its length is 3.\n```\n\n### Example 3\n\n```bash\nInput: text1 = \"abc\", text2 = \"def\"\nOutput: 0\nExplanation: There is no such common subsequence, so the result is 0.\n```\n\n\n### Constraints:\n\n- 1 <= text1.length, text2.length <= 1000\n- text1 and text2 consist of only lowercase English characters","basename":"longest-common-sequence"},"longest-common-subsequence":{"title":"Longest Common Subsequence","description":"Given two strings text1 and text2, return the length of their longest common subsequence. If there is no common subsequence, return 0.","tags":["hard","algoexpert"],"link":null,"images":[],"preview":"# Longest Common Subsequence\n\nWrite a function that takes in two strings and returns their longest common subsequence.\n\nA subsequence of a string is a set of characters that aren't necessarily adjacent in the string but that are in the same order as they appear in the string. For instance, the characters [\"a\", \"c\", \"d\"] form a subsequence of the string \"abcd\", and so do the characters [\"b\", \"d\"]. Note that a single character in a string and the string itself are both valid subsequences of the string.\n\nYou can assume that there will only be one longest common subsequence.\n\n## Sample Input\n\n```\nstr1 = \"ZXVVYZW\"\nstr2 = \"XKYKZPW\"\n```\n\n## Sample Output\n\n```\n[\"X\", \"Y\", \"Z\", \"W\"]\n```\n\n### Hints\n\nHint 1\n> Try building a two-dimensional array of the longest common subsequences of substring pairs of the input strings. Let the rows of the array represent substrings of the second input string str2. Let the first row represent the empty string. Let each row i thereafter represent the substrings of str2 from 0 to i, with i excluded. Let the columns similarly represent the first input string str1.\n\nHint 2\n> Build up the array mentioned in Hint #1 one row at a time. In other words, find the longest common subsequences for all the substrings of str1 represented by the columns and the empty string represented by the first row, then for all the substrings of str1 represented by the columns and the first letter of str2 represented by the second row, etc., until you compare both full strings. Find a formula that relates the longest common subsequence at any given point to previous subsequences.\n\nHint 3\n> Do you really need to build and store subsequences at each point in the two-dimensional array mentioned in Hint #1? Try storing booleans to determine whether or not a letter at a given point in the two-dimensional array is part of the longest common subsequence as well as pointers to determine what should come before this letter in the final subsequence. Use these pointers to backtrack your way through the array and to build up the longest common subsequence at the end of your algorithm.\n\n```\nOptimal Space & Time Complexity\nO(nm) time | O(nm) space - where n and m are the lengths of the two input strings\n```","basename":"longest-common-subsequence"},"longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit":{"title":"Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit","description":"Given an array of integers nums and an integer limit, return the size of the longest non-empty subarray such that the absolute difference between any two elements of this subarray is less than or equal to limit.","tags":["medium"],"link":"https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit","images":[],"preview":"### Description\n\nGiven an array of integers nums and an integer limit, return the size of the longest non-empty subarray such that the absolute difference between any two elements of this subarray is less than or equal to limit.\n\n \n\n### Example 1\n\n```bash\nInput: nums = [8,2,4,7], limit = 4\nOutput: 2 \nExplanation: All subarrays are: \n\n[8] with maximum absolute diff |8-8| = 0 <= 4.\n[8,2] with maximum absolute diff |8-2| = 6 > 4. \n[8,2,4] with maximum absolute diff |8-2| = 6 > 4.\n[8,2,4,7] with maximum absolute diff |8-2| = 6 > 4.\n[2] with maximum absolute diff |2-2| = 0 <= 4.\n[2,4] with maximum absolute diff |2-4| = 2 <= 4.\n[2,4,7] with maximum absolute diff |2-7| = 5 > 4.\n[4] with maximum absolute diff |4-4| = 0 <= 4.\n[4,7] with maximum absolute diff |4-7| = 3 <= 4.\n[7] with maximum absolute diff |7-7| = 0 <= 4. \n\nTherefore, the size of the longest subarray is 2.\n```\n\n### Example 2\n\n```bash\nInput: nums = [10,1,2,4,7,2], limit = 5\nOutput: 4 \nExplanation: The subarray [2,4,7,2] is the longest since the maximum absolute diff is |2-7| = 5 <= 5.\n```\n\n### Constraints:\n\n- 1 <= nums.length <= 105\n- 1 <= nums[i] <= 109\n- 0 <= limit <= 109","basename":"longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit"},"longest-palindromic-subsequence":{"title":"Longest Palindromic Subsequence","description":null,"tags":[],"link":"https://leetcode.com/problems/longest-palindromic-subsequence/description/?envType=study-plan-v2&envId=dynamic-programming","images":[],"preview":"### Description\n\nGiven a string `s`, find the longest palindromic subsequence's length in `s`.\n\nA subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.\n\n### Example 1\n\n```bash\nInput: s = \"bbbab\"\nOutput: 4\nExplanation: One possible longest palindromic subsequence is \"bbbb\".\n```\n\n### Example 2\n\n```bash\nInput: s = \"cbbd\"\nOutput: 2\nExplanation: One possible longest palindromic subsequence is \"bb\".\n```\n\n### Constraints:\n\n- 1 <= s.length <= 1000\n- s consists only of lowercase English letters.","basename":"longest-palindromic-subsequence"},"longest-palindromic-substring":{"title":"Longest Palindromic Substring","description":"Given a string s, return the longest palindromic substring in s.","tags":["medium","dp","neetcode"],"link":"https://leetcode.com/problems/longest-palindromic-substring/","images":[],"preview":"### Description\n\nGiven a string `s`, return the longest palindromic substring in `s`.\n\n### Example 1\n\n```bash\nInput: s = \"babad\"\nOutput: \"bab\"\nExplanation: \"aba\" is also a valid answer.\n```\n\n### Example 2\n\n```bash\nInput: s = \"cbbd\"\nOutput: \"bb\"\n```\n\n### Constraints:\n\n- 1 <= s.length <= 1000\n- s consist of only digits and English letters.","basename":"longest-palindromic-substring"},"longest-string-chain":{"title":"Longest String Chain","description":"Return the length of the longest possible word chain with words chosen from the given list of words.","tags":["medium","dp","general-1d"],"link":"https://leetcode.com/problems/longest-string-chain","images":[],"preview":"### Description\n\nYou are given an array of words where each word consists of lowercase English letters.\n\nwordA is a predecessor of wordB if and only if we can insert exactly one letter anywhere in wordA without changing the order of the other characters to make it equal to wordB.\n\nFor example, \"abc\" is a predecessor of \"abac\", while \"cba\" is not a predecessor of \"bcad\".\nA word chain is a sequence of words [word1, word2, ..., wordk] with k >= 1, where word1 is a predecessor of word2, word2 is a predecessor of word3, and so on. A single word is trivially a word chain with k == 1.\n\nReturn the length of the longest possible word chain with words chosen from the given list of words.\n\n\n\n### Example 1\n\n```bash\nInput: words = [\"a\",\"b\",\"ba\",\"bca\",\"bda\",\"bdca\"]\nOutput: 4\nExplanation: One of the longest word chains is \n\n[\"a\",\"ba\",\"bda\",\"bdca\"].\n```\n\n### Example 2\n\n```bash\nInput: words = [\"xbc\",\"pcxbcf\",\"xb\",\"cxbc\",\"pcxbc\"]\nOutput: 5\nExplanation: All the words can be put in a word chain \n\n[\"xb\", \"xbc\", \"cxbc\", \"pcxbc\", \"pcxbcf\"].\n```\n\n### Example 3\n\n```bash\nInput: words = [\"abcd\",\"dbqca\"]\nOutput: 1\nExplanation: The trivial word chain [\"abcd\"] is one of the longest word chains.\n[\"abcd\",\"dbqca\"] is not a valid word chain because the ordering of the letters is changed.\n```\n\n### Constraints:\n\n- 1 <= words.length <= 1000\n- 1 <= words[i].length <= 16\n- words[i] only consists of lowercase English letters.","basename":"longest-string-chain"},"longest-substring-without-repeating-characters":{"title":"Longest Substring Without Repeating Characters","description":null,"tags":[],"link":null,"images":[],"preview":"### Description\n\n\n\n### Example 1\n\n```bash\nInput: s = \"abcabcbb\"\nOutput: 3\nExplanation: The answer is \"abc\", with the length of 3.\n```\n\n### Example 2\n\n```bash\nInput: s = \"bbbbb\"\nOutput: 1\nExplanation: The answer is \"b\", with the length of 1.\n```","basename":"longest-substring-without-repeating-characters"},"longest-valid-parentheses":{"title":"Longest Valid Parentheses","description":"Given a string containing just the characters '(' and ')', return the length of the longest valid (well-formed) parentheses substring.","tags":["hard","dp","general-1d"],"link":"https://leetcode.com/problems/longest-valid-parentheses","images":[],"preview":"### Description\n\nGiven a string containing just the characters '(' and ')', return the length of the longest valid (well-formed) parentheses substring.\n\n### Example 1\n\n```bash\nInput: s = \"(()\"\nOutput: 2\nExplanation: The longest valid parentheses substring is \"()\".\n```\n\n### Example 2\n\n```bash\nInput: s = \")()())\"\nOutput: 4\nExplanation: The longest valid parentheses substring is \"()()\".\n```\n\n\n### Example 3\n\n```bash\nInput: s = \"\"\nOutput: 0\n```\n\n### Constraints:\n\n- 0 <= s.length <= 3 * 104\n- s[i] is '(', or ')'.","basename":"longest-valid-parentheses"},"lowest-common-manager":{"title":"Lowest Common Manager","tags":["hard","algoexpert"],"preview":"# Lowest Common Manager\n\nYou're given three inputs, all of which are instances of an OrgChart class that have a directReports property pointing to their direct reports. The first input is the top manager in an organizational chart (i.e., the only instance that isn't anybody else's direct report), and the other two inputs are reports in the organizational chart. The two reports are guaranteed to be distinct.\n\nWrite a function that returns the lowest common manager to the two reports.\n\n## Sample Input\n``` \n// From the organizational chart below.\ntopManager = Node A\nreportOne = Node E\nreportTwo = Node I\n          A\n       /     \\\n      B       C\n    /   \\   /   \\\n   D     E F     G\n /   \\\nH     I\n``` \n\n## Sample Output\n```\nNode B\n```\n\n### Hints\n\nHint 1\n> Given a random subtree in the organizational chart, the manager at the root of that subtree is common to any two reports in the subtree.\n\nHint 2\n> Knowing Hint #1, the lowest common manager to two reports in an organizational chart is the root of the lowest subtree containing those two reports. Find that lowest subtree to find the lowest common manager.\n\nHint 3\n> To find the lowest subtree containing both of the input reports, try recursively traversing the organizational chart and keeping track of the number of those reports contained in each subtree as well as the lowest common manager in each subtree. Some subtrees might contain neither of the two reports, some might contain one of them, and others might contain both; the first to contain both should return the lowest common manager for all of the subtrees above it that contain it, including the entire organizational chart.\n\n```\nOptimal Space & Time Complexity\nO(n) time | O(d) space - where n is the number of people in the org and d is the depth (height) of the org chart\n```\n\n![solution](answer.png)","basename":"lowest-common-manager"},"lru-cache":{"title":"LRU Cache","description":"Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.","tags":["neetcode","medium","linked-list"],"link":"https://leetcode.com/problems/lru-cache/","preview":"### Description\n\nDesign a data structure that follows the constraints of a Least Recently Used (LRU) cache.\n\nImplement the `LRUCache` class:\n\n- LRUCache(int capacity) Initialize the LRU cache with **positive** size capacity.\n- `int get(int key)` Return the value of the key if the key exists, otherwise return -1.\n- void `put(int key, int value)` Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, **evict** the least recently used key.\n\nThe functions get and put must each run in O(1) average time complexity.\n\n### Example 1\n\n```bash\nInput\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\nOutput\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\nExplanation\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // cache is {1=1}\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\nlRUCache.get(2);    // returns -1 (not found)\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\nlRUCache.get(1);    // return -1 (not found)\nlRUCache.get(3);    // return 3\nlRUCache.get(4);    // return 4\n```\n\n\n### Constraints:\n\n- 1 <= capacity <= 3000\n- 0 <= key <= 104\n- 0 <= value <= 105\n- At most 2 * 105 calls will be made to get and put.","basename":"lru-cache"},"make-array-strictly-increasing":{"title":"Make Array Strictly Increasing","description":"If there is no way to make arr1 strictly increasing, return -1.","tags":["hard","grand-dp","with-binary-search"],"link":"https://leetcode.com/problems/make-array-strictly-increasing/","images":[],"preview":"### Description\n\nGiven two integer arrays arr1 and arr2, return the minimum number of operations (possibly zero) needed to make arr1 strictly increasing.\n\nIn one operation, you can choose two indices 0 <= i < arr1.length and 0 <= j < arr2.length and do the assignment arr1[i] = arr2[j].\n\nIf there is no way to make arr1 strictly increasing, return -1.\n\n### Example 1\n\n```bash\nInput: arr1 = [1,5,3,6,7], arr2 = [1,3,2,4]\nOutput: 1\nExplanation: Replace 5 with 2, then arr1 = [1, 2, 3, 6, 7].\n```\n\n### Example 2\n\n```bash\nInput: arr1 = [1,5,3,6,7], arr2 = [4,3,1]\nOutput: 2\nExplanation: Replace 5 with 3 and then replace 3 with 4. \n\narr1 = [1, 3, 4, 6, 7].\n```\n\n### Example 3\n\n```bash\nInput: arr1 = [1,5,3,6,7], arr2 = [1,6,3,3]\nOutput: -1\nExplanation: You can't make arr1 strictly increasing.\n```\n\n### Constraints:\n\n- 1 <= arr1.length, arr2.length <= 2000\n- 0 <= arr1[i], arr2[i] <= 10^9","basename":"make-array-strictly-increasing"},"max-area-of-island":{"title":"Max Area of Island","description":"You are given an m x n binary matrix grid. An island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.","tags":["neetcode","medium","graphs"],"link":"https://leetcode.com/problems/max-area-of-island/","images":[],"preview":"### Description\n\nYou are given an m x n binary matrix grid. An island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.\n\nThe area of an island is the number of cells with a value 1 in the island.\n\nReturn the maximum area of an island in grid. If there is no island, return 0.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2021/05/01/maxarea1-grid.jpg)\n\n```bash\nInput: grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]\nOutput: 6\nExplanation: The answer is not 11, because the island must be connected 4-directionally.\n```\n\n### Example 2\n\n```bash\nInput: grid = [[0,0,0,0,0,0,0,0]]\nOutput: 0\n```\n\n### Constraints:\n\n- m == grid.length \n- n == grid[i].length \n- 1 <= m, n <= 50 \n- grid[i][j] is either 0 or 1.","basename":"max-area-of-island"},"max-path-sum":{"title":"Max Path Sum","description":"Given a non-empty binary tree, find the maximum path sum.","tags":["hard","algoexpert"],"link":null,"images":[],"hints":["https://wngnelson.com/assets/img_src/dsa/maxpathsum.gif"],"preview":"# Max Path Sum In Binary Tree\n\nWrite a function that takes in a Binary Tree and returns its max path sum.\n\nA path is a collection of connected nodes in a tree, where no node is connected to more than two other nodes; a path sum is the sum of the values of the nodes in a particular path.\n\nEach BinaryTree node has an integer value, a left child node, and a right child node. Children nodes can either be BinaryTree nodes themselves or None / null.\n\n## Sample Input\n```\ntree = 1\n    /     \\\n   2       3\n /   \\   /   \\\n4     5 6     7\n```\n\n## Sample Output\n```\n18 // 5 + 2 + 1 + 3 + 7\n```\n\n### Hints\n\nHint 1\n> If you were to imagine each node in a Binary Tree as the root of the Binary Tree, temporarily eliminating all of the nodes that come above it, how would you find the max path sum for each of these newly imagined Binary Trees? In simpler terms, how can you find the max path sum for each subtree in the Binary Tree?\n\nHint 2\n> For every node in a Binary Tree, there are four options for the max path sum that includes its value: the node's value alone, the node's value plus the max path sum of its left subtree, the node's value plus the max path sum of its right subtree, or the node's value plus the max path sum of both its subtrees.\n\nHint 3\n> A recursive algorithm that computes each node's max path sum and uses it to compute its parents' nodes' max path sums seems appropriate, but realize that you cannot have a path going through a node and both its subtrees as well as that node's parent node. In other words, the fourth option mentioned in Hint #2 poses a challenge to implementing a recursive algorithm that solves this problem. How can you get around it?\n\n```\nOptimal Space & Time Complexity\nO(n) time | O(log(n)) space - where n is the number of nodes in the Binary Tree\n```\n\n![solution](pseudocode.png)\n\n### Notes\n\nIn the video explanation, we forget to handle the edge case where all nodes in the input Binary Tree have negative values.\n\nIn this case, the maxPathSum is guaranteed to be negative, since there are no positive-valued nodes.\n\nThis means that we can't set the base-case leftMaxPathSum and rightMaxPathSum values, when the left and / or right child nodes are null, to 0. Setting them to 0 means that the final maxPathSum will always be 0, since the final computation in our recursive method will compare 0 to a negative value.\n\n```\nmaxPathSum = max(leftMaxPathSum, rightMaxPathSum, maxSumAsRootNode)\n```\nThis operation will always yield 0 when maxSumAsRootNode is negative and leftMaxPathSum and / or rightMaxPathSum are 0.\n\nTherefore, we set the base-case leftMaxPathSum and rightMaxPathSum values, when the left and / or right child nodes are null, to -Infinity (or whatever the min number in your programming language is).\n\n```\nif tree is None:\n    return (0, float(\"-inf\"))\n```","basename":"max-path-sum"},"max-points-on-a-line":{"title":"Max Points on a Line","description":"Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane, return the maximum number of points that lie on the same straight line.","tags":["hard","math"],"link":null,"images":[],"preview":"### Description\n\nGiven an array of points where points[i] = [xi, yi] represents a point on the X-Y plane, return the maximum number of points that lie on the same straight line.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2021/02/25/plane1.jpg)\n\n```bash\nInput: points = [[1,1],[2,2],[3,3]]\nOutput: 3\n```\n\n### Example 2\n\n![](https://assets.leetcode.com/uploads/2021/02/25/plane2.jpg)\n\n```bash\nInput: points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]\nOutput: 4\n```\n\n### Constraints:\n\n- 1 <= points.length <= 300\n- points[i].length == 2\n- -104 <= xi, yi <= 104\n- All the points are unique.","basename":"max-points-on-a-line"},"max-profit":{"title":"Max Profit","description":"Best time to Buy and Sell Stock","tags":["neetcode","easy","sliding-window"],"link":"https://leetcode.com/problems/best-time-to-buy-and-sell-stock/","preview":"### Description\n\nYou are given an array prices where prices[i] is the price of a given stock on the ith day.\n\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\n\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.\n\n### Example 1\n\n```bash\nInput: prices = [7,1,5,3,6,4]\nOutput: 5\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n```\n\n### Example 2\n\n```bash\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: In this case, no transactions are done and the max profit = 0.\n```\n\n### Constraints:\n\n-  1 <= prices.length <= 105\n-  0 <= prices[i] <= 104","basename":"max-profit"},"max-sliding-window":{"title":"Max Sliding Window","description":"Sliding Window Maximum","tags":["neetcode","hard","sliding-window"],"link":"https://leetcode.com/problems/sliding-window-maximum/","preview":"### Description\n\nYou are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.  Return the max sliding window.\n\n### Example 1\n\nNote how the maximum at each movemnet is added to the results list\n\n```bash\nInput: nums = [1,3,-1,-3,5,3,6,7], k = 3\nOutput: [3,3,5,5,6,7]\nExplanation: \nWindow position                Max\n---------------               -----\n[1  3  -1] -3  5  3  6  7       3\n 1 [3  -1  -3] 5  3  6  7       3\n 1  3 [-1  -3  5] 3  6  7       5\n 1  3  -1 [-3  5  3] 6  7       5\n 1  3  -1  -3 [5  3  6] 7       6\n 1  3  -1  -3  5 [3  6  7]      7\n```\n\n### Example 2\n```bash\nInput: nums = [1], k = 1\nOutput: [1]\n```\n\n### Constraints:\n\n-      1 <= nums.length <= 10^5     \n-      -10^4 <= nums[i] <= 10^4     \n-      1 <= k <= nums.length","basename":"max-sliding-window"},"max-sum-increasing-subsequence":{"title":"Max Sum Increasing Subsequence","description":"Write a function that takes in a non-empty array of integers and returns the greatest sum that can be generated from a strictly-increasing subsequence in the array as well as an array of the numbers in that subsequence.","tags":[],"link":null,"images":[],"preview":"# Max Sum Increasing Subsequence\n\nWrite a function that takes in a non-empty array of integers and returns the greatest sum that can be generated from a strictly-increasing subsequence in the array as well as an array of the numbers in that subsequence.\n\nA subsequence of an array is a set of numbers that aren't necessarily adjacent in the array but that are in the same order as they appear in the array. For instance, the numbers [1, 3, 4] form a subsequence of the array [1, 2, 3, 4], and so do the numbers [2, 4]. Note that a single number in an array and the array itself are both valid subsequences of the array.\n\nYou can assume that there will only be one increasing subsequence with the greatest sum.\n\n## Sample Input\n\n```\narray = [10, 70, 20, 30, 50, 11, 30]\n```\n\n## Sample Output\n\n```\n[110, [10, 20, 30, 50]] // The subsequence [10, 20, 30, 50] is strictly increasing and yields the greatest sum: 110.\n```\n\n### Hints\n\nHint 1\n> Try building an array of the same length as the input array. At each index in this new array, store the maximum sum that can be generated from an increasing subsequence ending with the number found at that index in the input array.\n\nHint 2\n> Can you efficiently keep track of potential sequences in another array? Instead of storing entire sequences, try storing the indices of previous numbers. For example, at index 3 in this other array, store the index of the before-last number in the max-sum increasing subsequence ending with the number at index 3.\n\n```\nOptimal Space & Time Complexity\nO(n^2) time | O(n) space - where n is the length of the input array\n```","basename":"max-sum-increasing-subsequence"},"maximal-network-rank":{"title":"Maximal Network Rank","description":"Given the integer n and the array roads, return the maximal network rank of the entire infrastructure.","tags":["medium","graph","game-theory"],"link":"https://leetcode.com/problems/maximal-network-rank","images":[],"preview":"### Description\n\nThere is an infrastructure of n cities with some number of roads connecting these cities. Each roads[i] = [ai, bi] indicates that there is a bidirectional road between cities ai and bi.\n\nThe network rank of two different cities is defined as the total number of directly connected roads to either city. If a road is directly connected to both cities, it is only counted once.\n\nThe maximal network rank of the infrastructure is the maximum network rank of all pairs of different cities.\n\nGiven the integer n and the array roads, return the maximal network rank of the entire infrastructure.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2020/09/21/ex1.png)\n\n```bash\nInput: n = 4, roads = [[0,1],[0,3],[1,2],[1,3]]\nOutput: 4\nExplanation: The network rank of cities 0 and 1 is 4 as there are 4 roads that are connected to either 0 or 1. The road between 0 and 1 is only counted once.\n```\n\n### Example 2\n\n![](https://assets.leetcode.com/uploads/2020/09/21/ex2.png)\n\n```bash\nInput: n = 5, roads = [[0,1],[0,3],[1,2],[1,3],[2,3],[2,4]]\nOutput: 5\nExplanation: There are 5 roads that are connected to cities 1 or 2.\n```\n\n### Example 3\n\n```bash\nInput: n = 8, roads = [[0,1],[1,2],[2,3],[2,4],[5,6],[5,7]]\nOutput: 5\nExplanation: The network rank of 2 and 5 is 5. Notice that all the cities do not have to be connected.\n```\n\n### Constraints:\n\n- 2 <= n <= 100\n- 0 <= roads.length <= n * (n - 1) / 2\n- roads[i].length == 2\n- 0 <= ai, bi <= n-1\n- ai != bi\n- Each pair of cities has at most one road connecting them.","basename":"maximal-network-rank"},"maximal-square":{"title":"Maximal Square","description":"Given an m x n binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.","tags":["medium","dynamic-programming"],"link":"https://leetcode.com/problems/maximal-square","images":[],"preview":"### Description\n\nGiven an m x n binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.\n\n### Example 1\n\n```bash\nInput: matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]\nOutput: 4\n```\n\n### Example 2\n\n```bash\nInput: matrix = [[\"0\",\"1\"],[\"1\",\"0\"]]\nOutput: 1\n```\n\n### Example 3\n\n```bash\nInput: matrix = [[\"0\"]]\nOutput: 0\n```\n\n### Constraints:\n\n- m == matrix.length\n- n == matrix[i].length\n- 1 <= m, n <= 300\n- matrix[i][j] is '0' or '1'.","basename":"maximal-square"},"maximize-expression":{"title":"Maximize Expression","tags":["hard","algoexpert"],"preview":"# Maximize Expression\n\nWrite a function that takes in an array of integers and returns the largest possible value for the expression array[a] - array[b] + array[c] - array[d], where a, b, c, and d are indices of the array and a < b < c < d.\n\nIf the input array has fewer than 4 elements, your function should return 0.\n\n## Sample Input\n\n```\narray = [3, 6, 1, -3, 2, 7]\n```\n\n## Sample Output\n\n```\n4\n// Choose a = 1, b = 3, c = 4, and d = 5\n// -> 6 - (-3) + 2 - 7 = 4\n```\n\n### Hints\n\nHint 1\n> The brute-force approach to solving this problem is to simply iterate through every valid choice of a, b, c, and d and to evaluate the expression at each iteration. While doing this, you can keep track of the maximum value that you find and return it after considering all possibilities. This solution runs in O(n^4) time; can you think of a way to solve this faster?\n\nHint 2\n> You can solve this problem using dynamic programming with a time complexity of O(n); however, you'll need to use external space.\n\nHint 3\n> If you know what the maximum possible value of a is at each index in the array, you can find the maximum possible value of a - b at each individual index in the array in O(1) time (or in O(n) time for all indices). The same thing holds for finding the maximum possible value of a - b + c if you know the maximum possible value of a - b at each index. How does this fact help you solve the entire problem in O(n) time?\n\nHint 4\n> Start by finding the maximum possible value of a at each index in the array, meaning the maximum value of a that you can obtain at each index i if a is chosen from an index between 0 and i, inclusive. Store all of these values in an array, and use them to help you determine the maximum possible value of a - b at each index. Do the same for a - b + c (using the results from a - b) and a - b + c - d (using the results from a - b + c). Once you make it to a - b + c - d, you'll be able to determine the maximum value of the expression.\n\n```\nOptimal Space & Time Complexity\nO(n) time | O(n) space - where n is the length of the array\n```","basename":"maximize-expression"},"maximize-score-after-n-operations":{"title":"Maximize Score After N Operations","description":"Return the maximum score you can receive after performing n operations.","tags":["hard","grand-dp","bitmasking"],"link":"https://leetcode.com/problems/maximize-score-after-n-operations/","images":[],"preview":"### Description\n\nYou are given nums, an array of positive integers of size 2 * n. You must perform n operations on this array.\n\nIn the ith operation (1-indexed), you will:\n\n- Choose two elements, x and y.\n- Receive a score of i * gcd(x, y).\n- Remove x and y from nums.\n\nReturn the maximum score you can receive after performing n operations.\n\nThe function gcd(x, y) is the greatest common divisor of x and y.\n\n### Example 1\n\n```bash\nInput: nums = [1,2]\nOutput: 1\nExplanation: The optimal choice of operations is:\n(1 * gcd(1, 2)) = 1\n```\n\n### Example 2\n\n```bash\nInput: nums = [3,4,6,8]\nOutput: 11\nExplanation: The optimal choice of operations is:\n(1 * gcd(3, 6)) + (2 * gcd(4, 8)) = 3 + 8 = 11\n```\n\n### Example 3\n\n```bash\nInput: nums = [1,2,3,4,5,6]\nOutput: 14\nExplanation: The optimal choice of operations is:\n(1 * gcd(1, 5)) + (2 * gcd(2, 4)) + (3 * gcd(3, 6)) = 1 + 4 + 9 = 14\n```\n\n### Constraints:\n\n- 1 <= n <= 7\n- nums.length == 2 * n\n- 1 <= nums[i] <= 106","basename":"maximize-score-after-n-operations"},"maximum-depth-of-binary-tree":{"title":"Maximum Depth of Binary Tree","description":"A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.","tags":["neetcode","easy","binary-tree"],"link":"https://leetcode.com/problems/maximum-depth-of-binary-tree/","images":["https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg"],"preview":"### Description\n\nGiven the root of a binary tree, return its maximum depth.\n\nA binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg)\n\n```bash\nInput: root = [3,9,20,null,null,15,7]\nOutput: 3\n```\n\n### Example 2\n\n```bash\nInput: root = [1,null,2]\nOutput: 2\n```\n\n### Constraints:\n\n- The number of nodes in the tree is in the range [0, 104]. \n- -100 <= Node.val <= 100","basename":"maximum-depth-of-binary-tree"},"maximum-element-after-decreasing-and-rearranging":{"title":"Maximum Element After Decreasing and Rearranging","description":"You are given an array of positive integers arr. Perform some operations (possibly none) on arr so that it satisfies these conditions","tags":["medium","daily"],"link":"https://leetcode.com/problems/maximum-element-after-decreasing-and-rearranging/description/?envType=daily-question&envId=2023-11-15","images":[],"preview":"### Description\n\nYou are given an array of positive integers arr. Perform some operations (possibly none) on arr so that it satisfies these conditions:\n\nThe value of the first element in arr must be 1.\nThe absolute difference between any 2 adjacent elements must be less than or equal to 1. In other words, abs(arr[i] - arr[i - 1]) <= 1 for each i where 1 <= i < arr.length (0-indexed). abs(x) is the absolute value of x.\nThere are 2 types of operations that you can perform any number of times:\n\nDecrease the value of any element of arr to a smaller positive integer.\nRearrange the elements of arr to be in any order.\nReturn the maximum possible value of an element in arr after performing the operations to satisfy the conditions.\n\n \n\n### Example 1\n\n```bash\nInput: arr = [2,2,1,2,1]\nOutput: 2\nExplanation: \nWe can satisfy the conditions by rearranging arr so it becomes [1,2,2,2,1].\nThe largest element in arr is 2.\n```\n\n### Example 2\n\n```bash\nInput: arr = [100,1,1000]\nOutput: 3\nExplanation: \nOne possible way to satisfy the conditions is by doing the following:\n1. Rearrange arr so it becomes [1,100,1000].\n2. Decrease the value of the second element to 2.\n3. Decrease the value of the third element to 3.\nNow arr = [1,2,3], which satisfies the conditions.\nThe largest element in arr is 3.\n```\n\n### Example 3\n\n```bash\nInput: arr = [1,2,3,4,5]\nOutput: 5\nExplanation: The array already satisfies the conditions, and the largest element is 5.\n```\n\n### Constraints:\n\n- 1 <= arr.length <= 105\n- 1 <= arr[i] <= 109","basename":"maximum-element-after-decreasing-and-rearranging"},"maximum-length-of-pair-chain":{"title":"Maximum Length of Pair Chain","description":"Return the length longest chain which can be formed.","tags":["medium","dp","longest-increasing-subsequence"],"link":"https://leetcode.com/problems/maximum-length-of-pair-chain/","images":[],"preview":"### Description\n\nYou are given an array of n pairs pairs where pairs[i] = [lefti, righti] and lefti < righti.\n\nA pair `p2 = [c, d]` follows a pair `p1 = [a, b]` if `b < c`. A chain of pairs can be formed in this fashion.\n\nReturn the length longest chain which can be formed.\n\nYou do not need to use up all the given intervals. You can select pairs in any order.\n\n### Example 1\n\n```bash\nInput: pairs = [[1,2],[2,3],[3,4]]\nOutput: 2\nExplanation: The longest chain is [1,2] -> [3,4].\n```\n\n### Example 2\n\n```bash\nInput: pairs = [[1,2],[7,8],[4,5]]\nOutput: 3\nExplanation: The longest chain is [1,2] -> [4,5] -> [7,8].\n```\n\n### Constraints:\n\n- n == pairs.length\n- 1 <= n <= 1000\n- -1000 <= lefti < righti <= 1000","basename":"maximum-length-of-pair-chain"},"maximum-number-of-achievable-transfer-requests":{"title":"Maximum Number of Achievable Transfer Requests","description":"You are given an array requests where requests[i] = [fromi, toi] represents an employee's request to transfer from building fromi to building toi.","tags":["hard","grand-dp","knapsack"],"link":"https://leetcode.com/problems/maximum-number-of-achievable-transfer-requests","images":[],"preview":"### Description\n\nWe have n buildings numbered from 0 to n - 1. Each building has a number of employees. It's transfer season, and some employees want to change the building they reside in.\n\nYou are given an array requests where requests[i] = [fromi, toi] represents an employee's request to transfer from building fromi to building toi.\n\nAll buildings are full, so a list of requests is achievable only if for each building, the net change in employee transfers is zero. This means the number of employees leaving is equal to the number of employees moving in. For example if n = 3 and two employees are leaving building 0, one is leaving building 1, and one is leaving building 2, there should be two employees moving to building 0, one employee moving to building 1, and one employee moving to building 2.\n\nReturn the maximum number of achievable requests.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2020/09/10/move1.jpg)\n\n```bash\nInput: n = 5, requests = [[0,1],[1,0],[0,1],[1,2],[2,0],[3,4]]\nOutput: 5\nExplantion: Let's see the requests:\nFrom building 0 we have employees x and y and both want to move to building 1.\nFrom building 1 we have employees a and b and they want to move to buildings 2 and 0 respectively.\nFrom building 2 we have employee z and they want to move to building 0.\nFrom building 3 we have employee c and they want to move to building 4.\nFrom building 4 we don't have any requests.\nWe can achieve the requests of users x and b by swapping their places.\nWe can achieve the requests of users y, a and z by swapping the places in the 3 buildings.\n```\n\n### Example 2\n\n![](https://assets.leetcode.com/uploads/2020/09/10/move2.jpg)\n\n```bash\nInput: n = 3, requests = [[0,0],[1,2],[2,1]]\nOutput: 3\nExplantion: Let's see the requests:\nFrom building 0 we have employee x and they want to stay in the same building 0.\nFrom building 1 we have employee y and they want to move to building 2.\nFrom building 2 we have employee z and they want to move to building 1.\nWe can achieve all the requests. \n```\n\n### Constraints:\n\n- 1 <= n <= 20\n- 1 <= requests.length <= 16\n- requests[i].length == 2\n- 0 <= fromi, toi < n","basename":"maximum-number-of-achievable-transfer-requests"},"maximum-number-of-events-that-can-be-attended-ii":{"title":"Maximum Number of Events That Can Be Attended II","description":"You can only attend one event at a time. If you choose to attend an event, you must attend the entire event. Note that the end day is inclusive","tags":["hard","grand-dp","with-binary-search"],"link":"https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended-ii","images":[],"preview":"### Description\n\nYou are given an array of events where events[i] = [startDayi, endDayi, valuei]. The ith event starts at startDayi and ends at endDayi, and if you attend this event, you will receive a value of valuei. You are also given an integer k which represents the maximum number of events you can attend.\n\nYou can only attend one event at a time. If you choose to attend an event, you must attend the entire event. Note that the end day is inclusive: that is, you cannot attend two events where one of them starts and the other ends on the same day.\n\nReturn the maximum sum of values that you can receive by attending events.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2021/01/10/screenshot-2021-01-11-at-60048-pm.png)\n\n```bash\nInput: events = [[1,2,4],[3,4,3],[2,3,1]], k = 2\nOutput: 7\nExplanation: Choose the green events, 0 and 1 (0-indexed) for a total value of 4 + 3 = 7.\n```\n\n### Example 2\n\n![](https://assets.leetcode.com/uploads/2021/01/10/screenshot-2021-01-11-at-60150-pm.pngs)\n\n```bash\nInput: events = [[1,2,4],[3,4,3],[2,3,10]], k = 2\nOutput: 10\nExplanation: Choose event 2 for a total value of 10.\nNotice that you cannot attend any other event as they overlap, and that you do not have to attend k events.\n```\n\n### Example 3\n\n![](https://assets.leetcode.com/uploads/2021/01/10/screenshot-2021-01-11-at-60703-pm.png)\n\n```bash\nInput: events = [[1,1,1],[2,2,2],[3,3,3],[4,4,4]], k = 3\nOutput: 9\nExplanation: Although the events do not overlap, you can only attend 3 events. Pick the highest valued three.\n```\n\n### Constraints:\n\n- 1 <= k <= events.length\n- 1 <= k * events.length <= 106\n- 1 <= startDayi <= endDayi <= 109\n- 1 <= valuei <= 106","basename":"maximum-number-of-events-that-can-be-attended-ii"},"maximum-product-of-splitted-binary-tree":{"title":"Maximum Product of Splitted Binary Tree","description":"Return the maximum product of the sums of the two subtrees. Since the answer may be too large, return it modulo 109 + 7.","tags":["medium","grand-dp","on-tree"],"link":"https://leetcode.com/problems/maximum-product-of-splitted-binary-tree/","images":[],"preview":"### Description\n\nGiven the root of a binary tree, split the binary tree into two subtrees by removing one edge such that the product of the sums of the subtrees is maximized.\n\nReturn the maximum product of the sums of the two subtrees. Since the answer may be too large, return it modulo 109 + 7.\n\nNote that you need to maximize the answer before taking the mod and not after taking it.\n\n \n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2020/01/21/sample_1_1699.png)\n\n```bash\nInput: root = [1,2,3,4,5,6]\nOutput: 110\nExplanation: Remove the red edge and get 2 binary trees with sum 11 and 10. Their product is 110 (11*10)\n```\n\n### Example 2\n\n![](https://assets.leetcode.com/uploads/2020/01/21/sample_2_1699.png)\n\n```bash\nInput: root = [1,null,2,3,4,null,null,5,6]\nOutput: 90\nExplanation: Remove the red edge and get 2 binary trees with sum 15 and 6.Their product is 90 (15*6)\n```\n\n### Constraints:\n\n- The number of nodes in the tree is in the range [2, 5 * 104].\n- 1 <= Node.val <= 104","basename":"maximum-product-of-splitted-binary-tree"},"maximum-product-subarray":{"title":"Maximum Product Subarray","description":"Given an integer array nums, find a subarray that has the largest product, and return the product.","tags":["medium","dp","neetcode"],"link":"https://leetcode.com/problems/maximum-product-subarray/","images":[],"hints":["https://wngnelson.com/assets/img_src/dsa/maximum+Product+subarray.gif"],"preview":"### Description\n\nGiven an integer array `nums`, find a subarray that has the largest product, and return the product.\n\nThe test cases are generated so that the answer will fit in a **32-bit** integer.\n\n### Example 1\n\n```bash\nInput: nums = [2,3,-2,4]\nOutput: 6\nExplanation: [2,3] has the largest product 6.\n```\n\n### Example 2\n\n```bash\nInput: nums = [-2,0,-1]\nOutput: 0\nExplanation: The result cannot be 2, because [-2,-1] is not a subarray.\n```\n\n### Constraints:\n\n- 1 <= nums.length <= 2 * 104\n- -10 <= nums[i] <= 10\n- The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.","basename":"maximum-product-subarray"},"maximum-profit-in-job-scheduling":{"title":"Maximum Profit in Job Scheduling","description":"We have n jobs, where every job is scheduled to be done from startTime[i] to endTime[i], obtaining a profit of profit[i].","tags":["hard","grand-dp","with-binary-search"],"link":"https://leetcode.com/problems/maximum-profit-in-job-scheduling/","images":[],"preview":"### Description\n    \nWe have n jobs, where every job is scheduled to be done from startTime[i] to endTime[i], obtaining a profit of profit[i].\n\nYou're given the startTime, endTime and profit arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.\n\nIf you choose a job that ends at time X you will be able to start another job that starts at time X.\n\n### Example 1\n\n```bash\nInput: startTime = [1,2,3,3], endTime = [3,4,5,6], profit = [50,10,40,70]\nOutput: 120\nExplanation: The subset chosen is the first and fourth job. \nTime range [1-3]+[3-6] , we get profit of 120 = 50 + 70.\n```\n\n### Example 2\n\n```bash\nInput: startTime = [1,2,3,4,6], endTime = [3,5,10,6,9], profit = [20,20,100,70,60]\nOutput: 150\nExplanation: The subset chosen is the first, fourth and fifth job. \nProfit obtained 150 = 20 + 70 + 60.\n```\n\n### Constraints:\n\n- 1 <= startTime.length == endTime.length == profit.length <= 5 * 104\n- 1 <= startTime[i] < endTime[i] <= 10^9\n- 1 <= profit[i] <= 10^4","basename":"maximum-profit-in-job-scheduling"},"maximum-score-from-performing-multiplication-operations":{"title":"Maximum Score from Performing Multiplication Operations","description":"Return the maximum score after performing m operations.","tags":["hard","dp","general-1d"],"link":"https://leetcode.com/problems/maximum-score-from-performing-multiplication-operations","images":[],"preview":"### Description\n\nYou are given two 0-indexed integer arrays nums and multipliers of size n and m respectively, where n >= m.\n\nYou begin with a score of 0. You want to perform exactly m operations. On the ith operation (0-indexed) you will:\n\n- Choose one integer x from either the start or the end of the array nums.\n- Add multipliers[i] * x to your score.\n- Note that multipliers[0] corresponds to the first operation, multipliers[1] to the second operation, and so on.\n\nRemove x from nums.\nReturn the maximum score after performing m operations.\n\n### Example 1\n\n```bash\nInput: nums = [1,2,3], multipliers = [3,2,1]\nOutput: 14\nExplanation: An optimal solution is as follows:\n- Choose from the end, [1,2,3], adding 3 * 3 = 9 to the score.\n- Choose from the end, [1,2], adding 2 * 2 = 4 to the score.\n- Choose from the end, [1], adding 1 * 1 = 1 to the score.\nThe total score is 9 + 4 + 1 = 14.\n```\n\n### Example 2\n\n```bash\nInput: nums = [-5,-3,-3,-2,7,1], multipliers = [-10,-5,3,4,6]\nOutput: 102\nExplanation: An optimal solution is as follows:\n- Choose from the start, [-5,-3,-3,-2,7,1], adding -5 * -10 = 50 to the score.\n- Choose from the start, [-3,-3,-2,7,1], adding -3 * -5 = 15 to the score.\n- Choose from the start, [-3,-2,7,1], adding -3 * 3 = -9 to the score.\n- Choose from the end, [-2,7,1], adding 1 * 4 = 4 to the score.\n- Choose from the end, [-2,7], adding 7 * 6 = 42 to the score. \nThe total score is 50 + 15 - 9 + 4 + 42 = 102.\n```\n\n### Constraints:\n\n- n == nums.length\n- m == multipliers.length\n- 1 <= m <= 300\n- m <= n <= 105\n- -1000 <= nums[i], multipliers[i] <= 1000","basename":"maximum-score-from-performing-multiplication-operations"},"maximum-subarray":{"title":"Maximum Subarray","description":"Given an integer array nums, find the subarray with the largest sum, and return its sum.","tags":["medium","dp","greedy","neetcode"],"link":"https://leetcode.com/problems/maximum-subarray/","images":[],"preview":"### Description\n\nGiven an integer array `nums`, find the subarray with the largest sum, and return its sum.\n\n### Example 1\n\n```bash\nInput: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\n```\n\n### Example 2\n\n```bash\nInput: nums = [1]\nOutput: 1\nExplanation: The subarray [1] has the largest sum 1.\n```\n\n### Example 3\n\n```bash\nInput: nums = [5,4,-1,7,8]\nOutput: 23\nExplanation: The subarray [5,4,-1,7,8] has the largest sum 23.\n```\n\n### Constraints:\n\n- 1  <= nums.length <= 105\n- -104 <= nums[i] <= 104","basename":"maximum-subarray"},"maximum-sum-submatrix":{"title":"Maximum Sum Submatrix","tags":["hard","algoexpert"],"preview":"# Maximum Sum Submatrix\n\nYou're given a two-dimensional array (a matrix) of potentially unequal height and width that's filled with integers. You're also given a positive integer size. Write a function that returns the maximum sum that can be generated from a submatrix with dimensions size * size.\n\nFor example, consider the following matrix:\n\n```\n[\n  [2, 4],\n  [5, 6],\n  [-3, 2],\n]\n```\n\nIf size = 2, then the 2x2 submatrices to consider are:\n\n```\n[2, 4]\n[5, 6]\n------\n[5, 6]\n[-3, 2]\n```\n\nThe sum of the elements in the first submatrix is 17, and the sum of the elements in the second submatrix is 10. In this example, your function should return 17.\n\nNote: size will always be at least 1, and the dimensions of the input matrix will always be at least size * size.\n\n## Sample Input\n\n```\nmatrix = \n[\n  [5, 3, -1, 5],\n  [-7, 3, 7, 4],\n  [12, 8, 0, 0],\n  [1, -8, -8, 2],\n]\nsize = 2\n```\n\n## Sample Output\n\n```\n18\n// [\n//   [., ., ., .],\n//   [., 3, 7, .],\n//   [., 8, 0, .],\n//   [., ., ., .],\n// ]\n```\n\n### Hints\n\nHint 1\n> The brute-force approach to solve this problem involves simply considering all possible submatrices of size size * size, determining their sums, and finally returning the maximum sum. This approach is acceptable, but it isn't optimal. Why isn't it optimal?\n\nHint 2\n> The approach stated in Hint #1 isn't optimal because it repeats some additions. When considering submatrices of any size larger than 1, it's almost always the case that some these matrices will have overlapping elements, meaning that we'll repeatedly add up the same numbers. If we were to use the brute-force approach, we would get a time complexity of O(width * height * size). To achieve a more optimal time complexity, we need to avoid readding elements that have already been added. Can you think of a way to solve this problem in O(width * height) time?\n\nHint 3\n> To avoid doing repeated addition, we have to use auxiliary space. Ideally, this extra space will allow us to determine the sum of a submatrix of any size in constant time. Start by creating a matrix with the same dimensions as the input matrix (we call this matrix sums). The element at position i, j (where i is the row and j is the column) in this new matrix should be the sum of all the elements in the submatrix whose top left corner is at 0, 0 and whose bottom right corner is at i, j. How can you quickly fill up this new matrix, and how can you then use it to determine the sum of a submatrix of any size in constant time?\n\nHint 4\n> The sum of a matrix whose bottom right corner is at i, j (where size <= i <= j) is simply sums[i][j] - sums[i - size][j] - sums[i][j - size] + sums[i - size][j - size]. See the Conceptual Overview section of this question's video explanation for a more in-depth explanation.\n\n```\nOptimal Space & Time Complexity\nO(w * h) time | O(w * h) space - where w is the width of the matrix and h is the height\n```","basename":"maximum-sum-submatrix"},"maximum-value-of-k-coins-from-piles":{"title":"Maximum Value of K Coins From Piles","description":"In one move, you can choose any coin on top of any pile, remove it, and add it to your wallet.","tags":["hard","dp","general-1d"],"link":"https://leetcode.com/problems/maximum-value-of-k-coins-from-piles","images":[],"preview":"### Description\n\nThere are n piles of coins on a table. Each pile consists of a positive number of coins of assorted denominations.\n\nIn one move, you can choose any coin on top of any pile, remove it, and add it to your wallet.\n\nGiven a list piles, where piles[i] is a list of integers denoting the composition of the ith pile from top to bottom, and a positive integer k, return the maximum total value of coins you can have in your wallet if you choose exactly k coins optimally.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2019/11/09/e1.png)\n\n```bash\nInput: piles = [[1,100,3],[7,8,9]], k = 2\nOutput: 101\nExplanation:\nThe above diagram shows the different ways we can choose k coins.\nThe maximum total we can obtain is 101.\n```\n\n### Example 2\n\n```bash\nInput: piles = [[100],[100],[100],[100],[100],[100],[1,1,1,1,1,1,700]], k = 7\nOutput: 706\nExplanation:\nThe maximum total can be obtained if we choose all coins from the last pile.\n```\n\n### Constraints:\n\n- n == piles.length\n- 1 <= n <= 1000\n- 1 <= piles[i][j] <= 105\n- 1 <= k <= sum(piles[i].length) <= 2000","basename":"maximum-value-of-k-coins-from-piles"},"median-of-two-sorted-arrays":{"title":"Median of Two Sorted Arrays","description":"Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).","tags":["hard","binary-search"],"link":"https://leetcode.com/problems/median-of-two-sorted-arrays/?envType=study-plan-v2&envId=top-interview-150","images":[],"preview":"### Description\n\nGiven two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\n\nThe overall run time complexity should be O(log (m+n)).\n\n### Example 1\n\n```bash\nInput: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.\n```\n\n### Example 2\n\n```bash\nInput: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n```\n\n### Constraints:\n\n- nums1.length == m\n- nums2.length == n\n- 0 <= m <= 1000\n- 0 <= n <= 1000\n- 1 <= m + n <= 2000\n- -106 <= nums1[i], nums2[i] <= 106","basename":"median-of-two-sorted-arrays"},"median-sorted-arrays":{"title":"Median of Two Sorted Arrays","description":"Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.","tags":["neetcode","hard","binary-search"],"link":"https://leetcode.com/problems/median-of-two-sorted-arrays/","preview":"### Description\n\nGiven two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively, return **the median** of the two sorted arrays.\n\nThe overall run time complexity should be `O(log (m+n))`.\n\n### Example 1\n\n```bash\nInput: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.\n```\n\n### Example 2\n\n```bash\nInput: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n```\n\n### Constraints:\n\n-      nums1.length == m     \n-      nums2.length == n     \n-      0 <= m <= 1000     \n-      0 <= n <= 1000     \n-      1 <= m + n <= 2000     \n-      -106 <= nums1[i], nums2[i] <= 106","basename":"median-sorted-arrays"},"meeting-rooms-ii":{"title":"Meeting Rooms II","description":"Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],] (si < ei), find the minimum number of conference rooms required.","tags":["neetcode","medium","intervals"],"link":"https://cheonhyangzhang.gitbooks.io/leetcode-solutions/content/253-meeting-rooms-ii---medium.html","images":[],"preview":"### Description\n\nGiven an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],] (si < ei), find the minimum number of conference rooms required.\n\n\n### Example 1\n\n```bash\nInput: [[0, 30],[5, 10],[15, 20]]\nOutput: 2\n```\n\n### Example 2\n\n```bash\nInput:\n [[7,10],[2,4]]\n\nOutput:\n 1\n ```","basename":"meeting-rooms-ii"},"meeting-rooms":{"title":"Meeting Rooms","description":"Given an array of meeting time intervals consisting of start and end times[[s1,e1],[s2,e2],...](si< ei), determine if a person could attend all meetings.","tags":["neetcode","easy","intervals"],"link":"https://leetcode.com/problems/meeting-rooms/","images":[],"preview":"### Description\n\nGiven an array of meeting time intervals consisting of start and end times `[[s1,e1],[s2,e2],...]` (si< ei), determine if a person could attend all meetings.\n\n### Example 1\n\n```bash\nInput:\n[[0,30],[5,10],[15,20]]\nOutput:\n false\n```\n\n### Example 2\n\n```bash\nInput:\n [[7,10],[2,4]]\n\nOutput:\n true\n```","basename":"meeting-rooms"},"merge-intervals":{"title":"Merge Intervals","description":"Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.","tags":["medium","intervals"],"link":"https://leetcode.com/problems/merge-intervals/","images":[],"preview":"### Description\n\nGiven an arrray of `intervals` where `intervals[i] = [starti, endi]`, merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.\n\n### Example 1\n\n```bash\nInput: intervals = [[1,3],[2,6],[8,10],[15,18]]\nOutput: [[1,6],[8,10],[15,18]]\nExplanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].\n```\n\n### Example 2\n\n```bash\nInput: intervals = [[1,4],[4,5]]\nOutput: [[1,5]]\nExplanation: Intervals [1,4] and [4,5] are considered overlapping.\n```\n\n### Constraints:\n\n- 1 <= intervals.length <= 104\n- intervals[i].length == 2\n- 0 <= starti <= endi <= 104","basename":"merge-intervals"},"merge-k-sorted-list":{"title":"Merge k Sorted Lists","description":"You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.","tags":["neetcode","hard","linked-list"],"link":"https://leetcode.com/problems/merge-k-sorted-lists/","preview":"### Description\n\nYou are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\n\nMerge all the linked-lists into one sorted linked-list and return it.\n\n \n\n### Example 1\n\n```bash\nInput: lists = [[1,4,5],[1,3,4],[2,6]]\nOutput: [1,1,2,3,4,4,5,6]\nExplanation: The linked-lists are:\n[\n  1->4->5,\n  1->3->4,\n  2->6\n]\nmerging them into one sorted list:\n1->1->2->3->4->4->5->6\n```\n\n### Example 2\n\n```bash\n\n```\n\n### Example 3\n\n```bash\nInput: lists = [[]]\nOutput: []\n```\n\n### Constraints:\n\n- k == lists.length \n- 0 <= k <= 10^4 \n- 0 <= lists[i].length <= 500 \n- -10^4 <= lists[i][j] <= 10^4 \n- lists[i] is sorted in **ascending order**. \n- The sum of lists[i].length will not exceed 10^4.","basename":"merge-k-sorted-list"},"merge-linked-lists":{"title":"Merged Linked Lists","tags":["hard","algoexpert"],"preview":"# Merge Linked Lists\n\nWrite a function that takes in the heads of two Singly Linked Lists that are in sorted order, respectively. The function should merge the lists in place (i.e., it shouldn't create a brand new list) and return the head of the merged list; the merged list should be in sorted order.\n\nEach LinkedList node has an integer value as well as a next node pointing to the next node in the list or to None / null if it's the tail of the list.\n\nYou can assume that the input linked lists will always have at least one node; in other words, the heads will never be None / null.\n\n## Sample Input\n```\nheadOne = 2 -> 6 -> 7 -> 8 // the head node with value 2\nheadTwo = 1 -> 3 -> 4 -> 5 -> 9 -> 10 // the head node with value 1\n```\n\n## Sample Output\n\n```\n1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> 10 // the new head node with value 1\n```\n\n### Hints\n\n```\nHint 1\nYou can iterate through the Linked Lists from head to tail and merge them along the way by inserting nodes from the second Linked List into the first Linked List.\n```\n\n```\nHint 2\nYou'll need to manipulate three nodes at once at every step.\n```\n\n```\nHint 3\nAt every step, you'll need to have three variables (p1, p2, and p1Prev) pointing to the current node in the first Linked List (p1), the current node in the second Linked List (p2), and the previous node in the first Linked List (p1Prev). If the value of p1 is smaller than the value of p2, then you can just \"move forward\" in the first Linked List by moving p1 and p1Prev forward by one position (p1Prev becomes p1 and p1 becomes p1.next). If the value of p1 is greater than the value of p2, then you need to insert p2 before p1. You'll have to first make p1Prev point to p2, then make p2 point to p1, all the while not losing track of p2's \"next\" node, which you'll need to move to right after. You'll also have to handle edge cases when you're dealing with head nodes or tail nodes.\n```\n\n```\nHint 4\nYou can implement this algorithm both iteratively and recursively following nearly identical logic.\n```\n\n```\nOptimal Space & Time Complexity\nO(n + m) time | O(1) space - where n is the number of nodes in the first Linked List and m is the number of nodes in the second Linked List\n```","basename":"merge-linked-lists"},"merge-triplets-to-form-target-triplet":{"title":"Merge Triplets to Form Target Triplet","description":"Return true if it is possible to obtain the target triplet [x, y, z] as an element of triplets, or false otherwise.","tags":["medium","greedy","neetcode"],"link":"https://leetcode.com/problems/merge-triplets-to-form-target-triplet/","images":[],"preview":"### Description\n\nA triplet is an array of three integers. You are given a 2D integer array triplets, where triplets[i] = [ai, bi, ci] describes the ith triplet. You are also given an integer array target = [x, y, z] that describes the triplet you want to obtain.\n\nTo obtain target, you may apply the following operation on triplets any number of times (possibly zero):\n\n- Choose two indices **(0-indexed)** `i` and `j (i != j)` and **update** triplets[j] to become `[max(ai, aj), max(bi, bj), max(ci, cj)]`.\n    - For example, if triplets[i] = [2, 5, 3] and `triplets[j] = [1, 7, 5]`, triplets[j] will be updated to `[max(2, 1), max(5, 7), max(3, 5)] = [2, 7, 5]`.\n\nReturn `true` if it is possible to obtain the `target` **triplet** `[x, y, z]` as an **element** of `triplets`, or `false` otherwise.\n\n### Example 1\n\n```bash\nInput: triplets = [[2,5,3],[1,8,4],[1,7,5]], target = [2,7,5]\nOutput: true\nExplanation: Perform the following operations:\n- Choose the first and last triplets [[2,5,3],[1,8,4],[1,7,5]]. Update the last triplet to be [max(2,1), max(5,7), max(3,5)] = [2,7,5]. triplets = [[2,5,3],[1,8,4],[2,7,5]]\nThe target triplet [2,7,5] is now an element of triplets.\n```\n\n### Example 2\n\n```bash\nInput: triplets = [[3,4,5],[4,5,6]], target = [3,2,5]\nOutput: false\nExplanation: It is impossible to have [3,2,5] as an element because there is no 2 in any of the triplets.\n```\n\n### Example 3\n\n```bash\nInput: triplets = [[2,5,3],[2,3,4],[1,2,5],[5,2,3]], target = [5,5,5]\nOutput: true\nExplanation: Perform the following operations:\n- Choose the first and third triplets [[2,5,3],[2,3,4],[1,2,5],[5,2,3]]. Update the third triplet to be [max(2,1), max(5,2), max(3,5)] = [2,5,5]. triplets = [[2,5,3],[2,3,4],[2,5,5],[5,2,3]].\n- Choose the third and fourth triplets [[2,5,3],[2,3,4],[2,5,5],[5,2,3]]. Update the fourth triplet to be [max(2,5), max(5,2), max(5,3)] = [5,5,5]. triplets = [[2,5,3],[2,3,4],[2,5,5],[5,5,5]].\nThe target triplet [5,5,5] is now an element of triplets.\n```\n\n\n### Constraints:\n\n- 1 <= triplets.length <= 105\n- triplets[i].length == target.length == 3\n- 1 <= ai, bi, ci, x, y, z <= 1000","basename":"merge-triplets-to-form-target-triplet"},"merge-two-sorted-list":{"title":"Merge Two Sorted Lists","description":"You are given the heads of two sorted linked lists list1 and list2. Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.","tags":["neetcode","easy","linked-list"],"link":"https://leetcode.com/problems/merge-two-sorted-lists/","images":["https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg"],"preview":"### Description\n\nYou are given the heads of two sorted linked lists list1 and list2.\n\nMerge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.\n\nReturn the head of the merged linked list.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg)\n\n```bash\nInput: list1 = [1,2,4], list2 = [1,3,4]\nOutput: [1,1,2,3,4,4]\n```\n\n### Example 2\n\n```bash\nInput: list1 = [], list2 = []\nOutput: []\n```\n\n### Example 3\n\n```bash\nInput: list1 = [], list2 = [0]\nOutput: [0]\n```\n\n### Constraints:\n\n- The number of nodes in both lists is in the range [0, 50]. \n- -100 <= Node.val <= 100 \n- Both list1 and list2 are sorted in non-decreasing order.","basename":"merge-two-sorted-list"},"min-code.md":{"title":"Time Based Key-value Store","description":"Design a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the key's value at a certain timestamp.","tags":["neetcode","medium","binary-search"],"link":"https://leetcode.com/problems/time-based-key-value-store/","preview":"### Description\n\nDesign a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the key's value at a certain timestamp.\n\nImplement the TimeMap class:\n\n- `TimeMap()` Initializes the object of the data structure\n- `void set(String key, String value, int timestamp)` Stores the key `key` with the value `value` at the given time timestamp.\n- `String get(String key, int timestamp)` Returns a value such that set was called previously, with `timestamp_prev <= timestamp`. If there are multiple such values, it returns the value associated with the largest `timestamp_prev`. If there are no values, it returns `\"\"`.\n\n\n### Example 1\n\n```bash\nInput\n[\"TimeMap\", \"set\", \"get\", \"get\", \"set\", \"get\", \"get\"]\n[[], [\"foo\", \"bar\", 1], [\"foo\", 1], [\"foo\", 3], [\"foo\", \"bar2\", 4], [\"foo\", 4], [\"foo\", 5]]\nOutput\n[null, null, \"bar\", \"bar\", null, \"bar2\", \"bar2\"]\n\nExplanation\nTimeMap timeMap = new TimeMap();\ntimeMap.set(\"foo\", \"bar\", 1);  // store the key \"foo\" and value \"bar\" along with timestamp = 1.\ntimeMap.get(\"foo\", 1);         // return \"bar\"\ntimeMap.get(\"foo\", 3);         // return \"bar\", since there is no value corresponding to foo at timestamp 3 and timestamp 2, then the only value is at timestamp 1 is \"bar\".\ntimeMap.set(\"foo\", \"bar2\", 4); // store the key \"foo\" and value \"bar2\" along with timestamp = 4.\ntimeMap.get(\"foo\", 4);         // return \"bar2\"\ntimeMap.get(\"foo\", 5);         // return \"bar2\"\n```\n\n\n### Constraints:\n\n-      1 <= key.length, value.length <= 100     \n-      key and value consist of lowercase English letters and digits.     \n-      1 <= timestamp <= 107     \n-      All the timestamps timestamp of set are strictly increasing.     \n-      At most 2 * 105 calls will be made to set and get.","basename":"min-code.md"},"min-cost-climbing-stairs":{"title":"Min Cost Climbing Stairs","description":"You are given an integer array cost where cost[i] is the cost of ith step on a staircase. Once you pay the cost, you can either climb one or two steps.  You can either start from the step with index 0, or the step with index 1.  Return the minimum cost to reach the top of the floor.","tags":["easy","dp","neetcode"],"link":"https://leetcode.com/problems/min-cost-climbing-stairs/","images":[],"preview":"### Description\n\nYou are given an integer array `cost` where `cost[i] `is the cost of ith step on a staircase. Once you pay the cost, you can either climb one or two steps.\n\nYou can either start from the step with index `0`, or the step with index `1`.\n\nReturn the minimum cost to reach the top of the floor.\n\n### Example 1\n\n```bash\nInput: cost = [10,15,20]\nOutput: 15\nExplanation: You will start at index 1.\n- Pay 15 and climb two steps to reach the top.\nThe total cost is 15.\n```\n\n### Example 2\n\n```bash\nInput: cost = [1,100,1,1,1,100,1,1,100,1]\nOutput: 6\nExplanation: You will start at index 0.\n- Pay 1 and climb two steps to reach index 2.\n- Pay 1 and climb two steps to reach index 4.\n- Pay 1 and climb two steps to reach index 6.\n- Pay 1 and climb one step to reach index 7.\n- Pay 1 and climb two steps to reach index 9.\n- Pay 1 and climb one step to reach the top.\nThe total cost is 6.\n```\n\n### Constraints:\n\n-     2 <= cost.length <= 1000\n-     0 <= cost[i] <= 999","basename":"min-cost-climbing-stairs"},"min-cost-to-connect-all-points":{"title":"Min Cost To Connect All Points","description":"Return the minimum cost to make all points connected. All points are connected if there is exactly one simple path between any two points","tags":["medium","graph","minimum-spanning-tree"],"link":"https://leetcode.com/problems/min-cost-to-connect-all-points","images":[],"preview":"### Description\n\nYou are given an array points representing integer coordinates of some points on a 2D-plane, where points[i] = [xi, yi].\n\nThe cost of connecting two points [xi, yi] and [xj, yj] is the manhattan distance between them: |xi - xj| + |yi - yj|, where |val| denotes the absolute value of val.\n\nReturn the minimum cost to make all points connected. All points are connected if there is exactly one simple path between any two points.\n\n \n\n### Example 1\n\n```bash\nInput: points = [[0,0],[2,2],[3,10],[5,2],[7,0]]\nOutput: 20\nExplanation: \n```\n![](https://assets.leetcode.com/uploads/2020/08/26/c.png)\n\nWe can connect the points as shown above to get the minimum cost of 20.\nNotice that there is a unique path between every pair of points.\n\n### Example 2\n\n\n```bash\nInput: points = [[3,12],[-2,5],[-4,1]]\nOutput: 18\n```\n\n### Constraints:\n\n- 1 <= points.length <= 1000\n- -106 <= xi, yi <= 106\n- All pairs (xi, yi) are distinct.","basename":"min-cost-to-connect-all-points"},"min-max-prunning":{"title":"Min Max Prunning","description":"Create Adversarial Search Prunning Problem","tags":["ai","medium","search"],"images":[],"preview":"### Description\n\nCreate Adversarial Search Prunning Problem\n\n### Example 1\n\n![](https://media.geeksforgeeks.org/wp-content/uploads/MIN_MAX3.jpg)\n\n```js\n\nlet values = [3, 5, 6, 9, 1, 2, 0, -1];\nlet result = problem.solve(values);\nconsole.log(\"MinMaxPrunnin with:\", values, result);\n```\n\nShould equals to:\n\n```js\nassert.equal(result.minmax, 5);\nassert.deepEqual(result.prunnings, [6, 2]);\n```\n\n- Prunnings being the nodes in which trigger prunnings.\n\n### Example 2\n\n```js\nlet values = [4, 8, 9, 3, 2, -2, 2, -1];\nconst problem = new this.Problem\n```\n\n```js\nassert.equal(result.minmax, 8);\nassert.deepEqual(result.prunnings, [9, 2]);\n```\n\n### Constraints:\n\n- By default the player is a maximizer.\n- Numebers on the leafts being x; abs(x) < 1000","basename":"min-max-prunning"},"min-number-of-jumps":{"title":"Min Number of Jumps","description":"Given an array of integers nums where each element represents the max number of steps that can be made forward from that element, return the minimum number of jumps to reach the last index.","tags":["hard","algoexpert"],"link":null,"images":[],"preview":"# Min Number Of Jumps\n\nYou're given a non-empty array of positive integers where each integer represents the maximum number of steps you can take forward in the array. For example, if the element at index 1 is 3, you can go from index 1 to index 2, 3, or 4.\n\nWrite a function that returns the minimum number of jumps needed to reach the final index.\n\nNote that jumping from index i to index i + x always constitutes one jump, no matter how large x is.\n\n## Sample Input\n\n```\narray = [3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3]\n```\n\n## Sample Output\n\n```\n4 // 3 --> (4 or 2) --> (2 or 3) --> 7 --> 3\n```\n\n### Hints\n\nHint 1\n> Try building an array of the minimum number of jumps needed to go from index 0 to all indices. Start at index 0 and progressively build up the array, using previously calculated values to find next ones.\n\nHint 2\n> Building the array mentioned in Hint #1 should be feasible using two for loops. In an effort to optimize your algorithm, realize that at any point in the array you know the farthest index that you can reach as well as the number of steps that you have left until you must \"consume\" a jump.\n\nHint 3\n> After initializing your maximum reach as well as your current number of steps to the value stored at index 0, you can easily update your maximum reach as you traverse the input array by simply comparing it to the value stored at each index. You can also remove one step from your current number of steps at each index, since moving from one index to the next uses up one step. When your steps reach zero, find a way to calculate how many steps you actually have left using the maximum reach and the index that you're at.\n\n```\nOptimal Space & Time Complexity\nO(n) time | O(1) space - where n is the length of the input array\n```","basename":"min-number-of-jumps"},"min-rewards":{"title":"Min Rewards","description":"Min Rewards","tags":["hard","algoexpert"],"preview":"# Min Rewards\n\nImagine that you're a teacher who's just graded the final exam in a class. You have a list of student scores on the final exam in a particular order (not necessarily sorted), and you want to reward your students. You decide to do so fairly by giving them arbitrary rewards following two rules:\n\n   - All students must receive at least one reward.\n   - Any given student must receive strictly more rewards than an adjacent student (a student immediately to the left or to the right) with a lower score and must receive strictly fewer rewards than an adjacent student with a higher score.\n\nWrite a function that takes in a list of scores and returns the minimum number of rewards that you must give out to students to satisfy the two rules.\n\nYou can assume that all students have different scores; in other words, the scores are all unique.\n\n## Sample Input\n\n```\nscores = [8, 4, 2, 1, 3, 6, 7, 9, 5]\n```\n\n## Sample Output\n\n```\n25 // you would give out the following rewards: [4, 3, 2, 1, 2, 3, 4, 5, 1]\n```\n\n### Hints\n\nHint 1\n> You could try iterating through the input list of scores and incrementing the number of rewards you give to each student if they have a greater score than the previous student's score. However, if you reach a student with a smaller score than the previous student's score, you'll have to backtrack through the array to fix previous reward assignments. During this backtrack, is it correct to simply increment the reward of a student whose score is greater than the next student's score?\n\nHint 2\n> Notice that there are local mins and local maxes in the input list of scores: scores that are smaller than both scores next to them and scores that are greater than both scores next to them. Find the local mins, and try expanding away from them until you reach local maxes, assigning (and incrementing) rewards as you go.\n\nHint 3\n> Do you actually need to find the local mins mentioned in Hint #2? Can you simply do two sweeps of the input list of scores, one from left to right, and one from right to left?\n\n```\nOptimal Space & Time Complexity\nO(n) time | O(n) space - where n is the length of the input array\n```","basename":"min-rewards"},"min-stack":{"title":"Min Stack","description":"Min Stack","tags":["neetcode","medium","stack"],"link":"https://leetcode.com/problems/min-stack/","preview":"### Description\n\nDesign a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n\nImplement the MinStack class:\n\n    MinStack() initializes the stack object.\n    void push(int val) pushes the element val onto the stack.\n    void pop() removes the element on the top of the stack.\n    int top() gets the top element of the stack.\n    int getMin() retrieves the minimum element in the stack.\n\nYou must implement a solution with O(1) time complexity for each function.\n\n### Example 1\n```bash\nInput\n[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"]\n[[],[-2],[0],[-3],[],[],[],[]]\n\nOutput\n[null,null,null,null,-3,null,0,-2]\n\nExplanation\nMinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.getMin(); // return -3\nminStack.pop();\nminStack.top();    // return 0\nminStack.getMin(); // return -2\n```\n\n### Constraints:\n\n- -2^31 <= val <= 2^31 - 1     \n- Methods pop, top and getMin operations will always be called on non-empty stacks.     \n- At most 3 * 104 calls will be made to push, pop, top, and getMin.","basename":"min-stack"},"min-window":{"title":"Min Window Substring","description":"Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \"\".","tags":["neetcode","hard","sliding-window"],"link":"https://leetcode.com/problems/minimum-window-substring/","preview":"### Description\n\nGiven two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \"\".\n\n### Example 1\n```bash\nInput: s = \"ADOBECODEBANC\", t = \"ABC\"\nOutput: \"BANC\"\nExplanation: The minimum window substring \"BANC\" includes 'A', 'B', and 'C' from string t.\n```\n\n### Example 2\n```bash\nInput: s = \"a\", t = \"a\"\nOutput: \"a\"\nExplanation: The entire string s is the minimum window.\n```\n\n### Example 3\n```bash\nInput: s = \"a\", t = \"aa\"\nOutput: \"\"\nExplanation: Both 'a's from t must be included in the window.\nSince the largest window of s only has one 'a', return empty string.\n```\n\n### Constraints:\n\n-      m == s.length     \n-      n == t.length     \n-      1 <= m, n <= 105     \n-      s and t consist of uppercase and lowercase English letters.","basename":"min-window"},"minimum-absolute-difference-in-bst":{"title":"Minimum Absolute Difference in Bst","description":"Given the root of a Binary Search Tree (BST), return the minimum absolute difference between the values of any two different nodes in the tree.","tags":["easy","binary-tree"],"link":null,"images":[],"preview":"### Description\n\nGiven the root of a Binary Search Tree (BST), return the minimum absolute difference between the values of any two different nodes in the tree.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2021/02/05/bst1.jpg)\n\n\n```bash\nInput: root = [4,2,6,1,3]\nOutput: 1\n```\n\n### Example 2\n\n![](https://assets.leetcode.com/uploads/2021/02/05/bst2.jpg)\n\n```bash\nInput: root = [1,0,48,null,null,12,49]\nOutput: 1\n```\n\n### Constraints:\n\n- The number of nodes in the tree is in the range [2, 104].\n- 0 <= Node.val <= 105","basename":"minimum-absolute-difference-in-bst"},"minimum-cost-for-tickets":{"title":"Minimum Cost for Tickets","description":"The passes allow that many days of consecutive travel.","tags":["medium","dp","general-1d"],"link":"https://leetcode.com/problems/minimum-cost-for-tickets/","images":[],"preview":"### Description\n\nYou have planned some train traveling one year in advance. The days of the year in which you will travel are given as an integer array days. Each day is an integer from 1 to 365.\n\nTrain tickets are sold in three different ways:\n\n- a 1-day pass is sold for costs[0] dollars,\n- a 7-day pass is sold for costs[1] dollars, and\n- a 30-day pass is sold for costs[2] dollars.\n\nThe passes allow that many days of consecutive travel.\n\n- For example, if we get a 7-day pass on day 2, then we can travel for 7 days: 2, 3, 4, 5, 6, 7, and 8.\n\nReturn the minimum number of dollars you need to travel every day in the given list of days.\n\n \n\n### Example 1\n\n```bash\nInput: days = [1,4,6,7,8,20], costs = [2,7,15]\nOutput: 11\nExplanation: For example, here is one way to buy passes that lets you travel your travel plan:\nOn day 1, you bought a 1-day pass for costs[0] = $2, which covered day 1.\nOn day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9.\nOn day 20, you bought a 1-day pass for costs[0] = $2, which covered day 20.\nIn total, you spent $11 and covered all the days of your travel.\n```\n\n### Example 2\n\n```bash\nInput: days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15]\nOutput: 17\nExplanation: For example, here is one way to buy passes that lets you travel your travel plan:\nOn day 1, you bought a 30-day pass for costs[2] = $15 which covered days 1, 2, ..., 30.\nOn day 31, you bought a 1-day pass for costs[0] = $2 which covered day 31.\nIn total, you spent $17 and covered all the days of your travel.\n```\n\n### Constraints:\n\n- 1 <= days.length <= 365\n- 1 <= days[i] <= 365\n- days is in strictly increasing order.\n- costs.length == 3\n- 1 <= costs[i] <= 1000","basename":"minimum-cost-for-tickets"},"minimum-cost-to-cut-a-stick":{"title":"Minimum Cost to Cut a Stick","description":"You should perform the cuts in order, you can change the order of the cuts as you wish.","tags":["hard","grand-dp","general-multi-d"],"link":"https://leetcode.com/problems/minimum-cost-to-cut-a-stick","images":[],"preview":"### Description\n\nGiven a wooden stick of length n units. The stick is labelled from 0 to n. For example, a stick of length 6 is labelled as follows:\n\n![](https://assets.leetcode.com/uploads/2020/07/21/statement.jpg)\n\nGiven an integer array cuts where cuts[i] denotes a position you should perform a cut at.\n\nYou should perform the cuts in order, you can change the order of the cuts as you wish.\n\nThe cost of one cut is the length of the stick to be cut, the total cost is the sum of costs of all cuts. When you cut a stick, it will be split into two smaller sticks (i.e. the sum of their lengths is the length of the stick before the cut). Please refer to the first example for a better explanation.\n\nReturn the minimum total cost of the cuts.\n\n \n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2020/07/23/e1.jpg)\n\n![](https://assets.leetcode.com/uploads/2020/07/21/e11.jpg)\n\n\n```bash\nInput: n = 7, cuts = [1,3,4,5]\nOutput: 16\nExplanation: Using cuts order = [1, 3, 4, 5] as in the input leads to the \n\n\n\nThe first cut is done to a rod of length 7 so the cost is 7. The second cut is done to a rod of length 6 (i.e. the second part of the first cut), the third is done to a rod of length 4 and the last cut is to a rod of length 3. The total cost is 7 + 6 + 4 + 3 = 20.\nRearranging the cuts to be [3, 5, 1, 4] for example will lead to a scenario with total cost = 16 (as shown in the example photo 7 + 4 + 3 + 2\n```\n\n### Example 2\n\n```bash\nInput: n = 9, cuts = [5,6,1,4,2]\nOutput: 22\nExplanation: If you try the given cuts ordering the cost will be 25.\nThere are much ordering with total cost <= 25, for example, the order [4, 6, 5, 2, 1] has total cost = 22 which is the minimum possible.\n```\n\n### Constraints:\n\n- 2 <= n <= 106\n- 1 <= cuts.length <= min(n - 1, 100)\n- 1 <= cuts[i] <= n - 1\n- All the integers in cuts array are distinct.","basename":"minimum-cost-to-cut-a-stick"},"minimum-difficulty-of-a-job-schedule":{"title":"Minimum Difficulty of a Job Schedule","description":"You are given an integer array jobDifficulty and an integer d. The difficulty of the ith job is jobDifficulty[i].","tags":["hard","grand-dp","general-multi-d"],"link":"https://leetcode.com/problems/minimum-difficulty-of-a-job-schedule/","images":[],"preview":"### Description\n\nYou want to schedule a list of jobs in d days. Jobs are dependent (i.e To work on the ith job, you have to finish all the jobs j where 0 <= j < i).\n\nYou have to finish at least one task every day. The difficulty of a job schedule is the sum of difficulties of each day of the d days. The difficulty of a day is the maximum difficulty of a job done on that day.\n\nYou are given an integer array jobDifficulty and an integer d. The difficulty of the ith job is jobDifficulty[i].\n\nReturn the minimum difficulty of a job schedule. If you cannot find a schedule for the jobs return -1.\n\n### Example 1\n\n```bash\nInput: jobDifficulty = [6,5,4,3,2,1], d = 2\nOutput: 7\nExplanation: First day you can finish the first 5 jobs, total difficulty = 6.\nSecond day you can finish the last job, total difficulty = 1.\nThe difficulty of the schedule = 6 + 1 = 7 \n```\n\n### Example 2\n\n```bash\nInput: jobDifficulty = [9,9,9], d = 4\nOutput: -1\nExplanation: If you finish a job per day you will still have a free day. you cannot find a schedule for the given jobs.\n```\n\n### Example 3\n\n```bash\nInput: jobDifficulty = [1,1,1], d = 3\nOutput: 3\nExplanation: The schedule is one job per day. total difficulty will be 3.\n```\n\n### Constraints:\n\n- 1 <= jobDifficulty.length <= 300\n- 0 <= jobDifficulty[i] <= 1000\n- 1 <= d <= 10","basename":"minimum-difficulty-of-a-job-schedule"},"minimum-genetic-mutation":{"title":"Minimum Genetic Mutation","description":"Given the two gene strings startGene and endGene and the gene bank bank, return the minimum number of mutations needed to mutate from startGene to endGene. If there is no such a mutation, return -1.","tags":["graph","medium","bfs"],"link":"https://leetcode.com/problems/minimum-genetic-mutation","images":[],"preview":"### Description\n\nA gene string can be represented by an 8-character long string, with choices from 'A', 'C', 'G', and 'T'.\n\nSuppose we need to investigate a mutation from a gene string startGene to a gene string endGene where one mutation is defined as one single character changed in the gene string.\n\nFor example, \"AACCGGTT\" --> \"AACCGGTA\" is one mutation.\nThere is also a gene bank bank that records all the valid gene mutations. A gene must be in bank to make it a valid gene string.\n\nGiven the two gene strings startGene and endGene and the gene bank bank, return the minimum number of mutations needed to mutate from startGene to endGene. If there is no such a mutation, return -1.\n\nNote that the starting point is assumed to be valid, so it might not be included in the bank.\n\n### Example 1\n\n```bash\nInput: startGene = \"AACCGGTT\", endGene = \"AACCGGTA\", bank = [\"AACCGGTA\"]\nOutput: 1\n```\n\n### Example 2\n\n```bash\nInput: startGene = \"AACCGGTT\", endGene = \"AAACGGTA\", bank = [\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"]\nOutput: 2\n```\n\n### Constraints:\n\n- 0 <= bank.length <= 10\n- startGene.length == endGene.length == bank[i].length == 8\n- startGene, endGene, and bank[i] consist of only the characters ['A', 'C', 'G', 'T'].","basename":"minimum-genetic-mutation"},"minimum-insertion-steps-to-make-a-string-palindrome":{"title":"Minimum Insertion Steps to Make a String Palindrome","description":"Given a string s. In one step you can insert any character at any index of the string.","tags":["hard","dp","longest-palindromic-subsequence"],"link":null,"images":[],"preview":"### Description\n\nGiven a string s. In one step you can insert any character at any index of the string.\n\nReturn the minimum number of steps to make s palindrome.\n\nA Palindrome String is one that reads the same backward as well as forward.\n\n### Example 1\n\n```bash\nInput: s = \"zzazz\"\nOutput: 0\nExplanation: The string \"zzazz\" is already palindrome we do not need any insertions.\n```\n\n### Example 2\n\n```bash\nInput: s = \"mbadm\"\nOutput: 2\nExplanation: String can be \"mbdadbm\" or \"mdbabdm\".\n```\n\n\n### Example 3\n\n```bash\nInput: s = \"leetcode\"\nOutput: 5\nExplanation: Inserting 5 characters the string becomes \"leetcodocteel\".\n```\n\n\n### Constraints:\n\n- 1 <= s.length <= 500\n- s consists of lowercase English letters.","basename":"minimum-insertion-steps-to-make-a-string-palindrome"},"minimum-number-of-arrows-to-burst-balloons":{"title":"Minimum Number of Arrows to Burst Balloons","description":"Given the array points, return the minimum number of arrows that must be shot to burst all balloons.","tags":["intervals","leetcode"],"link":"https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/","images":[],"preview":"### Description\n\nThere are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array points where points[i] = [xstart, xend] denotes a balloon whose horizontal diameter stretches between xstart and xend. You do not know the exact y-coordinates of the balloons.\n\nArrows can be shot up directly vertically (in the positive y-direction) from different points along the x-axis. A balloon with xstart and xend is burst by an arrow shot at x if xstart <= x <= xend. There is no limit to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.\n\nGiven the array points, return the minimum number of arrows that must be shot to burst all balloons.\n\n### Example 1\n\n```bash\nInput: points = [[10,16],[2,8],[1,6],[7,12]]\nOutput: 2\nExplanation: The balloons can be burst by 2 arrows:\n- Shoot an arrow at x = 6, bursting the balloons [2,8] and [1,6].\n- Shoot an arrow at x = 11, bursting the balloons [10,16] and [7,12].\n```\n\n### Example 2\n\n```bash\nInput: points = [[1,2],[3,4],[5,6],[7,8]]\nOutput: 4\nExplanation: One arrow needs to be shot for each balloon for a total of 4 arrows.\n```\n\n### Example 3\n\n```bash\nInput: points = [[1,2],[2,3],[3,4],[4,5]]\nOutput: 2\nExplanation: The balloons can be burst by 2 arrows:\n- Shoot an arrow at x = 2, bursting the balloons [1,2] and [2,3].\n- Shoot an arrow at x = 4, bursting the balloons [3,4] and [4,5].\n```\n\n### Constraints:\n\n- 1 <= points.length <= 105\n- points[i].length == 2\n- -231 <= xstart < xend <= 231 - 1","basename":"minimum-number-of-arrows-to-burst-balloons"},"minimum-number-of-k-consecutive-bit-flips":{"title":"Minimum Number of K Consecutive Bit Flips","description":"A subarray is a contiguous part of an array.","tags":["hard"],"link":"https://leetcode.com/problems/minimum-number-of-k-consecutive-bit-flips/description/","images":[],"preview":"### Description\n\nYou are given a binary array nums and an integer k.\n\nA k-bit flip is choosing a subarray of length k from nums and simultaneously changing every 0 in the subarray to 1, and every 1 in the subarray to 0.\n\nReturn the minimum number of k-bit flips required so that there is no 0 in the array. If it is not possible, return -1.\n\nA subarray is a contiguous part of an array.\n\n### Example 1\n\n```bash\nInput: nums = [0,1,0], k = 1\nOutput: 2\nExplanation: Flip nums[0], then flip nums[2].\n```\n\n### Example 2\n\n```bash\nInput: nums = [1,1,0], k = 2\nOutput: -1\nExplanation: No matter how we flip subarrays of size 2, we cannot make the array become [1,1,1].\n```\n\n\n### Example 3\n\n```bash\nInput: nums = [0,0,0,1,0,1,1,0], k = 3\nOutput: 3\nExplanation: \nFlip nums[0],nums[1],nums[2]: nums becomes [1,1,1,1,0,1,1,0]\nFlip nums[4],nums[5],nums[6]: nums becomes [1,1,1,1,1,0,0,0]\nFlip nums[5],nums[6],nums[7]: nums becomes [1,1,1,1,1,1,1,1]\n```\n\n### Constraints:\n\n- 1 <= nums.length <= 105\n- 1 <= k <= nums.length","basename":"minimum-number-of-k-consecutive-bit-flips"},"minimum-number-of-vertices-to-reach-all-nodes":{"title":"Minimum Number of Vertices to Reach All Nodes","description":"Find the smallest set of vertices from which all nodes in the graph are reachable. It's guaranteed that a unique solution exists.","tags":["medium","graph","graph-theory"],"link":"https://leetcode.com/problems/minimum-number-of-vertices-to-reach-all-nodes","images":[],"preview":"### Description\n\nGiven a directed acyclic graph, with n vertices numbered from 0 to n-1, and an array edges where edges[i] = [fromi, toi] represents a directed edge from node fromi to node toi.\n\nFind the smallest set of vertices from which all nodes in the graph are reachable. It's guaranteed that a unique solution exists.\n\nNotice that you can return the vertices in any order.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2020/07/07/untitled22.png)\n\n```bash\nInput: n = 6, edges = [[0,1],[0,2],[2,5],[3,4],[4,2]]\nOutput: [0,3]\nExplanation: It's not possible to reach all the nodes from a single vertex. From 0 we can reach [0,1,2,5]. From 3 we can reach [3,4,2,5]. So we output [0,3].\n```\n\n### Example 2\n\n![](https://assets.leetcode.com/uploads/2020/07/07/untitled.png)\n\n```bash\nInput: n = 5, edges = [[0,1],[2,1],[3,1],[1,4],[2,4]]\nOutput: [0,2,3]\nExplanation: Notice that vertices 0, 3 and 2 are not reachable from any other node, so we must include them. Also any of these vertices can reach nodes 1 and 4.\n```\n\n### Constraints:\n\n- 2 <= n <= 10^5\n- 1 <= edges.length <= min(10^5, n * (n - 1) / 2)\n- edges[i].length == 2\n- 0 <= fromi, toi < n\n- All pairs (fromi, toi) are distinct.","basename":"minimum-number-of-vertices-to-reach-all-nodes"},"minimum-path-sum":{"title":"Minimum Path Sum","description":"Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.","tags":["multi-dimensional-dp","medium"],"link":"leetcode.com/problems/minimum-path-sum","images":[],"preview":"### Description\n\nGiven a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\n\nNote: You can only move either down or right at any point in time.\n\n \n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg)\n\n```bash\nInput: grid = [[1,3,1],[1,5,1],[4,2,1]]\nOutput: 7\nExplanation: Because the path 1  3  1  1  1 minimizes the sum.\n```\n\n### Example 2\n\n```bash\nInput: grid = [[1,2,3],[4,5,6]]\nOutput: 12\n```\n\n### Constraints:\n\n- m == grid.length\n- n == grid[i].length\n- 1 <= m, n <= 200\n- 0 <= grid[i][j] <= 200","basename":"minimum-path-sum"},"minimum-size-subarray-sum":{"title":"Minimum Size Subarray Sum","description":"Given an array of positive integers nums and a positive integer target, return the minimal length of a subarray whose sum is greater than or equal to target. If there is no such subarray, return 0 instead.","tags":["medium","binary-search"],"link":"https://leetcode.com/problems/minimum-size-subarray-sum/","images":[],"preview":"### Description\n\nGiven an array of positive integers nums and a positive integer target, return the minimal length of a subarray whose sum is greater than or equal to target. If there is no such subarray, return 0 instead.\n\n### Example 1\n\n```bash\nInput: target = 7, nums = [2,3,1,2,4,3]\nOutput: 2\nExplanation: The subarray [4,3] has the minimal length under the problem constraint.\n```\n\n### Example 2\n\n```bash\nInput: target = 4, nums = [1,4,4]\nOutput: 1\n```\n\n### Constraints:\n\n- 1 <= target <= 109\n- 1 <= nums.length <= 105\n- 1 <= nums[i] <= 104","basename":"minimum-size-subarray-sum"},"minimum-waiting-time":{"title":"Minimum Waiting Time","description":"We are given an array of positive integers. Each integer in the input array represents the duration of a query that needs to be executed. Only one query can be executed at a time, but the queries can be executed in any order. We are asked to write a function that is going to return the minimum amount of total waiting time for all the queries. We are allowed to mutate the input array.","tags":["easy","algoexpert"],"link":"https://github.com/pinglu85/algoExpert/blob/main/Easy/minimum-waiting-time.md","preview":"### Description\n\nUnderstanding the problem\n\nWe are given an array of positive integers. Each integer in the input array represents the duration of a query that needs to be executed. Only one query can be executed at a time, but the queries can be executed in any order. We are asked to write a function that is going to return the minimum amount of total waiting time for all the queries. We are allowed to mutate the input array.\n\nSuppose the input array is [1, 3, 2]. The first query can be executed immediately, therefore the waiting time of the first query is 0. The second query have to wait until the first one finishes before it can execute, so the waiting time of the second query is going to be 1 second, the duration of the first query. The third query has to wait for both the first query and the second query to finish executing before it can start. Since the second query takes 3 seconds to execute, the waiting time of the third query is going to be 1 + 3 seconds. So if the queries are executed in that order, then the total awaiting time for all of the queries is going to be (0) + (1) + (1 + 3) = 5.\n\n### Example 1\n\n```bash\n([3, 2, 1, 2, 6]) => 17\n```\n\n### Example 2\n\n```bash\n([2, 1, 1, 1]) => 6\n```\n\n```bash\n([1, 2, 4, 5, 2, 1]) => 23\n([1, 1, 1, 1, 1]) => 10\n```\n\n### Constraints:\n\n-","basename":"minimum-waiting-time"},"missing-number":{"title":"Missing Number","description":"Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.","tags":["easy","bit-manipulation"],"link":"https://leetcode.com/problems/missing-number/","images":[],"preview":"### Description\n\nGiven an array `nums` containing `n` distinct numbers in the range `[0, n]`, return the only number in the range that is missing from the array.\n\n### Example 1\n\n```bash\nInput: nums = [3,0,1]\nOutput: 2\nExplanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.\n```\n\n### Example 2\n\n```bash\nInput: nums = [0,1]\nOutput: 2\nExplanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.\n```\n\n### Example 3\n\n```bash\nInput: nums = [9,6,4,2,3,5,7,0,1]\nOutput: 8\nExplanation: n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums.\n```\n\n### Constraints:\n\n- n == nums.length\n- 1 <= n <= 104\n- 0 <= nums[i] <= n\n- All the numbers of nums are unique.","basename":"missing-number"},"most-profit-assigning-work":{"title":"Most Profit Assigning Work","description":"Return the maximum profit we can achieve after assigning the workers to the jobs.","tags":["medium"],"link":"https://leetcode.com/problems/most-profit-assigning-work","images":[],"preview":"### Description\n\nYou have n jobs and m workers. You are given three arrays: difficulty, profit, and worker where:\n\n- difficulty[i] and profit[i] are the difficulty and the profit of the ith job, and\nworker[j] is the ability of jth worker (i.e., the jth worker can only complete a job with difficulty at most worker[j]).\n\nEvery worker can be assigned at most one job, but one job can be completed multiple times.\n\nFor example, if three workers attempt the same job that pays $1, then the total profit will be $3. If a worker cannot complete any job, their profit is $0.\nReturn the maximum profit we can achieve after assigning the workers to the jobs.\n\n### Example 1\n\n```bash\nInput: difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7]\nOutput: 100\nExplanation: Workers are assigned jobs of difficulty [4,4,6,6] and they get a profit of [20,20,30,30] separately.\n```\n\n### Example 2\n\n```bash\nInput: difficulty = [85,47,57], profit = [24,66,99], worker = [40,25,25]\nOutput: 0\n```\n\n### Constraints:\n\n- n == difficulty.length\n- n == profit.length\n- m == worker.length\n- 1 <= n, m <= 104\n- 1 <= difficulty[i], profit[i], worker[i] <= 105","basename":"most-profit-assigning-work"},"multi-string-search":{"title":"Multi String Search","description":"Function that takes in a big string and an array of small strings, all of which are smaller in length than the big string. The function should return an array of booleans, where each boolean represents whether the small string at that index in the array of small strings is contained in the big string.","tags":["hard","algoexpert"],"link":null,"images":[],"preview":"# Multi String Search\n\nWrite a function that takes in a big string and an array of small strings, all of which are smaller in length than the big string. The function should return an array of booleans, where each boolean represents whether the small string at that index in the array of small strings is contained in the big string.\n\nNote that you can't use language-built-in string-matching methods.\n\n## Sample Input #1\n\n```\nbigString = \"this is a big string\"\nsmallStrings = [\"this\", \"yo\", \"is\", \"a\", \"bigger\", \"string\", \"kappa\"]\n```\n\n## Sample Output #1\n\n```\n[true, false, true, true, false, true, false]\n```\n\n## Sample Input #2\n\n```\nbigString = \"abcdefghijklmnopqrstuvwxyz\"\nsmallStrings = [\"abc\", \"mnopqr\", \"wyz\", \"no\", \"e\", \"tuuv\"]\n```\n\n## Sample Output #2\n\n```\n[true, true, false, true, true, false]\n```\n\n### Hints\n\nHint 1\n> A simple way to solve this problem is to iterate through all of the small strings, checking if each of them is contained in the big string by iterating through the big string's characters and comparing them to the given small string's characters with a couple of loops. Is this approach efficient from a time-complexity point of view?\n\nHint 2\n> Try building a suffix-trie-like data structure containing all of the big string's suffixes. Then, iterate through all of the small strings and check if each of them is contained in the data structure you've created. What are the time-complexity ramifications of this approach?\n\nHint 3\n> Try building a trie containing all of the small strings. Then, iterate through the big string's characters and check if any part of the big string is a string contained in the trie you've created. Is this approach better than the one described in Hint #2 from a time-complexity point of view?\n\n```\nOptimal Space & Time Complexity\nO(ns + bs) time | O(ns) space - where n is the number of small strings, s is the length of longest small string, and b is the length of the big string\n```","basename":"multi-string-search"},"multiply-strings":{"title":"Multiply Strings","description":"Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.","tags":["medium","math","neetcode"],"link":"https://leetcode.com/problems/multiply-strings/","images":[],"preview":"### Description\n\nGiven two non-negative integers `num1` and `num2` represented as strings, return the product of `num1` and `num2`, also represented as a string.\n\n**Note**: You must not use any built-in BigInteger library or convert the inputs to integer directly.\n\n### Example 1\n\n```bash\nInput: num1 = \"2\", num2 = \"3\"\nOutput: \"6\"\n```\n\n### Example 2\n\n```bash\nInput: num1 = \"123\", num2 = \"456\"\nOutput: \"56088\"\n```\n\n### Constraints:\n\n- 1 <= num1.length, num2.length <= 200\n- num1 and num2 consist of digits only.\n- Both num1 and num2 do not contain any leading zero, except the number 0 itself.","basename":"multiply-strings"},"n-queens-ii":{"title":"N Queens II","description":"Given an integer n, return the number of distinct solutions to the n-queens puzzle.","tags":["hard","backtracking"],"link":"leetcode.com/problems/n-queens-ii","images":["https://assets.leetcode.com/uploads/2020/11/13/queens.jpg"],"preview":"### Description\n\nThe n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\n\nGiven an integer n, return the number of distinct solutions to the n-queens puzzle.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2020/11/13/queens.jpg)\n\n```bash\nInput: n = 4\nOutput: 2\nExplanation: There are two distinct solutions to the 4-queens puzzle as shown.\n```\n\n### Example 2\n\n```bash\nInput: n = 1\nOutput: 1\n```\n\n### Constraints:\n\n- 1 <= n <= 9","basename":"n-queens-ii"},"n-queens":{"title":"N-Queens","description":"The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.","tags":["neetcode","hard","backtracking"],"link":"https://leetcode.com/problems/n-queens/","images":[],"preview":"### Description\n\nThe **n-queens** puzzle is the problem of placing n queens on an `n x n` chessboard such that no two queens attack each other.\n\nGiven an integer n, return all distinct solutions to the **n-queens puzzle**. You may return the answer in **any order**.\n\nEach solution contains a distinct board configuration of the n-queens' placement, where `'Q'` and `'.'` both indicate a queen and an empty space, respectively.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2020/11/13/queens.jpg)\n\n\n```bash\nInput: n = 4\nOutput: [[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]\nExplanation: There exist two distinct solutions to the 4-queens puzzle as shown above\n```\n\n### Example 2\n\n```bash\nInput: n = 1\nOutput: [[\"Q\"]]\n```\n\n### Example 3\n\n```bash\nInput: n = 6\nOutput: \n```\n\n### Constraints:\n\n- `1 <= n <= 9`","basename":"n-queens"},"n-th-tribonacci-number":{"title":"N-th Tribonacci Number","description":"The Tribonacci sequence Tn is defined as follows","tags":["fibonacci","easy","dp"],"link":"https://leetcode.com/problems/n-th-tribonacci-number","images":[],"preview":"### Description\n\nThe Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.\n\n\n### Example 1\n\n```bash\nInput: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4\n```\n\n### Example 2\n\n```bash\nInput: n = 25\nOutput: 1389537\n```\n\n### Constraints:\n\n- 0 <= n <= 37\n- The answer is guaranteed to fit within a 32-bit integer, ie. answer <= 2^31 - 1.","basename":"n-th-tribonacci-number"},"nearest-exit-from-entrance-in-maze":{"title":"Nearest Exit From Entrance in Maze","description":"Return the number of steps in the shortest path from the entrance to the nearest exit, or -1 if no such path exists.","tags":["medium","graph","bfs"],"link":"https://leetcode.com/problems/nearest-exit-from-entrance-in-maze","images":["https://assets.leetcode.com/uploads/2021/06/04/nearest1-grid.jpg","https://assets.leetcode.com/uploads/2021/06/04/nearesr2-grid.jpg","https://assets.leetcode.com/uploads/2021/06/04/nearest3-grid.jpg"],"preview":"### Description\n\nYou are given an m x n matrix maze (0-indexed) with empty cells (represented as '.') and walls (represented as '+'). You are also given the entrance of the maze, where entrance = [entrancerow, entrancecol] denotes the row and column of the cell you are initially standing at.\n\nIn one step, you can move one cell up, down, left, or right. You cannot step into a cell with a wall, and you cannot step outside the maze. Your goal is to find the nearest exit from the entrance. An exit is defined as an empty cell that is at the border of the maze. The entrance does not count as an exit.\n\nReturn the number of steps in the shortest path from the entrance to the nearest exit, or -1 if no such path exists.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2021/06/04/nearest1-grid.jpg)\n\n```bash\nInput: maze = [[\"+\",\"+\",\".\",\"+\"],[\".\",\".\",\".\",\"+\"],[\"+\",\"+\",\"+\",\".\"]], entrance = [1,2]\nOutput: 1\nExplanation: There are 3 exits in this maze at [1,0], [0,2], and [2,3].\nInitially, you are at the entrance cell [1,2].\n- You can reach [1,0] by moving 2 steps left.\n- You can reach [0,2] by moving 1 step up.\nIt is impossible to reach [2,3] from the entrance.\nThus, the nearest exit is [0,2], which is 1 step away.\n```\n\n### Example 2\n\n![](https://assets.leetcode.com/uploads/2021/06/04/nearesr2-grid.jpg)\n\n```bash\nInput: maze = [[\"+\",\"+\",\"+\"],[\".\",\".\",\".\"],[\"+\",\"+\",\"+\"]], entrance = [1,0]\nOutput: 2\nExplanation: There is 1 exit in this maze at [1,2].\n[1,0] does not count as an exit since it is the entrance cell.\nInitially, you are at the entrance cell [1,0].\n- You can reach [1,2] by moving 2 steps right.\nThus, the nearest exit is [1,2], which is 2 steps away.\n```\n\n### Example 3\n\n![](https://assets.leetcode.com/uploads/2021/06/04/nearest3-grid.jpg)\n\n```bash\nInput: maze = [[\".\",\"+\"]], entrance = [0,0]\nOutput: -1\nExplanation: There are no exits in this maze.\n```\n\n### Constraints:\n\n- maze.length == m\n- maze[i].length == n\n- 1 <= m, n <= 100\n- maze[i][j] is either '.' or '+'.\n- entrance.length == 2\n- 0 <= entrancerow < m\n- 0 <= entrancecol < n\n- entrance will always be an empty cell.","basename":"nearest-exit-from-entrance-in-maze"},"new-21-game":{"title":"New 21 Game","description":"Alice starts with 0 points and draws numbers while she has less than k points. During each draw, she gains an integer number of points randomly from the range [1, maxPts], where maxPts is an integer. Each draw is independent and the outcomes have equal probabilities.","tags":["medium","grand-dp","probability"],"link":"https://leetcode.com/problems/new-21-game/","images":[],"preview":"### Description\n\nAlice plays the following game, loosely based on the card game \"21\".\n\nAlice starts with 0 points and draws numbers while she has less than k points. During each draw, she gains an integer number of points randomly from the range [1, maxPts], where maxPts is an integer. Each draw is independent and the outcomes have equal probabilities.\n\nAlice stops drawing numbers when she gets k or more points.\n\nReturn the probability that Alice has n or fewer points.\n\nAnswers within 10-5 of the actual answer are considered accepted.\n\n### Example 1\n\n```bash\nInput: n = 10, k = 1, maxPts = 10\nOutput: 1.00000\nExplanation: Alice gets a single card, then stops.\n```\n\n### Example 2\n\n```bash\nInput: n = 6, k = 1, maxPts = 10\nOutput: 0.60000\nExplanation: Alice gets a single card, then stops.\nIn 6 out of 10 possibilities, she is at or below 6 points.\n```\n\n### Constraints:\n\n- 0 <= k <= n <= 104\n- 1 <= maxPts <= 104","basename":"new-21-game"},"non-overlapping-intervals":{"title":"Non-overlapping Intervals","description":"Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.","tags":["neetcode","medium","intervals"],"link":"https://leetcode.com/problems/non-overlapping-intervals/","images":[],"preview":"### Description\n\nGiven an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.\n\n### Example 1\n\n```bash\nInput: intervals = [[1,2],[2,3],[3,4],[1,3]]\nOutput: 1\nExplanation: [1,3] can be removed and the rest of the intervals are non-overlapping.\n```\n\n### Example 2\n\n```bash\nInput: intervals = [[1,2],[1,2],[1,2]]\nOutput: 2\nExplanation: You need to remove two [1,2] to make the rest of the intervals non-overlapping.\n```\n\n### Example 3\n\n```bash\nInput: intervals = [[1,2],[2,3]]\nOutput: 0\nExplanation: You don't need to remove any of the intervals since they're already non-overlapping.\n```\n\n### Constraints:\n\n- 1 <= intervals.length <= 105\n- intervals[i].length == 2\n- -5 * 104 <= starti < endi <= 5 * 104","basename":"non-overlapping-intervals"},"number-of-1-bits":{"title":"Number of 1 Bits","description":"Write a function that takes the binary representation of an unsigned integer and returns the number of","tags":["easy","bit-manipulation","neetcode"],"link":"https://leetcode.com/problems/number-of-1-bits/","images":[],"preview":"### Description\n\nWrite a function that takes the binary representation of an unsigned integer and returns the number of '1' bits it has (also known as the Hamming weight).\n\n**Note:**\n\n    Note that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.\n    In Java, the compiler represents the signed integers using 2's complement notation. Therefore, in Example 3, the input represents the signed integer. -3.\n\n\n### Example 1\n\n```bash\nInput: n = 00000000000000000000000000001011\nOutput: 3\nExplanation: The input binary string 00000000000000000000000000001011 has a total of three '1' bits.\n```\n\n### Example 2\n\n```bash\nInput: n = 00000000000000000000000010000000\nOutput: 1\nExplanation: The input binary string 00000000000000000000000010000000 has a total of one '1' bit.\n```\n\n### Constraints:\n\n- The input must be a **binary string** of length `32`.","basename":"number-of-1-bits"},"number-of-closed-islands":{"title":"Number of Closed Islands","description":"Given a 2D grid consists of 0s (land) and 1s (water).  An island is a maximal 4-directionally connected group of 0s and a closed island is an island totally (all left, top, right, bottom) surrounded by 1s.","tags":["medium","graph","matrix-graphs"],"link":"https://leetcode.com/problems/number-of-closed-islands","images":[],"preview":"### Description\n\nGiven a 2D grid consists of 0s (land) and 1s (water).  An island is a maximal 4-directionally connected group of 0s and a closed island is an island totally (all left, top, right, bottom) surrounded by 1s.\n\nReturn the number of closed islands.\n\n\n\n### Example 1\n\n```bash\nInput: grid = [[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]]\nOutput: 2\nExplanation: \nIslands in gray are closed because they are completely surrounded by water (group of 1s).\n```\n\n### Example 2\n\n```bash\nInput: grid = [[0,0,1,0,0],[0,1,0,1,0],[0,1,1,1,0]]\nOutput: 1\n```\n\n### Example 3\n\n```bash\nInput: grid = [[1,1,1,1,1,1,1],\n               [1,0,0,0,0,0,1],\n               [1,0,1,1,1,0,1],\n               [1,0,1,0,1,0,1],\n               [1,0,1,1,1,0,1],\n               [1,0,0,0,0,0,1],\n               [1,1,1,1,1,1,1]]\nOutput: 2\n```\n\n### Constraints:\n\n- 1 <= grid.length, grid[0].length <= 100\n- 0 <= grid[i][j] <=1","basename":"number-of-closed-islands"},"number-of-connected-components-in-an-undirected-graph":{"title":"Redundant Connection","description":"find the number of connected components in an undirected graph.","tags":["neetcode","medium","graphs"],"link":"https://cheonhyangzhang.gitbooks.io/leetcode-solutions/content/323-number-of-connected-components-in-an-undirected-graph.html","images":[],"preview":"### Description\n\nGiven n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to find the number of connected components in an undirected graph.\n\n### Example 1\n\n```bash\n\nExample 1:\n\n     0          3\n     |          |\n     1 --- 2    4\n\nGiven n = 5 and edges = [[0, 1], [1, 2], [3, 4]], return 2.\n```\n\n### Example 2\n\n```bash\n\nExample 2:\n\n     0           4\n     |           |\n     1 --- 2 --- 3\n\nGiven n = 5 and edges = [[0, 1], [1, 2], [2, 3], [3, 4]], return 1.\n```\n\n### Constraints:\n\nNote:\nYou can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges.","basename":"number-of-connected-components-in-an-undirected-graph"},"number-of-enclaves":{"title":"Number of Enclaves","description":"Return the number of land cells in grid for which we cannot walk off the boundary of the grid in any number of moves.","tags":["medium","graph","matrix-graphs"],"link":"https://leetcode.com/problems/number-of-enclaves","images":["https://assets.leetcode.com/uploads/2021/02/18/enclaves1.jpg","https://assets.leetcode.com/uploads/2021/02/18/enclaves2.jpg"],"preview":"### Description\n\nYou are given an m x n binary matrix grid, where 0 represents a sea cell and 1 represents a land cell.\n\nA move consists of walking from one land cell to another adjacent (4-directionally) land cell or walking off the boundary of the grid.\n\nReturn the number of land cells in grid for which we cannot walk off the boundary of the grid in any number of moves.\n\n \n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2021/02/18/enclaves1.jpg)\n\n```bash\nInput: grid = [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]\nOutput: 3\nExplanation: There are three 1s that are enclosed by 0s, and one 1 that is not enclosed because its on the boundary.\n```\n\n### Example 2\n\n![](https://assets.leetcode.com/uploads/2021/02/18/enclaves2.jpg)\n\n```bash\nInput: grid = [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]\nOutput: 0\nExplanation: All 1s are either on the boundary or can reach the boundary.\n```\n\n### Constraints:\n\n- m == grid.length\n- n == grid[i].length\n- 1 <= m, n <= 500\n- grid[i][j] is either 0 or 1.","basename":"number-of-enclaves"},"number-of-islands":{"title":"Number of Islands","description":"Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.","tags":["neetcode","medium","graphs"],"link":"https://leetcode.com/problems/number-of-islands/","images":[],"preview":"### Description\n\nGiven an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\n\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\n\n\n### Example 1\n\n```bash\nInput: grid = [\n  [\"1\",\"1\",\"1\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"0\",\"0\"]\n]\nOutput: 1\n```\n\n### Example 2\n\n```bash\n\nInput: grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]\nOutput: 3\n```\n\n\n### Constraints:\n\n-","basename":"number-of-islands"},"number-of-longest-increasing-subsequence":{"title":"Number of Longest Increasing Subsequence","description":"Given an integer array nums, return the number of longest increasing subsequences. Notice that the sequence has to be strictly increasing.","tags":["dp","medium","longest-increasing-subsequence"],"link":"https://leetcode.com/problems/number-of-longest-increasing-subsequenc","images":[],"preview":"### Description\n\nGiven an integer array nums, return the number of longest increasing subsequences.\n\nNotice that the sequence has to be strictly increasing.\n\n### Example 1\n\n```bash\nInput: nums = [1,3,5,4,7]\nOutput: 2\nExplanation: The two longest increasing subsequences are \n\n[1, 3, 4, 7] and [1, 3, 5, 7].\n```\n\n### Example 2\n\n```bash\nInput: nums = [2,2,2,2,2]\nOutput: 5\nExplanation: The length of the longest increasing subsequence is 1, and there are 5 increasing subsequences of length 1, so output 5.\n```\n\n### Constraints:\n\n- 1 <= nums.length <= 2000\n- -106 <= nums[i] <= 106","basename":"number-of-longest-increasing-subsequence"},"number-of-music-playlists":{"title":"Number of Music Playlists","description":"Your music player contains n different songs. You want to listen to goal songs (not necessarily different) during your trip. To avoid boredom, you will create a playlist so that.","tags":["hard","grand-dp","general-multi-d"],"link":"https://leetcode.com/problems/number-of-music-playlists","images":[],"preview":"### Description\n\nYour music player contains n different songs. You want to listen to goal songs (not necessarily different) during your trip. To avoid boredom, you will create a playlist so that:\n\n- Every song is played at least once.\n- A song can only be played again only if k other songs have been played.\n\nGiven n, goal, and k, return the number of possible playlists that you can create. Since the answer can be very large, return it modulo 109 + 7.\n\n \n\n### Example 1\n\n```bash\nInput: n = 3, goal = 3, k = 1\nOutput: 6\nExplanation: There are 6 possible playlists: \n\n[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1].\n```\n\n### Example 2\n\n```bash\nInput: n = 2, goal = 3, k = 0\nOutput: 6\nExplanation: There are 6 possible playlists: \n\n[1, 1, 2], [1, 2, 1], [2, 1, 1], [2, 2, 1], [2, 1, 2], and [1, 2, 2].\n```\n\n### Example 3\n\n```bash\nInput: n = 2, goal = 3, k = 1\nOutput: 2\nExplanation: There are 2 possible playlists: \n\n[1, 2, 1] and [2, 1, 2].\n```\n\n### Constraints:\n\n- 0 <= k < n <= goal <= 100","basename":"number-of-music-playlists"},"number-of-provinces":{"title":"Number of Provinces","description":"A province is a group of directly or indirectly connected cities and no other cities outside of the group.","tags":["graph","medium"],"link":"https://leetcode.com/problems/number-of-provinces/","images":["https://assets.leetcode.com/uploads/2020/12/24/graph1.jpg"],"preview":"### Description\n\nThere are n cities. Some of them are connected, while some are not. If city a is connected directly with city b, and city b is connected directly with city c, then city a is connected indirectly with city c.\n\nA province is a group of directly or indirectly connected cities and no other cities outside of the group.\n\nYou are given an n x n matrix isConnected where isConnected[i][j] = 1 if the ith city and the jth city are directly connected, and isConnected[i][j] = 0 otherwise.\n\nReturn the total number of provinces.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2020/12/24/graph1.jpg)\n\n```bash\nInput: isConnected = [[1,1,0],[1,1,0],[0,0,1]]\nOutput: 2\n```\n\n### Example 2\n\n![](https://assets.leetcode.com/uploads/2020/12/24/graph2.jpg)\n\n```bash\nInput: isConnected = [[1,0,0],[0,1,0],[0,0,1]]\nOutput: 3\n```\n\n### Constraints:\n\n- 1 <= n <= 200\n- n == isConnected.length\n- n == isConnected[i].length\n- isConnected[i][j] is 1 or 0.\n- isConnected[i][i] == 1\n- isConnected[i][j] == isConnected[j][i]","basename":"number-of-provinces"},"number-of-ways-of-cutting-a-pizza":{"title":"Number of Ways of Cutting a Pizza","description":"Return the number of ways of cutting the pizza such that each piece contains at least one apple. Since the answer can be a huge number, return this modulo 10^9 + 7.","tags":["hard","grand-dp","general-multi-d"],"link":"https://leetcode.com/problems/number-of-ways-of-cutting-a-pizza","images":[],"preview":"### Description\n\nGiven a rectangular pizza represented as a rows x cols matrix containing the following characters: 'A' (an apple) and '.' (empty cell) and given the integer k. You have to cut the pizza into k pieces using k-1 cuts. \n\nFor each cut you choose the direction: vertical or horizontal, then you choose a cut position at the cell boundary and cut the pizza into two pieces. If you cut the pizza vertically, give the left part of the pizza to a person. If you cut the pizza horizontally, give the upper part of the pizza to a person. Give the last piece of pizza to the last person.\n\nReturn the number of ways of cutting the pizza such that each piece contains at least one apple. Since the answer can be a huge number, return this modulo 10^9 + 7.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2020/04/23/ways_to_cut_apple_1.png)\n\n```bash\nInput: pizza = [\"A..\",\"AAA\",\"...\"], k = 3\nOutput: 3 \nExplanation: The figure above shows the three ways to cut the pizza. Note that pieces must contain at least one apple.\n```\n\n### Example 2\n\n```bash\nInput: pizza = [\"A..\",\"AA.\",\"...\"], k = 3\nOutput: 1\n```\n\n\n### Example 3\n\n```bash\nInput: pizza = [\"A..\",\"A..\",\"...\"], k = 1\nOutput: 1\n```\n\n### Constraints:\n\n- 1 <= rows, cols <= 50\n- rows == pizza.length\n- cols == pizza[i].length\n- 1 <= k <= 10\n- pizza consists of characters 'A' and '.' only.","basename":"number-of-ways-of-cutting-a-pizza"},"number-of-ways-to-form-a-target-string-given-a-dictionary":{"title":"Number of Ways to Form a Target String Given a Dictionary","description":"Notice that you can use multiple characters from the same string in words provided the conditions above are met.","tags":["hard","grand-dp","general-multiple-1d"],"link":"https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary","images":[],"preview":"### Description\n\nYou are given a list of strings of the same length words and a string target.\n\nYour task is to form target using the given words under the following rules:\n\n- target should be formed from left to right.\n- To form the ith character (0-indexed) of target, you can choose the kth character of the jth string in words if target[i] = words[j][k].\n- Once you use the kth character of the jth string of words, you can no longer use the xth character of any string in words where x <= k. In other words, all characters to the left of or at index k become unusuable for every string.\n- Repeat the process until you form the string target.\nNotice that you can use multiple characters from the same string in words provided the conditions above are met.\n\nReturn the number of ways to form target from words. Since the answer may be too large, return it modulo 109 + 7.\n\n### Example 1\n\n```bash\nInput: words = [\"acca\",\"bbbb\",\"caca\"], target = \"aba\"\nOutput: 6\nExplanation: There are 6 ways to form target.\n\"aba\" -> index 0 (\"acca\"), index 1 (\"bbbb\"), index 3 (\"caca\")\n\"aba\" -> index 0 (\"acca\"), index 2 (\"bbbb\"), index 3 (\"caca\")\n\"aba\" -> index 0 (\"acca\"), index 1 (\"bbbb\"), index 3 (\"acca\")\n\"aba\" -> index 0 (\"acca\"), index 2 (\"bbbb\"), index 3 (\"acca\")\n\"aba\" -> index 1 (\"caca\"), index 2 (\"bbbb\"), index 3 (\"acca\")\n\"aba\" -> index 1 (\"caca\"), index 2 (\"bbbb\"), index 3 (\"caca\")\n```\n\n### Example 2\n\n```bash\nInput: words = [\"abba\",\"baab\"], target = \"bab\"\nOutput: 4\nExplanation: There are 4 ways to form target.\n\"bab\" -> index 0 (\"baab\"), index 1 (\"baab\"), index 2 (\"abba\")\n\"bab\" -> index 0 (\"baab\"), index 1 (\"baab\"), index 3 (\"baab\")\n\"bab\" -> index 0 (\"baab\"), index 2 (\"baab\"), index 3 (\"baab\")\n\"bab\" -> index 1 (\"abba\"), index 2 (\"baab\"), index 3 (\"baab\")\n```\n\n### Constraints:\n\n- 1 <= words.length <= 1000\n- 1 <= words[i].length <= 1000\n- All strings in words have the same length.\n- 1 <= target.length <= 1000\n- words[i] and target contain only lowercase English letters.","basename":"number-of-ways-to-form-a-target-string-given-a-dictionary"},"number-of-ways-to-reorder-array-to-get-same-bst":{"title":"Number of Ways to Reorder Array to Get Same BST","description":"Given an array nums that represents a permutation of integers from 1 to n. We are going to construct a binary search tree (BST) by inserting the elements of nums in order into an initially empty BST. Find the number of different ways to reorder nums so that the constructed BST is identical to that formed from the original array nums.","tags":[],"link":null,"images":[],"preview":"### Description\n\nGiven an array nums that represents a permutation of integers from 1 to n. We are going to construct a binary search tree (BST) by inserting the elements of nums in order into an initially empty BST. Find the number of different ways to reorder nums so that the constructed BST is identical to that formed from the original array nums.\n\n- For example, given nums = [2,1,3], we will have 2 as the root, 1 as a left child, and 3 as a right child. The array [2,3,1] also yields the same BST but [3,2,1] yields a different BST.\nReturn the number of ways to reorder nums such that the BST formed is identical to the original BST formed from nums.\n\nSince the answer may be very large, return it modulo 109 + 7.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2020/08/12/bb.png)\n\n```bash\nInput: nums = [2,1,3]\nOutput: 1\nExplanation: We can reorder nums to be [2,3,1] which will yield the same BST. There are no other ways to reorder nums which will yield the same BST.\n```\n\n### Example 2\n\n![](https://assets.leetcode.com/uploads/2020/08/12/ex1.png)\n\n```bash\nInput: nums = [3,4,5,1,2]\nOutput: 5\nExplanation: The following 5 arrays will yield the same BST: \n[3,1,2,4,5]\n[3,1,4,2,5]\n[3,1,4,5,2]\n[3,4,1,2,5]\n[3,4,1,5,2]\n```\n\n\n### Example 3\n\n![](https://assets.leetcode.com/uploads/2020/08/12/ex4.png)\n\n```bash\nInput: nums = [1,2,3]\nOutput: 0\nExplanation: There are no other orderings of nums that will yield the same BST.\n```\n\n\n### Constraints:\n\n- 1 <= nums.length <= 1000\n- 1 <= nums[i] <= nums.length\n- All integers in nums are distinct.","basename":"number-of-ways-to-reorder-array-to-get-same-bst"},"number-of-ways-to-wear-different-hats-to-each-other":{"title":"Number of Ways to Wear Different Hats to Each Other","description":"Return the number of ways that the n people wear different hats to each other.","tags":["hard","grand-dp","bitmasking"],"link":"https://leetcode.com/problems/number-of-ways-to-wear-different-hats-to-each-other/","images":[],"preview":"### Description\n\nThere are n people and 40 types of hats labeled from 1 to 40.\n\nGiven a 2D integer array hats, where hats[i] is a list of all hats preferred by the ith person.\n\nReturn the number of ways that the n people wear different hats to each other.\n\nSince the answer may be too large, return it modulo 10^9 + 7.\n\n \n\n### Example 1\n\n```bash\nInput: hats = [[3,4],[4,5],[5]]\nOutput: 1\nExplanation: There is only one way to choose hats given the conditions. \nFirst person choose hat 3, Second person choose hat 4 and last one hat 5.\n```\n\n### Example 2\n\n```bash\nInput: hats = [[3,5,1],[3,5]]\nOutput: 4\nExplanation: There are 4 ways to choose hats:\n(3,5), (5,3), (1,3) and (1,5)\n```\n\n### Example 3\n\n```bash\nInput: hats = [[1,2,3,4],[1,2,3,4],[1,2,3,4],[1,2,3,4]]\nOutput: 24\nExplanation: Each person can choose hats labeled from 1 to 4.\nNumber of Permutations of (1,2,3,4) = 24.\n```\n\n\n### Constraints:\n\n- n == hats.length\n- 1 <= n <= 10\n- 1 <= hats[i].length <= 40\n- 1 <= hats[i][j] <= 40\n- hats[i] contains a list of unique integers.","basename":"number-of-ways-to-wear-different-hats-to-each-other"},"numbers-in-pi":{"title":"Numbers in Pi","description":"Given a string representation of the first n digits of Pi and a list of positive integers (all in string format), write a function that returns the smallest number of spaces that can be added to the n digits of Pi such that all resulting numbers are found in the list of integers.","tags":["hard","algoexpert"],"preview":"# Numbers In Pi\n\nGiven a string representation of the first n digits of Pi and a list of positive integers (all in string format), write a function that returns the smallest number of spaces that can be added to the n digits of Pi such that all resulting numbers are found in the list of integers.\n\nNote that a single number can appear multiple times in the resulting numbers. For example, if Pi is \"3141\" and the numbers are [\"1\", \"3\", \"4\"], the number \"1\" is allowed to appear twice in the list of resulting numbers after three spaces are added: \"3 | 1 | 4 | 1\".\n\nIf no number of spaces to be added exists such that all resulting numbers are found in the list of integers, the function should return -1.\n\n## Sample Input\n\n```\npi = \"3141592653589793238462643383279\",\nnumbers = [\"314159265358979323846\", \"26433\", \"8\", \"3279\", \"314159265\", \"35897932384626433832\", \"79\"]\n```\n\n## Sample Output\n\n```\n2 // \"314159265 | 35897932384626433832 | 79\"\n```\n\n### Hints\n\nHint 1\n> You'll need to look numbers up quickly; is the input array the best data structure for this?\n\nHint 2\n> Dump every favorite number in a hash table for fast look-up. Iterate through the digits of Pi, checking if every prefix of the n digits is a favorite number. What should you do if you find that a prefix of the n digits of Pi is a favorite number?\n\nHint 3\n> Going off of Hint #2, if you find a prefix of the n digits of Pi that is a favorite number, try adding 1 space after it and then recursively calculating the smallest number of spaces in the suffix that comes after it. Do this for every prefix, and you'll find the answer. Can this method be optimized with a cache?\n\n```\nOptimal Space & Time Complexity\nO(n^3 + m) time | O(n + m) space - where n is the number of digits in Pi and m is the number of favorite numbers\n```","basename":"numbers-in-pi"},"ones-and-zeroes":{"title":"Ones and Zeroes","description":"A set x is a subset of a set y if all elements of x are also elements of y.","tags":["medium","dp","on-tree"],"link":"https://leetcode.com/problems/ones-and-zeroes/","images":[],"preview":"### Description\n\nYou are given an array of binary strings strs and two integers m and n.\n\nReturn the size of the largest subset of strs such that there are at most m `0`'s and n `1`'s in the subset.\n\nA set x is a subset of a set `y` if all elements of x are also elements of `y`.\n\n### Example 1\n\n```bash\nInput: strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3\nOutput: 4\nExplanation: The largest subset with at most 5 0's and 3 1's is {\"10\", \"0001\", \"1\", \"0\"}, so the answer is 4.\nOther valid but smaller subsets include {\"0001\", \"1\"} and {\"10\", \"1\", \"0\"}.\n{\"111001\"} is an invalid subset because it contains 4 1's, greater than the maximum of 3.\n```\n\n### Example 2\n\n```bash\nInput: strs = [\"10\",\"0\",\"1\"], m = 1, n = 1\nOutput: 2\nExplanation: The largest subset is {\"0\", \"1\"}, so the answer is 2.\n```\n\n### Constraints:\n\n- 1 <= strs.length <= 600\n- 1 <= strs[i].length <= 100\n- strs[i] consists only of digits '0' and '1'.\n- 1 <= m, n <= 100","basename":"ones-and-zeroes"},"optimal-account-balancing":{"title":"Optimal Account Balancing","description":"Return the minimum number of transactions required to settle the debt.","tags":["hard","grand-dp","bitmasking"],"link":"https://leetcode.com/problems/optimal-account-balancing/","images":[],"preview":"### Description\n\nYou are given an array of transactions transactions where transactions[i] = [fromi, toi, amounti] indicates that the person with ID = fromi gave amounti $ to the person with ID = toi.\n\nReturn the minimum number of transactions required to settle the debt.\n\n### Example 1\n\n```bash\nInput: transactions = [[0,1,10],[2,0,5]]\nOutput: 2\nExplanation:\nPerson #0 gave person #1 $10.\nPerson #2 gave person #0 $5.\nTwo transactions are needed. One way to settle the debt is person #1 pays person #0 and #2 $5 each.\n```\n\n### Example 2\n\n```bash\nInput: transactions = [[0,1,10],[1,0,1],[1,2,5],[2,0,5]]\nOutput: 1\nExplanation:\nPerson #0 gave person #1 $10.\nPerson #1 gave person #0 $1.\nPerson #1 gave person #2 $5.\nPerson #2 gave person #0 $5.\nTherefore, person #1 only need to give person #0 $4, and all debt is settled.\n```\n\n### Constraints:\n\n- 1 <= transactions.length <= 8\n- transactions[i].length == 3\n- 0 <= fromi, toi < 1\n- fromi != toi\n- 1 <= amounti <= 100","basename":"optimal-account-balancing"},"optimize-water-distribution-in-a-village":{"title":"Optimize Water Distribution in a Village","description":"Return the minimum total cost to supply water to all houses.","tags":["hard","graph","minimum-spanning-tree"],"link":"https://leetcode.com/problems/optimize-water-distribution-in-a-village","images":["https://assets.leetcode.com/uploads/2019/05/22/1359_ex1.png"],"preview":"### Description\n\nThere are n houses in a village. We want to supply water for all the houses by building wells and laying pipes.\n\nFor each house i, we can either build a well inside it directly with cost wells[i - 1] (note the -1 due to 0-indexing), or pipe in water from another well to it. The costs to lay pipes between houses are given by the array pipes where each pipes[j] = [house1j, house2j, costj] represents the cost to connect house1j and house2j together using a pipe. Connections are bidirectional, and there could be multiple valid connections between the same two houses with different costs.\n\nReturn the minimum total cost to supply water to all houses.\n\n \n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2019/05/22/1359_ex1.png)\n\n```bash\nInput: n = 3, wells = [1,2,2], pipes = [[1,2,1],[2,3,1]]\nOutput: 3\nExplanation: The image shows the costs of connecting houses using pipes.\nThe best strategy is to build a well in the first house with cost 1 and connect the other houses to it with cost 2 so the total cost is 3.\n```\n\n### Example 2\n\n```bash\nInput: n = 2, wells = [1,1], pipes = [[1,2,1],[1,2,2]]\nOutput: 2\nExplanation: We can supply water with cost two using one of the three options:\nOption 1:\n  - Build a well inside house 1 with cost 1.\n  - Build a well inside house 2 with cost 1.\nThe total cost will be 2.\nOption 2:\n  - Build a well inside house 1 with cost 1.\n  - Connect house 2 with house 1 with cost 1.\nThe total cost will be 2.\nOption 3:\n  - Build a well inside house 2 with cost 1.\n  - Connect house 1 with house 2 with cost 1.\nThe total cost will be 2.\nNote that we can connect houses 1 and 2 with cost 1 or with cost 2 but we will always choose the cheapest option. \n```\n\n### Constraints:\n\n- 2 <= n <= 104\n- wells.length == n\n- 0 <= wells[i] <= 105\n- 1 <= pipes.length <= 104\n- pipes[j].length == 3\n- 1 <= house1j, house2j <= n\n- 0 <= costj <= 105\n- house1j != house2j","basename":"optimize-water-distribution-in-a-village"},"pacific-atlantic-water-flow":{"title":"Pacific Atlantic Water Flow","description":"There is an m x n rectangular island that borders both the Pacific Ocean and Atlantic Ocean. The Pacific Ocean touches the island's left and top edges, and the Atlantic Ocean touches the island's right and bottom edges.","tags":["neetcode","medium","graphs"],"link":"https://leetcode.com/problems/pacific-atlantic-water-flow/","images":[],"hints":["https://wngnelson.com/assets/img_src/dsa/pacific-atlantic.gif"],"preview":"### Description\n\nThere is an m x n rectangular island that borders both the** Pacific Ocean** and Atlantic Ocean. The Pacific Ocean touches the island's left and top edges, and the Atlantic Ocean touches the island's right and bottom edges.\n\nThe island is partitioned into a grid of square cells. You are given an m x n integer matrix heights where heights[r][c] represents the **height above sea level** of the cell at coordinate (r, c).\n\nThe island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell's height is **less than or equal to** the current cell's height. Water can flow from any cell adjacent to an ocean into the ocean.\n\nReturn a **2D list** of grid coordinates result where result[i] = [ri, ci] denotes that rain water can flow from cell (ri, ci) to **both** the Pacific and Atlantic oceans.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2021/06/08/waterflow-grid.jpg)\n\n```bash\nInput: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]\nOutput: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]\nExplanation: The following cells can flow to the Pacific and Atlantic oceans, as shown below:\n[0,4]: [0,4] -> Pacific Ocean \n       [0,4] -> Atlantic Ocean\n[1,3]: [1,3] -> [0,3] -> Pacific Ocean \n       [1,3] -> [1,4] -> Atlantic Ocean\n[1,4]: [1,4] -> [1,3] -> [0,3] -> Pacific Ocean \n       [1,4] -> Atlantic Ocean\n[2,2]: [2,2] -> [1,2] -> [0,2] -> Pacific Ocean \n       [2,2] -> [2,3] -> [2,4] -> Atlantic Ocean\n[3,0]: [3,0] -> Pacific Ocean \n       [3,0] -> [4,0] -> Atlantic Ocean\n[3,1]: [3,1] -> [3,0] -> Pacific Ocean \n       [3,1] -> [4,1] -> Atlantic Ocean\n[4,0]: [4,0] -> Pacific Ocean \n       [4,0] -> Atlantic Ocean\nNote that there are other possible paths for these cells to flow to the Pacific and Atlantic oceans.\n```\n\n### Example 2\n\n```bash\nInput: heights = [[1]]\nOutput: [[0,0]]\nExplanation: The water can flow from the only cell to the Pacific and Atlantic oceans.\n```\n\n### Constraints:\n\n- m == heights.length\n- n == heights[r].length\n- 1 <= m, n <= 200\n- 0 <= heights[r][c] <= 10^5","basename":"pacific-atlantic-water-flow"},"paint-house-ii":{"title":"Paint House II","description":"The cost of painting each house with a certain color is represented by an n x k cost matrix costs.","tags":["hard","general-1d","dp"],"link":"https://leetcode.com/problems/paint-house-ii","images":[],"preview":"### Description\n\nThere are a row of n houses, each house can be painted with one of the k colors. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.\n\nThe cost of painting each house with a certain color is represented by an n x k cost matrix costs.\n\nFor example, costs[0][0] is the cost of painting house 0 with color 0; costs[1][2] is the cost of painting house 1 with color 2, and so on...\nReturn the minimum cost to paint all houses.\n\n \n\n### Example 1\n\n```bash\nInput: costs = [[1,5,3],[2,9,4]]\nOutput: 5\nExplanation:\nPaint house 0 into color 0, paint house 1 into color 2. Minimum cost: 1 + 4 = 5; \nOr paint house 0 into color 2, paint house 1 into color 0. Minimum cost: 3 + 2 = 5.\n```\n\n### Example 2\n\n```bash\nInput: costs = [[1,3],[2,4]]\nOutput: 5\n```\n\n### Constraints:\n\n- costs.length == n\n- costs[i].length == k\n- 1 <= n <= 100\n- 2 <= k <= 20\n- 1 <= costs[i][j] <= 20","basename":"paint-house-ii"},"paint-house-iii":{"title":"Paint House III","description":"Return the minimum cost of painting all the remaining houses in such a way that there are exactly target neighborhoods. If it is not possible, return -1","tags":["hard","grand-dp","general-multi-d"],"link":"https://leetcode.com/problems/paint-house-iii","images":[],"preview":"### Description\n\nThere is a row of m houses in a small city, each house must be painted with one of the n colors (labeled from 1 to n), some houses that have been painted last summer should not be painted again.\n\nA neighborhood is a maximal group of continuous houses that are painted with the same color.\n\n- For example: houses = [1,2,2,3,3,2,1,1] contains 5 neighborhoods [{1}, {2,2}, {3,3}, {2}, {1,1}].\nGiven an array houses, an m x n matrix cost and an integer target where:\n\n- houses[i]: is the color of the house i, and 0 if the house is not painted yet.\n- cost[i][j]: is the cost of paint the house i with the color j + 1.\n\nReturn the minimum cost of painting all the remaining houses in such a way that there are exactly target neighborhoods. If it is not possible, return -1.\n\n \n\n### Example 1\n\n```bash\nInput: houses = [0,0,0,0,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3\nOutput: 9\nExplanation: Paint houses of this way [1,2,2,1,1]\nThis array contains target = 3 neighborhoods, [{1}, {2,2}, {1,1}].\nCost of paint all houses (1 + 1 + 1 + 1 + 5) = 9.\n```\n\n### Example 2\n\n```bash\nInput: houses = [0,2,1,2,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3\nOutput: 11\nExplanation: Some houses are already painted, Paint the houses of this way [2,2,1,2,2]\nThis array contains target = 3 neighborhoods, [{2,2}, {1}, {2,2}]. \nCost of paint the first and last house (10 + 1) = 11.\n```\n\n### Constraints:\n\n- m == houses.length == cost.length\n- n == cost[i].length\n- 1 <= m <= 100\n- 1 <= n <= 20\n- 1 <= target <= m\n- 0 <= houses[i] <= n\n- 1 <= cost[i][j] <= 104","basename":"paint-house-iii"},"paint-house":{"title":"Paint House","description":"The cost of painting each house with a certain color is represented by an n x 3 cost matrix costs.","tags":["medium","dp","general-1d"],"link":"https://leetcode.com/problems/paint-house","images":[],"preview":"### Description\n\nThere is a row of n houses, where each house can be painted one of three colors: red, blue, or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.\n\nThe cost of painting each house with a certain color is represented by an n x 3 cost matrix costs.\n\nFor example, costs[0][0] is the cost of painting house 0 with the color red; costs[1][2] is the cost of painting house 1 with color green, and so on...\nReturn the minimum cost to paint all houses.\n\n \n\n### Example 1\n\n```bash\nInput: costs = [[17,2,17],[16,16,5],[14,3,19]]\nOutput: 10\nExplanation: Paint house 0 into blue, paint house 1 into green, paint house 2 into blue.\nMinimum cost: 2 + 5 + 3 = 10.\n```\n\n### Example 2\n\n```bash\nInput: costs = [[7,6,2]]\nOutput: 2\n```\n\n### Constraints:\n\n- costs.length == n\n- costs[i].length == 3\n- 1 <= n <= 100\n- 1 <= costs[i][j] <= 20","basename":"paint-house"},"palindrome-partitioning":{"title":"Palindrome Partitioning","description":"Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s.","tags":["neetcode"],"link":"https://leetcode.com/problems/palindrome-partitioning/","images":[],"preview":"### Description\n\nGiven a string `s`, partition `s` such that every substring of the partition is a **palindrome**. Return all possible palindrome partitioning of `s`.\n\n### Example 1\n\n```bash\nInput: s = \"aab\"\nOutput: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\n```\n\n### Example 2\n\n```bash\nInput: s = \"a\"\nOutput: [[\"a\"]]\n```\n\n### Constraints:\n\n- 1 <= s.length <= 16 \n- `s` contains only lowercase English letters.","basename":"palindrome-partitioning"},"palindromic-substrings":{"title":"Palindromic Substrings","description":"Given a string s, return the number of palindromic substrings in it.  A string is a palindrome when it reads the same backward as forward.  A substring is a contiguous sequence of characters within the string.","tags":["medium","dp","neetcode"],"link":"https://leetcode.com/problems/palindromic-substrings/","images":[],"preview":"### Description\n\nGiven a string s, return the number of **palindromic substrings** in it. A string is a **palindrome** when it reads the same backward as forward.\nA **substring** is a contiguous sequence of characters within the string.\n\n### Example 1\n\n```bash\nInput: s = \"abc\"\nOutput: 3\nExplanation: Three palindromic strings: \"a\", \"b\", \"c\".\n```\n\n### Example 2\n\n```bash\nInput: s = \"aaa\"\nOutput: 6\nExplanation: Six palindromic strings: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\".\n```\n\n### Constraints:\n\n- 1 <= s.length <= 1000\n- s consists of lowercase English letters.","basename":"palindromic-substrings"},"partition-equal-subset-sum":{"title":"Partition Equal Subset Sum","description":"Given an integer array nums, return true if you can partition the array into two subsets such that the sum of the elements in both subsets is equal or false otherwise.","tags":["medium","dp","neetcode"],"link":"https://leetcode.com/problems/partition-equal-subset-sum/1","images":[],"preview":"### Description\n\nGiven an integer array `nums`, return `true` if you can partition the array into two subsets such that the sum of the elements in both subsets is equal or `false` otherwise.\n\n### Example 1\n\n```bash\nInput: nums = [1,5,11,5]\nOutput: true\nExplanation: The array can be partitioned as [1, 5, 5] and [11].\n```\n\n### Example 2\n\n```bash\nInput: nums = [1,2,3,5]\nOutput: false\nExplanation: The array cannot be partitioned into equal sum subsets.\n```\n\n### Constraints:\n\n- 1 <= nums.length <= 200\n- 1 <= nums[i] <= 100","basename":"partition-equal-subset-sum"},"partition-labels":{"title":"Partition of Labels","description":"You are given a string s. We want to partition the string into as many parts as possible so that each letter appears in at most one part.","tags":["medium","greedy","neetcode"],"link":"https://leetcode.com/problems/partition-labels/","images":[],"preview":"### Description\n\nYou are given a string `s`. We want to partition the string into as many parts as possible so that each letter appears in at most one part.\n\nNote that the partition is done so that after concatenating all the parts in order, the resultant string should be `s`.\n\nReturn a list of integers representing the size of these parts.\n\n### Example 1\n\n```bash\nInput: s = \"ababcbacadefegdehijhklij\"\nOutput: [9,7,8]\nExplanation:\nThe partition is \"ababcbaca\", \"defegde\", \"hijhklij\".\nThis is a partition so that each letter appears in at most one part.\nA partition like \"ababcbacadefegde\", \"hijhklij\" is incorrect, because it splits s into less parts.\n```\n\n### Example 2\n\n```bash\nInput: s = \"eccbbbbdec\"\nOutput: [10]\n```\n\n### Constraints:\n\n- 1 <= s.length <= 500\n- s consists of lowercase English letters.","basename":"partition-labels"},"partition-list":{"title":"Partition List","description":null,"tags":[],"link":null,"images":[],"preview":"### Description\n\nGiven the head of a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.\n\nYou should preserve the original relative order of the nodes in each of the two partitions.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2021/01/04/partition.jpg)\n\n```bash\nInput: head = [1,4,3,2,5,2], x = 3\nOutput: [1,2,2,4,3,5]\n```\n\n### Example 2\n\n```bash\nInput: head = [2,1], x = 2\nOutput: [1,2]\n```\n\n### Constraints:\n\n- The number of nodes in the list is in the range [0, 200].\n- -100 <= Node.val <= 100\n- -200 <= x <= 200","basename":"partition-list"},"partition-to-k-equal-sum-subsets":{"title":"Partition to K Equal Sum Subsets","description":"Given an integer array nums and an integer k, return true if it is possible to divide this array into k non-empty subsets whose sums are all equal.","tags":["medium","grand-dp","bitmasking"],"link":"https://leetcode.com/problems/partition-to-k-equal-sum-subsets","images":[],"preview":"### Description\n\nGiven an integer array nums and an integer k, return true if it is possible to divide this array into k non-empty subsets whose sums are all equal.\n\n### Example 1\n\n```bash\nInput: nums = [4,3,2,3,5,2,1], k = 4\nOutput: true\nExplanation: It is possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums.\n```\n\n### Example 2\n\n```bash\nInput: nums = [1,2,3,4], k = 3\nOutput: false\n```\n\n### Constraints:\n\n- 1 <= k <= nums.length <= 16\n- 1 <= nums[i] <= 10^4\n- The frequency of each element is in the range [1, 4].","basename":"partition-to-k-equal-sum-subsets"},"path-with-maximum-probability":{"title":"Path With Maximum Probability","description":"If there is no path from start to end, return 0. Your answer will be accepted if it differs from the correct answer by at most 1e-5.","tags":["medium","graph","dijkstra"],"link":"https://leetcode.com/problems/path-with-maximum-probability","images":[],"preview":"### Description\n\nYou are given an undirected weighted graph of n nodes (0-indexed), represented by an edge list where edges[i] = [a, b] is an undirected edge connecting the nodes a and b with a probability of success of traversing that edge succProb[i].\n\nGiven two nodes start and end, find the path with the maximum probability of success to go from start to end and return its success probability.\n\nIf there is no path from start to end, return 0. Your answer will be accepted if it differs from the correct answer by at most 1e-5.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2019/09/20/1558_ex1.png)\n\n```bash\nInput: n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.2], start = 0, end = 2\nOutput: 0.25000\nExplanation: There are two paths from start to end, one having a probability of success = 0.2 and the other has 0.5 * 0.5 = 0.25.\n```\n\n### Example 2\n\n![](https://assets.leetcode.com/uploads/2019/09/20/1558_ex2.png)\n\n```bash\nInput: n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.3], start = 0, end = 2\nOutput: 0.30000\n```\n\n### Example 3\n\n![](https://assets.leetcode.com/uploads/2019/09/20/1558_ex3.png)\n\n```bash\nInput: n = 3, edges = [[0,1]], succProb = [0.5], start = 0, end = 2\nOutput: 0.00000\nExplanation: There is no path between 0 and 2.\n```\n\n### Constraints:\n\n- 2 <= n <= 10^4\n- 0 <= start, end < n\n- start != end\n- 0 <= a, b < n\n- a != b\n- 0 <= succProb.length == edges.length <= 2*10^4\n- 0 <= succProb[i] <= 1\n- There is at most one edge between every two nodes.","basename":"path-with-maximum-probability"},"perfect-squares":{"title":"Perfect Squares","description":"A perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not.","tags":["medium","dp","on-tree"],"link":"https://leetcode.com/problems/perfect-squares","images":[],"preview":"### Description\n\nGiven an integer n, return the least number of perfect square numbers that sum to n.\n\nA perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, `1, 4, 9, and 16` are perfect squares while `3` and `11` are not.\n\n### Example 1\n\n```bash\nInput: n = 12\nOutput: 3\nExplanation: 12 = 4 + 4 + 4.\n```\n\n### Example 2\n\n```bash\nInput: n = 13\nOutput: 2\nExplanation: 13 = 4 + 9.\n```\n\n### Constraints:\n\n- 1 <= n <= 10^4","basename":"perfect-squares"},"permutations":{"title":"Permutations","description":"Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.","tags":["neetcode","medium","backtracking"],"link":"https://leetcode.com/problems/permutations/","images":[],"preview":"### Description\n\nGiven an array `nums` of distinct integers, return all the possible permutations. You can return the answer **in any order**.\n\n### Example 1\n\n```bash\nInput: nums = [1,2,3]\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n```\n\n### Example 2\n\n```bash\nInput: nums = [0,1]\nOutput: [[0,1],[1,0]]\n```\n\n### Example 3\n\n```bash\nInput: nums = [1]\nOutput: [[1]]\n```\n\n### Constraints:\n\n- 1 <= nums.length <= 6 \n- -10 <= nums[i] <= 10 \n- All the integers of nums are unique.","basename":"permutations"},"plus-one":{"title":"Plus One","description":"Increment the large integer by one and return the resulting array of digits.","tags":["easy","math","neetcode"],"link":"https://leetcode.com/problems/plus-one/","images":[],"preview":"### Description\n\nYou are given a **large integer** represented as an integer array `digits`, where each `digits[i]` is the `ith` digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading `0`'s.\n\nIncrement the large integer by one and return the resulting array of digits.\n\n### Example 1\n\n```bash\nInput: digits = [1,2,3]\nOutput: [1,2,4]\nExplanation: The array represents the integer 123.\nIncrementing by one gives 123 + 1 = 124.\nThus, the result should be [1,2,4].\n```\n\n### Example 2\n\n```bash\nInput: digits = [4,3,2,1]\nOutput: [4,3,2,2]\nExplanation: The array represents the integer 4321.\nIncrementing by one gives 4321 + 1 = 4322.\nThus, the result should be [4,3,2,2].\n```\n\n### Example 3\n\n```bash\nInput: digits = [9]\nOutput: [1,0]\nExplanation: The array represents the integer 9.\nIncrementing by one gives 9 + 1 = 10.\nThus, the result should be [1,0].\n```\n\n### Constraints:\n\n- 1 <= digits.length <= 100\n- 0 <= digits[i] <= 9\n- digits does not contain any leading 0's.","basename":"plus-one"},"populating-next-right-pointers-in-each-node-ii":{"title":"Populating Next Right Pointer in Each Node","description":"Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.","tags":["binary-tree","medium"],"link":"https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii","images":[],"preview":"### Description\n\nGiven a binary tree\n\n\n```js\nstruct Node {\n  int val;\n  Node *left;\n  Node *right;\n  Node *next;\n}\n```\n\n\nPopulate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.\n\nInitially, all next pointers are set to NULL.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2019/02/15/117_sample.png)\n\n```bash\nInput: root = [1,2,3,4,5,null,7]\nOutput: [1,#,2,3,#,4,5,7,#]\nExplanation: Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with '#' signifying the end of each level.\n```\n\n### Example 2\n\n```bash\nInput: root = []\nOutput: []\n```\n\n### Constraints:\n\n- The number of nodes in the tree is in the range [0, 6000].\n- -100 <= Node.val <= 100","basename":"populating-next-right-pointers-in-each-node-ii"},"powx-n":{"title":"Pow(x, n)","description":"Implement pow(x, n), which calculates x raised to the power n (i.e., xn).","tags":["medium","math","neetcode"],"link":"https://leetcode.com/problems/powx-n/","images":[],"preview":"### Description\n\nImplement `pow(x, n)`, which calculates `x` raised to the power n (i.e., x^n).\n\n### Example 1\n\n```bash\nInput: x = 2.00000, n = 10\nOutput: 1024.00000\n```\n\n### Example 2\n\n```bash\nInput: x = 2.10000, n = 3\nOutput: 9.26100\n```\n\n### Example 3\n\n```bash\nInput: x = 2.00000, n = -2\nOutput: 0.25000\nExplanation: 2-2 = 1/22 = 1/4 = 0.25\n```\n\n### Constraints:\n\n- -100.0 < x < 100.0\n- -231 <= n <= 231-1\n- n is an integer.\n- -104 <= xn <= 104","basename":"powx-n"},"predict-the-winner":{"title":"Predict the Winner","description":"Return true if Player 1 can win the game. If the scores of both players are equal, then player 1 is still the winner, and you should also return true. You may assume that both players are playing optimally.","tags":["medium","grand-dp","game-theory"],"link":"https://leetcode.com/problems/predict-the-winner/","images":[],"preview":"### Description\n\nYou are given an integer array nums. Two players are playing a game with this array: player 1 and player 2.\n\nPlayer 1 and player 2 take turns, with player 1 starting first. Both players start the game with a score of 0. At each turn, the player takes one of the numbers from either end of the array (i.e., nums[0] or nums[nums.length - 1]) which reduces the size of the array by 1. The player adds the chosen number to their score. The game ends when there are no more elements in the array.\n\nReturn true if Player 1 can win the game. If the scores of both players are equal, then player 1 is still the winner, and you should also return true. You may assume that both players are playing optimally.\n\n### Example 1\n\n```bash\nInput: nums = [1,5,2]\nOutput: false\nExplanation: Initially, player 1 can choose between 1 and 2. \nIf he chooses 2 (or 1), then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5, then player 1 will be left with 1 (or 2). \nSo, final score of player 1 is 1 + 2 = 3, and player 2 is 5. \nHence, player 1 will never be the winner and you need to return false.\n```\n\n### Example 2\n\n```bash\nInput: nums = [1,5,233,7]\nOutput: true\nExplanation: Player 1 first chooses 1. Then player 2 has to choose between 5 and 7. No matter which number player 2 choose, player 1 can choose 233.\nFinally, player 1 has more score (234) than player 2 (12), so you need to return True representing player1 can win.\n```\n\n### Constraints:\n\n- 1 <= nums.length <= 20\n- 0 <= nums[i] <= 10^7","basename":"predict-the-winner"},"profitable-schemes":{"title":"Profitable Schemes","description":"Return the number of schemes that can be chosen. Since the answer may be very large, return it modulo 109 + 7.","tags":["hard","grand-dp","probability"],"link":"https://leetcode.com/problems/profitable-scheme","images":[],"preview":"### Description\n\nThere is a group of n members, and a list of various crimes they could commit. The ith crime generates a profit[i] and requires group[i] members to participate in it. If a member participates in one crime, that member can't participate in another crime.\n\nLet's call a profitable scheme any subset of these crimes that generates at least minProfit profit, and the total number of members participating in that subset of crimes is at most n.\n\nReturn the number of schemes that can be chosen. Since the answer may be very large, return it modulo 10^9 + 7.\n\n### Example 1\n\n```bash\nInput: n = 5, minProfit = 3, group = [2,2], profit = [2,3]\nOutput: 2\nExplanation: To make a profit of at least 3, the group could either commit crimes 0 and 1, or just crime 1.\nIn total, there are 2 schemes.\n```\n\n### Example 2\n\n```bash\nInput: n = 10, minProfit = 5, group = [2,3,5], profit = [6,7,8]\nOutput: 7\nExplanation: To make a profit of at least 5, the group could commit any crimes, as long as they commit one.\nThere are 7 possible schemes: (0), (1), (2), (0,1), (0,2), (1,2), and (0,1,2).\n```\n\n### Constraints:\n\n- 1 <= n <= 100\n- 0 <= minProfit <= 100\n- 1 <= group.length <= 100\n- 1 <= group[i] <= 100\n- profit.length == group.length\n- 0 <= profit[i] <= 100","basename":"profitable-schemes"},"prompt":{"preview":"","basename":"prompt"},"put-boxes-into-the-warehouse-ii":{"title":"Put Boxes Into The Warehouse II","description":"Return the maximum number of boxes you can put into the warehouse.","tags":["medium"],"link":null,"images":[],"preview":"### Description\n\nYou are given two arrays of positive integers, boxes and warehouse, representing the heights of some boxes of unit width and the heights of n rooms in a warehouse respectively. The warehouse's rooms are labeled from 0 to n - 1 from left to right where warehouse[i] (0-indexed) is the height of the ith room.\n\nBoxes are put into the warehouse by the following rules:\n\nBoxes cannot be stacked.\nYou can rearrange the insertion order of the boxes.\nBoxes can be pushed into the warehouse from either side (left or right)\nIf the height of some room in the warehouse is less than the height of a box, then that box and all other boxes behind it will be stopped before that room.\nReturn the maximum number of boxes you can put into the warehouse.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2020/08/30/22.png)\n\n```bash\nInput: boxes = [1,2,2,3,4], warehouse = [3,4,1,2]\nOutput: 4\n```\n\n![](https://assets.leetcode.com/uploads/2020/08/30/22-1.png)\n\n\n```bash\nWe can store the boxes in the following order:\n1- Put the yellow box in room 2 from either the left or right side.\n2- Put the orange box in room 3 from the right side.\n3- Put the green box in room 1 from the left side.\n4- Put the red box in room 0 from the left side.\nNotice that there are other valid ways to put 4 boxes such as swapping the red and green boxes or the red and orange boxes.\n```\n\n\n### Example 2\n\n![](https://assets.leetcode.com/uploads/2020/08/30/22-2.png)\n\n```bash\nInput: boxes = [3,5,5,2], warehouse = [2,1,3,4,5]\nOutput: 3\nExplanation:\n```\n\n![](https://assets.leetcode.com/uploads/2020/08/30/22-3.png)\n\n```\nIt is not possible to put the two boxes of height 5 in the warehouse since there's only 1 room of height >= 5.\nOther valid solutions are to put the green box in room 2 or to put the orange box first in room 2 before putting the green and red boxes.\n```\n\n### Constraints:\n\n- n == warehouse.length\n- 1 <= boxes.length, warehouse.length <= 105\n- 1 <= boxes[i], warehouse[i] <= 109","basename":"put-boxes-into-the-warehouse-ii"},"redundant-connection":{"title":"Redundant Connection","description":"In this problem, a tree is an undirected graph that is connected and has no cycles.","tags":["neetcode","medium","graphs"],"link":"https://leetcode.com/problems/redundant-connection/","images":["https://assets.leetcode.com/uploads/2021/05/02/reduntant1-1-graph.jpg","https://assets.leetcode.com/uploads/2021/05/02/reduntant1-2-graph.jpg"],"hints":["https://wngnelson.com/assets/img_src/dsa/redundant_connection_dfs.gif","https://wngnelson.com/assets/img_src/dsa/redundant_connection.gif"],"preview":"### Description\n\nIn this problem, a tree is an **undirected graph** that is connected and has no cycles.\n\nYou are given a graph that started as a tree with n nodes labeled from 1 to n, with one additional edge added. The added edge has two **different** vertices chosen from 1 to n, and was not an edge that already existed. The graph is represented as an array edges of length n where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the graph.\n\nReturn an edge that can be removed so that the resulting graph is a tree of n nodes. If there are multiple answers, return the answer that occurs last in the input.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2021/05/02/reduntant1-1-graph.jpg)\n\n```bash\nInput: edges = [[1,2],[1,3],[2,3]]\nOutput: [2,3]\n```\n\n### Example 2\n\n![](https://assets.leetcode.com/uploads/2021/05/02/reduntant1-2-graph.jpg)\n\n```bash\nInput: edges = [[1,2],[2,3],[3,4],[1,4],[1,5]]\nOutput: [1,4]\n```\n\n### Constraints:\n\n- n == edges.length\n- 3 <= n <= 1000\n- edges[i].length == 2\n- 1 <= ai < bi <= edges.length\n- ai != bi\n- There are no repeated edges.\n- The given graph is connected.","basename":"redundant-connection"},"regex-1":{"title":"Regex 1","description":"create a markdown that returns all 'hackerrank' matches","tags":["neetcode","easy","regex"],"link":"https://www.hackerrank.com/challenges/regex-1/problem","preview":"### Description\n\nCreate a markdown that returns all 'hackerrank' matches\n\n### Example 1\n\n```bash\nInput The hackerrank team is on a mission to flatten the world by restructuring the hackerrank DNA of every company on the planet. We rank programmers based on their coding skills, helping companies source great programmers and reduce the time to hire. As a result, we are revolutionizing the way companies discover and evaluate talented engineers. The hackerrank platform is the destination for the best engineers to hone their skills and companies to find top engineers. \n\nOutput: ['hackerrank', 'hackerrank', 'hackerrank']\n```","basename":"regex-1"},"remove-duplicates-from-sorted-list-ii":{"title":"Remove Duplicates from Sorted List II","description":"Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well.","tags":["linked-list","medium"],"link":"https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/","images":[],"preview":"### Description\n\nGiven the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2021/01/04/linkedlist1.jpg)\n\n```bash\nInput: head = [1,2,3,3,4,4,5]\nOutput: [1,2,5]\n```\n\n### Example 2\n\n![](https://assets.leetcode.com/uploads/2021/01/04/linkedlist2.jpg)\n\n```bash\nInput: head = [1,1,1,2,3]\nOutput: [2,3]\n```\n\n### Constraints:\n\n- The number of nodes in the list is in the range [0, 300].\n- -100 <= Node.val <= 100\n- The list is guaranteed to be sorted in ascending order.","basename":"remove-duplicates-from-sorted-list-ii"},"remove-from-nth":{"title":"Remove Nth Node From End of List","description":"Given the head of a linked list, remove the nth node from the end of the list and return its head.","tags":["neetcode","medium","linked-list"],"link":"https://leetcode.com/problems/remove-nth-node-from-end-of-list/","preview":"### Description\n\nGiven the head of a linked list, remove the nth node from the end of the list and return its head.\n\n### Example 1\n\n```bash\nInput: head = [1,2,3,4,5], n = 2\nOutput: [1,2,3,5]\n```\n\n### Example 2\n\n```bash\nInput: head = [1], n = 1\nOutput: []\n```\n\n### Example 3\n\n```bash\nInput: head = [1,2], n = 1\nOutput: [1]\n```\n\n### Constraints:\n\n- The number of nodes in the list is sz. \n- 1 <= sz <= 30 \n- 0 <= Node.val <= 100 \n- 1 <= n <= sz","basename":"remove-from-nth"},"remove-nth-node-from-end-of-list":{"title":"Remove Nth Node From End of List","description":"Given the head of a linked list, remove the nth node from the end of the list and return its head.","tags":["medium","linked-list"],"link":"https://leetcode.com/problems/remove-nth-node-from-end-of-list","images":[],"preview":"### Description\n\nGiven the head of a linked list, remove the nth node from the end of the list and return its head.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg)\n\n```bash\nInput: head = [1,2,3,4,5], n = 2\nOutput: [1,2,3,5]\n```\n\n### Example 2\n\n```bash\nInput: head = [1], n = 1\nOutput: []\n```\n\n### Example 3\n\n```bash\nInput: head = [1,2], n = 1\nOutput: [1]\n```\n\n\n### Constraints:\n\n- The number of nodes in the list is sz.\n- 1 <= sz <= 30\n- 0 <= Node.val <= 100\n- 1 <= n <= sz","basename":"remove-nth-node-from-end-of-list"},"reorder-list":{"title":"Reorder List","description":"You are given the head of a singly linked-list. The list can be represented as","tags":["neetcode","medium","linked-list"],"link":"https://leetcode.com/problems/reorder-list/","images":["https://assets.leetcode.com/uploads/2021/03/04/reorder1linked-list.jpg","https://assets.leetcode.com/uploads/2021/03/04/reorder2linked-list.jpg"],"hints":["https://twitter.com/i/status/1720446908957630801"],"preview":"### Description\n\nYou are given the head of a singly linked-list. The list can be represented as:\n\n`L0  L1    Ln - 1  Ln`\nReorder the list to be on the following form:\n\n`L0  Ln  L1  Ln - 1  L2  Ln - 2  `\nYou may not modify the values in the list's nodes. Only nodes themselves may be changed.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2021/03/04/reorder1linked-list.jpg)\n\n```bash\nInput: head = [1,2,3,4]\nOutput: [1,4,2,3]\n```\n\n### Example 2\n\n![](https://assets.leetcode.com/uploads/2021/03/04/reorder2linked-list.jpg)\n\n```bash\nInput: head = [1,2,3,4,5]\nOutput: [1,5,2,4,3]\n```\n\n### Constraints:\n\n- The number of nodes in the list is in the range [1, 5 * 104]. \n- 1 <= Node.val <= 1000","basename":"reorder-list"},"reorder-routes-to-make-all-paths-lead-to-the-city-zero":{"title":"Reorder Routes to Make All Paths Lead to the City Zero","description":"Your task consists of reorienting some roads such that each city can visit the city 0. Return the minimum number of edges changed.","tags":["medium","graph","standard-traversal"],"link":"https://leetcode.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/","images":[],"preview":"### Description\n\nThere are n cities numbered from 0 to n - 1 and n - 1 roads such that there is only one way to travel between two different cities (this network form a tree). Last year, The ministry of transport decided to orient the roads in one direction because they are too narrow.\n\nRoads are represented by connections where connections[i] = [ai, bi] represents a road from city ai to city bi.\n\nThis year, there will be a big event in the capital (city 0), and many people want to travel to this city.\n\nYour task consists of reorienting some roads such that each city can visit the city 0. Return the minimum number of edges changed.\n\nIt's guaranteed that each city can reach city 0 after reorder.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2020/05/13/sample_1_1819.png)\n\n```bash\nInput: n = 6, connections = [[0,1],[1,3],[2,3],[4,0],[4,5]]\nOutput: 3\nExplanation: Change the direction of edges show in red such that each node can reach the node 0 (capital).\n```\n\n### Example 2\n\n![](https://assets.leetcode.com/uploads/2020/05/13/sample_2_1819.png)\n\n```bash\nInput: n = 5, connections = [[1,0],[1,2],[3,2],[3,4]]\nOutput: 2\nExplanation: Change the direction of edges show in red such that each node can reach the node 0 (capital).\n```\n\n### Constraints:\n\n- 2 <= n <= 5 * 104\n- connections.length == n - 1\n- connections[i].length == 2\n- 0 <= ai, bi <= n - 1\n- ai != bi","basename":"reorder-routes-to-make-all-paths-lead-to-the-city-zero"},"restore-the-array":{"title":"Restore the Array","description":"The program forgot to print whitespaces and the array is printed as a string of digits s and all we know is that all integers in the array were in the range [1, k] and there are no leading zeros in the array","tags":["hard","dp","general-1d"],"link":"https://leetcode.com/problems/restore-the-array/","images":[],"preview":"### Description\n\nA program was supposed to print an array of integers. The program forgot to print whitespaces and the array is printed as a string of digits s and all we know is that all integers in the array were in the range [1, k] and there are no leading zeros in the array.\n\nGiven the string s and the integer k, return the number of the possible arrays that can be printed as s using the mentioned program. Since the answer may be very large, return it modulo 109 + 7.\n\n### Example 1\n\n```bash\nInput: s = \"1000\", k = 10000\nOutput: 1\nExplanation: The only possible array is [1000]\n```\n\n### Example 2\n\n```bash\nInput: s = \"1000\", k = 10\nOutput: 0\nExplanation: There cannot be an array that was printed this way and has all integer >= 1 and <= 10.\n```\n\n### Constraints:\n\n- 1 <= s.length <= 105\n- s consists of only digits and does not contain leading zeros.\n- 1 <= k <= 109","basename":"restore-the-array"},"reverse-bits":{"title":"Reverse Bits","description":"Reverse bits of a given 32 bits unsigned integer.","tags":["easy","bit-manipulation"],"link":"https://leetcode.com/problems/reverse-bits/","images":[],"preview":"### Description\n\nReverse bits of a given 32 bits unsigned integer.\n\nNote:\n\n    Note that in some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.\n    In Java, the compiler represents the signed integers using 2's complement notation. Therefore, in Example 2 above, the input represents the signed integer -3 and the output represents the signed integer -1073741825.\n\n\n### Example 1\n\n```bash\nInput: n = 00000010100101000001111010011100\nOutput:    964176192 (00111001011110000010100101000000)\nExplanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000.\n```\n\n### Example 2\n\n```bash\nInput: n = 11111111111111111111111111111101\nOutput:   3221225471 (10111111111111111111111111111111)\nExplanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10111111111111111111111111111111.\n```\n\n### Constraints:\n\n- The input must be a binary string of length 32","basename":"reverse-bits"},"reverse-integer":{"title":"Reverse Integer","description":"Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.","tags":["medium","bit-manipulation"],"link":"https://leetcode.com/problems/reverse-integer/","images":[],"preview":"### Description\n\nGiven a signed 32-bit integer `x`, return `x` with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range `[-2^31, 2^31 - 1]`, then return `0`.\n\n**Assume the environment does not allow you to store 64-bit integers (signed or unsigned).**\n\n### Example 1\n\n```bash\nInput: x = 123\nOutput: 321\n```\n\n### Example 2\n\n```bash\nInput: x = -123\nOutput: -321\n```\n\n### Example 3\n\n```bash\nInput: x = 120\nOutput: 21\n```\n\n\n### Constraints:\n\n- -2^31 <= x <= 2^31 - 1","basename":"reverse-integer"},"reverse-linked-list-ii":{"title":"Reverse Linked List II","description":"Given the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from position left to position right, and return the reversed list.","tags":["medium","linked-list"],"link":"https://leetcode.com/problems/reverse-linked-list-ii/","images":["https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg","https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg"],"hints":["Once you find the left node, you can just run the reverse linked list algorithm until you reach the right node.","Remember that the tracked prev can be null","https://leetcode.com/problems/reverse-linked-list-ii/Figures/92/tail_and_con.png"],"preview":"### Description\n\nGiven the `head` of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from position `left` to position `right`, and return the reversed list.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg)\n\n```bash\nInput: head = [1,2,3,4,5], left = 2, right = 4\nOutput: [1,4,3,2,5]\n```\n\n### Example 2\n\n```bash\nInput: head = [5], left = 1, right = 1\nOutput: [5]\n```\n\n\n### Constraints:\n\n- The number of nodes in the list is n.\n- 1 <= n <= 500\n- -500 <= Node.val <= 500\n1 <= left <= right <= n","basename":"reverse-linked-list-ii"},"reverse-linked-list":{"title":"Reverse Linked List","description":"Given the head of a singly linked list, reverse the list, and return the reversed list.","tags":["neetcode","easy","linked-list"],"link":"https://leetcode.com/problems/reverse-linked-list/","images":["https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg","https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg"],"preview":"### Description\n\nGovem the `head` of a singly linked list, reverse the list, and return the reversed list.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg)\n\n```bash\nInput: head = [1,2,3,4,5]\nOutput: [5,4,3,2,1]\n```\n\n### Example 2\n\n![](https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg)\n\n```bash\nInput: head = [1,2]\nOutput: [2,1]\n```\n\n### Example 3\n\n```bash\nInput: head = []\nOutput: []\n```\n\n\n### Constraints:\n\n- The number of nodes in the list is the range [0, 5000].\n- -5000 <= Node.val <= 5000","basename":"reverse-linked-list"},"reverse-nodes-in-k-group":{"title":"Reverse Nodes in k-Group","description":"Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.","tags":["neetcode","hard","linked-list"],"link":"https://leetcode.com/problems/reverse-nodes-in-k-group/","preview":"### Description\n\nGiven the `head` of a linked list, reverse the nodes of the list `k` at a time, and return the modified list.\n\n`k` is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of `k` then left-out nodes, in the end, should remain as it is.\n\nYou may not alter the values in the list's nodes, only nodes themselves may be changed.\n\n### Example 1\n\n```bash\nInput: head = [1,2,3,4,5], k = 2\nOutput: [2,1,4,3,5]\n```\n\n### Example 2\n\n```bash\nInput: head = [1,2,3,4,5], k = 3\nOutput: [3,2,1,4,5]\n```\n\n### Constraints:\n\n- The number of nodes in the list is n. \n- 1 <= k <= n <= 5000 \n- 0 <= Node.val <= 1000","basename":"reverse-nodes-in-k-group"},"rotate-image":{"title":"Rotate Image","description":"You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).  You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.","tags":["neetcode","medium","math","neetcode","geometry"],"link":"https://leetcode.com/problems/rotate-image/","images":["https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg","https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg"],"hints":["https://wiki.anviltech.net/images/Setzero.jpeg"],"preview":"### Description\n\nYou are given an `n x n` 2D `matrix` representing an image, rotate the image by **90** degrees (clockwise).\n\nYou have to rotate the image in-place, which means you have to modify the input 2D matrix directly. **DO NOT **allocate another 2D matrix and do the rotation.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg)\n\n```bash\nInput: matrix = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [[7,4,1],[8,5,2],[9,6,3]]\n```\n\n### Example 2\n\n![](https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg)\n\n```bash\nInput: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\nOutput: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n```\n\n### Constraints:\n\n- n == matrix.length == matrix[i].length\n- 1 <= n <= 20\n- -1000 <= matrix[i][j] <= 1000","basename":"rotate-image"},"rotate-list":{"title":"Rotate List","description":"Given the head of a linked list, rotate the list to the right by k places.","tags":["linked-list","medium"],"link":"https://leetcode.com/problems/rotate-list","images":[],"preview":"### Description\n\nGiven the head of a linked list, rotate the list to the right by k places.\n\n### Example 1\n\n```bash\nInput: head = [1,2,3,4,5], k = 2\nOutput: [4,5,1,2,3]\n```\n\n### Example 2\n\n```bash\nInput: head = [0,1,2], k = 4\nOutput: [2,0,1]\n```\n\n### Constraints:\n\n- The number of nodes in the list is in the range [0, 500].\n- -100 <= Node.val <= 100\n- 0 <= k <= 2 * 109","basename":"rotate-list"},"rotting-oranges":{"title":"Rotting Oranges","description":"Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1.","tags":["neetcode","medium","graphs"],"link":"https://leetcode.com/problems/rotting-oranges/","images":["https://assets.leetcode.com/uploads/2019/02/16/oranges.png"],"preview":"### Description\n\nYou are given an m x n grid where each cell can have one of three values:\n\n- 0 representing an empty cell,\n- 1 representing a fresh orange, or\n- 2 representing a rotten orange.\n\nEvery minute, any fresh orange that is **4-directionally** adjacent to a rotten orange becomes rotten.\n\nReturn the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2019/02/16/oranges.png)\n\n```bash\nInput: grid = [[2,1,1],[1,1,0],[0,1,1]]\nOutput: 4\n```\n\n### Example 2\n\n```bash\nInput: grid = [[2,1,1],[0,1,1],[1,0,1]]\nOutput: -1\nExplanation: The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally.\n```\n\n### Example 3\n\n```bash\nInput: grid = [[0,2]]\nOutput: 0\nExplanation: Since there are already no fresh oranges at minute 0, the answer is just 0.\n```\n\n### Constraints:\n\n- m == grid.length \n- n == grid[i].length\n- 1 <= m, n <= 10 \n- grid[i][j] is 0, 1, or 2.","basename":"rotting-oranges"},"russian-doll-envelopes":{"title":"Russian Doll Envelopes","description":"You are given a 2D array of integers envelopes where envelopes[i] = [wi, hi] represents the width and the height of an envelope.","tags":["hard","dp","longest-increasing-subsequence"],"link":"https://leetcode.com/problems/russian-doll-envelope","images":[],"preview":"### Description\n\nYou are given a 2D array of integers envelopes where envelopes[i] = [wi, hi] represents the width and the height of an envelope.\n\nOne envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope's width and height.\n\nReturn the maximum number of envelopes you can Russian doll (i.e., put one inside the other).\n\nNote: You cannot rotate an envelope.\n\n### Example 1\n\n```bash\nInput: envelopes = [[5,4],[6,4],[6,7],[2,3]]\nOutput: 3\nExplanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] => [5,4] => [6,7]).\n```\n\n### Example 2\n\n```bash\nInput: envelopes = [[1,1],[1,1],[1,1]]\nOutput: 1\n```\n\n### Constraints:\n\n- 1 <= envelopes.length <= 105\n- envelopes[i].length == 2\n- 1 <= wi, hi <= 105","basename":"russian-doll-envelopes"},"same-bsts":{"title":"Same BSTs","description":"Same BSTs","tags":["hard","algoexpert"],"link":null,"images":[],"preview":"# Same BSTs\n\nAn array of integers is said to represent the Binary Search Tree (BST) obtained by inserting each integer in the array, from left to right, into the BST.\n\nWrite a function that takes in two arrays of integers and determines whether these arrays represent the same BST. Note that you're not allowed to construct any BSTs in your code.\n\nA BST is a Binary Tree that consists only of BST nodes. A node is said to be a valid BST node if and only if it satisfies the BST property: its value is strictly greater than the values of every node to its left; its value is less than or equal to the values of every node to its right; and its children nodes are either valid BST nodes themselves or None / null.\n\n## Sample Input\n\n```\narrayOne = [10, 15, 8, 12, 94, 81, 5, 2, 11]\narrayTwo = [10, 8, 5, 15, 2, 12, 11, 94, 81]\n```\n\n## Sample Output\n\n```\ntrue // both arrays represent the BST below\n         10\n       /     \\\n      8      15\n    /       /   \\\n   5      12    94\n /       /     /\n2       11    81\n\n```\n\n### Hints\n\nHint 1\n> You can immediately conclude that the input arrays don't represent the same BST if their first values aren't equal to each other, since their first values represent the root of the BST. Similarly, you can conclude this if their lengths are different. If their first values are equal to each other and their lengths are the same, what should your next step be?\n\nHint 2\n> Given an array of integers, all of the values in the array that are smaller than the first value in the array are located in the left subtree of the BST that the array represents, and all of the values in the array that are greater than or equal to the first value in the array are located in the right subtree of the BST that the array represents. Use this fact and Hint #1 to recursively determine whether all subtrees in the BSTs represented by the arrays are equal to each other.\n\nHint 3\n> Write a recursive function that takes in two arrays of integers. If the first values of the arrays aren't equal to each other or if the arrays don't have the same length, the arrays don't represent the same BST. If the first values and lengths are equal to each other, respectively, perform the following actions on both arrays: gather all integers that are smaller than the first integer; these form a new array that represents the left subtree of the relevant BST; gather all integers that are greater than or equal to the first integer; these form a new array that represents the right subtree of the relevant BST. Call the recursive function twice: once with the two left-subtree arrays and once with the two right-subtree arrays.\n\nHint 4\n> Do you actually need to create all of the auxiliary arrays mentioned in Hint #3?\n\n```\nOptimal Space & Time Complexity\nO(n^2) time | O(d) space - where n is the number of nodes in each array, respectively, and d is the depth of the BST that they represent\n```","basename":"same-bsts"},"same-tree":{"title":"Same Tree","description":"Given the roots of two binary trees p and q, write a function to check if they are the same or not.","tags":["neetcode","easy","binary-tree"],"link":"https://leetcode.com/problems/same-tree/","images":["https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg","https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg","https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg"],"preview":"### Description\n\nGiven the roots of two binary trees p and q, write a function to check if they are the same or not.\n\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg)\n\n```bash\nInput: p = [1,2,3], q = [1,2,3]\nOutput: true\n```\n\n### Example 2\n\n![](https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg)\n\n\n```bash\nInput: p = [1,2], q = [1,null,2]\nOutput: false\n```\n\n### Example 3\n\n![](https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg)\n\n```bash\nInput: p = [1,2,1], q = [1,1,2]\nOutput: false\n```\n\n### Constraints:\n\n- The number of nodes in both trees is in the range [0, 100]. \n- -10^4 <= Node.val <= 10^4","basename":"same-tree"},"satisfiability-of-equality-equations":{"title":"Satisfiability of Equality Equations","description":"Return true if it is possible to assign integers to variable names so as to satisfy all the given equations, or false otherwise.","tags":["medium","graph","union-find"],"link":"https://leetcode.com/problems/satisfiability-of-equality-equations/","images":[],"preview":"### Description\n\nYou are given an array of strings equations that represent relationships between variables where each string equations[i] is of length 4 and takes one of two different forms: \"xi==yi\" or \"xi!=yi\".Here, xi and yi are lowercase letters (not necessarily different) that represent one-letter variable names.\n\nReturn true if it is possible to assign integers to variable names so as to satisfy all the given equations, or false otherwise.\n\n\n\n### Example 1\n\n```bash\nInput: equations = [\"a==b\",\"b!=a\"]\nOutput: false\nExplanation: If we assign say, a = 1 and b = 1, then the first equation is satisfied, but not the second.\nThere is no way to assign the variables to satisfy both equations.\n```\n\n### Example 2\n\n```bash\nInput: equations = [\"b==a\",\"a==b\"]\nOutput: true\nExplanation: We could assign a = 1 and b = 1 to satisfy both equations.\n```\n\n### Constraints:\n\n- 1 <= equations.length <= 500\n- equations[i].length == 4\n- equations[i][0] is a lowercase letter.\n- equations[i][1] is either '=' or '!'.\n- equations[i][2] is '='.\n- equations[i][3] is a lowercase letter.","basename":"satisfiability-of-equality-equations"},"score-of-a-string":{"title":"Score of a String","description":"Score of a String","tags":["easy","string","math"],"link":null,"images":[],"preview":"### Description\n\nYou are given a string s. The score of a string is defined as the sum of the absolute difference between the ASCII values of adjacent characters.\n\nReturn the score of s.\n\n### Example 1\n\n```bash\nInput: s = \"hello\"\n\nOutput: 13\n\nExplanation:\n\nThe ASCII values of the characters in s are: 'h' = 104, 'e' = 101, 'l' = 108, 'o' = 111. So, the score of s would be |104 - 101| + |101 - 108| + |108 - 108| + |108 - 111| = 3 + 7 + 0 + 3 = 13.\n\n```\n\n### Example 2\n\n```bash\nInput: s = \"zaz\"\n\nOutput: 50\n\nExplanation:\n\nThe ASCII values of the characters in s are: 'z' = 122, 'a' = 97. So, the score of s would be |122 - 97| + |97 - 122| = 25 + 25 = 50.\n\n \n```\n\n### Constraints:\n\n- 2 <= s.length <= 100\n- s consists only of lowercase English letters.","basename":"score-of-a-string"},"scramble-string":{"title":"Scramble String","description":"Given two strings s1 and s2 of the same length, return true if s2 is a scrambled string of s1, otherwise, return false.","tags":["hard","grand-dp","general-multi-d"],"link":"https://leetcode.com/problems/scramble-string","images":[],"preview":"### Description\n\nWe can scramble a string s to get a string t using the following algorithm:\n\nIf the length of the string is 1, stop.\nIf the length of the string is > 1, do the following:\n\n- Split the string into two non-empty substrings at a random index, i.e., if the string is s, divide it to x and y where s = x + y.\n- Randomly decide to swap the two substrings or to keep them in the same order. i.e., after this step, s may become s = x + y or s = y + x.\n- Apply step 1 recursively on each of the two substrings x and y.\n\nGiven two strings s1 and s2 of the same length, return true if s2 is a scrambled string of s1, otherwise, return false.\n\n \n\n### Example 1\n\n```bash\nInput: s1 = \"great\", s2 = \"rgeat\"\nOutput: true\nExplanation: One possible scenario applied on s1 is:\n\"great\" --> \"gr/eat\" // divide at random index.\n\"gr/eat\" --> \"gr/eat\" // random decision is not to swap the two substrings and keep them in order.\n\"gr/eat\" --> \"g/r / e/at\" // apply the same algorithm recursively on both substrings. divide at random index each of them.\n\"g/r / e/at\" --> \"r/g / e/at\" // random decision was to swap the first substring and to keep the second substring in the same order.\n\"r/g / e/at\" --> \"r/g / e/ a/t\" // again apply the algorithm recursively, divide \"at\" to \"a/t\".\n\"r/g / e/ a/t\" --> \"r/g / e/ a/t\" // random decision is to keep both substrings in the same order.\nThe algorithm stops now, and the result string is \"rgeat\" which is s2.\nAs one possible scenario led s1 to be scrambled to s2, we return true.\n```\n\n### Example 2\n\n```bash\nInput: s1 = \"abcde\", s2 = \"caebd\"\nOutput: false\n```\n\n### Example 3\n\n```bash\nInput: s1 = \"a\", s2 = \"a\"\nOutput: true\n```\n\n### Constraints:\n\n- s1.length == s2.length\n- 1 <= s1.length <= 30\n- s1 and s2 consist of lowercase English letters.","basename":"scramble-string"},"search-a-2d-matrix":{"title":"Search a 2D Matrix","description":"You must write a solution in O(log(m * n)) time complexity.","tags":["medium","binary-search"],"link":"https://leetcode.com/problems/search-a-2d-matrix","images":[],"preview":"### Description\n\nYou are given an m x n integer matrix matrix with the following two properties:\n\nEach row is sorted in non-decreasing order.\nThe first integer of each row is greater than the last integer of the previous row.\nGiven an integer target, return true if target is in matrix or false otherwise.\n\nYou must write a solution in O(log(m * n)) time complexity.\n\n\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2020/10/05/mat.jpg)\n\n```bash\nInput: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\nOutput: true\n```\n\n### Example 2\n\n![](https://assets.leetcode.com/uploads/2020/10/05/mat2.jpg)\n\n```bash\nInput: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13\nOutput: false\n```\n\n### Constraints:\n\n- m == matrix.length\n- n == matrix[i].length\n- 1 <= m, n <= 100\n- -104 <= matrix[i][j], target <= 104","basename":"search-a-2d-matrix"},"search-insert-position":{"title":"Search Insert Position","description":"https://leetcode.com/problems/search-insert-position","tags":["binary-search","easy"],"link":"https://leetcode.com/problems/search-insert-position","images":[],"preview":"### Description\n\nGiven a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n\nYou must write an algorithm with O(log n) runtime complexity.\n\n### Example 1\n\n```bash\nInput: nums = [1,3,5,6], target = 5\nOutput: 2\n```\n\n### Example 2\n\n```bash\nInput: nums = [1,3,5,6], target = 2\nOutput: 1\n```\n\n### Example 3\n\n```bash\nInput: nums = [1,3,5,6], target = 7\nOutput: 4\n```\n\n\n### Constraints:\n\n- 1 <= nums.length <= 104\n- -104 <= nums[i] <= 104\n- nums contains distinct values sorted in ascending order.\n- -104 <= target <= 104","basename":"search-insert-position"},"search-matrix":{"title":"Search a 2D Matrix","description":"You are given an m x n integer matrix matrix with the following two properties","tags":["neetcode","medium","binary-search"],"link":"https://leetcode.com/problems/search-a-2d-matrix/","images":["https://assets.leetcode.com/uploads/2020/10/05/mat.jpg","https://assets.leetcode.com/uploads/2020/10/05/mat2.jpg"],"preview":"### Description\n\nYou are given an `m x n` integer matrix `matrix` with the following two properties:\n\n    Each row is sorted in non-decreasing order.\n    The first integer of each row is greater than the last integer of the previous row.\n\nGiven an integer target, return `true` if `target` is in `matrix` or `false` otherwise.\n\nYou must write a solution in `O(log(m * n))` time complexity.\n\n### Example 1\n\n![figure1](https://assets.leetcode.com/uploads/2020/10/05/mat.jpg)\n\n```bash\nInput: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\nOutput: true\n```\n\n### Example 2\n\n![figure2](https://assets.leetcode.com/uploads/2020/10/05/mat2.jpg)\n\n```bash\nInput: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13\nOutput: false\n```\n\n### Constraints:\n\n- m == matrix.length\n- n == matrix[i].length\n- 1 <= m, n <= 100\n- -104 <= matrix[i][j], target <= 104","basename":"search-matrix"},"search-rotated-array":{"title":"Search in Rotated Sorted Array","description":"Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.","tags":["neetcode","medium","binary-search"],"link":"https://leetcode.com/problems/search-in-rotated-sorted-array/","preview":"### Description\n\nThere is an integer array `nums` sorted in ascending order (with **distinct** values).\n\nPrior to being passed to your function, nums is **possibly rotated** at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].\n\nGiven the array `nums` **after** the possible rotation and an integer target, return the index of `target` if it is in `nums`, or `-1` if it is not in `nums`.\n\nYou must write an algorithm with O(log n) runtime complexity.\n\n### Example 1\n\n```bash\nInput: nums = [4,5,6,7,0,1,2], target = 0\nOutput: 4\n```\n\n### Example 2\n\n```bash\nInput: nums = [4,5,6,7,0,1,2], target = 3\nOutput: -1\n```\n\n\n### Example 3\n\n```bash\nInput: nums = [1], target = 0\nOutput: -1\n```\n\n### Constraints:\n\n-      1 <= nums.length <= 5000     \n-      -104 <= nums[i] <= 104     \n-      All values of nums are unique.     \n-      nums is an ascending array that is possibly rotated.     \n-      -104 <= target <= 104","basename":"search-rotated-array"},"serialize-and-deserialize-binary-tree":{"title":"Serialize and Deserialize Binary Tree","description":"Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.","tags":["neetcode","hard","binary-tree"],"link":"https://leetcode.com/problems/serialize-and-deserialize-binary-tree/","images":["https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg"],"hints":["https://wngnelson.com/assets/img_src/dsa/serialize.gif","https://wngnelson.com/assets/img_src/dsa/heapoperation.gif","https://wngnelson.com/assets/img_src/dsa/heapoperationsubstract.gif","https://wngnelson.com/assets/img_src/dsa/seialize_and_deserialice.gif"],"preview":"### Description\n\nSerialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\n\nDesign an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.\n\n**Clarification**: The input/output format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg)\n\n```bash\nInput: root = [1,2,3,null,null,4,5]\nOutput: [1,2,3,null,null,4,5]\n```\n\n### Example 2\n\n```bash\nInput: root = []\nOutput: []\n```\n\n### Constraints:\n\n- The number of nodes in the tree is in the range [0, 10^4]. \n- -1000 <= Node.val <= 1000","basename":"serialize-and-deserialize-binary-tree"},"set-matrix-zeroes":{"title":"Set Matrix Zeroes","description":"Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's.","tags":["neetcode","medium","math","neetcode","geometry"],"link":"https://leetcode.com/problems/set-matrix-zeroes/","images":["https://wiki.anviltech.net/images/Setzero.jpeg"],"hints":["https://assets.leetcode.com/uploads/2020/08/17/mat1.jpg","https://assets.leetcode.com/uploads/2020/08/17/mat2.jpg","https://wiki.anviltech.net/images/Setmatrixzero.gif","Use the first row and first column as a flag to indicate if a row or column should be set to zero."],"preview":"### Description\n\nGiven an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2020/08/17/mat1.jpg)\n\n```bash\nInput: matrix = [[1,1,1],[1,0,1],[1,1,1]]\nOutput: [[1,0,1],[0,0,0],[1,0,1]]\n```\n\n### Example 2\n\n![](https://assets.leetcode.com/uploads/2020/08/17/mat2.jpg)\n\n```bash\nInput: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]\nOutput: [[0,0,0,0],[0,4,5,0],[0,3,1,0]]\n```\n\n### Constraints:\n\n- m == matrix.length\n- n == matrix[0].length\n- 1 <= m, n <= 200\n- -231 <= matrix[i][j] <= 231 - 1","basename":"set-matrix-zeroes"},"shift-linked-list":{"title":"Shift Linked List","tags":["hard","algoexpert"],"preview":"# Shift Linked List\nWrite a function that takes in the head of a Singly Linked List and an integer k, shifts the list in place (i.e., doesn't create a brand new list) by k positions, and returns its new head.\n\nShifting a Linked List means moving its nodes forward or backward and wrapping them around the list where appropriate. For example, shifting a Linked List forward by one position would make its tail become the new head of the linked list.\n\nWhether nodes are moved forward or backward is determined by whether k is positive or negative.\n\nEach LinkedList node has an integer value as well as a next node pointing to the next node in the list or to None / null if it's the tail of the list.\n\nYou can assume that the input Linked List will always have at least one node; in other words, the head will never be None / null.\n\n## Sample Input\n\n```\nhead = 0 -> 1 -> 2 -> 3 -> 4 -> 5 // the head node with value 0\nk = 2\n```\n\n## Sample Output\n\n```\n4 -> 5 -> 0 -> 1 -> 2 -> 3 // the new head node with value 4\n```\n\n### Hints\n\n```\nHint 1\nPutting aside the cases where k is a negative integer, where k is 0, or where k is larger than the length of the linked list, what does shifting the linked list by k positions entail exactly?\n```\n\n```\nHint 2\nPutting aside the cases mentioned in Hint #1, shifting the linked list by k positions means moving the last k nodes in the linked list to the front of the linked list. What nodes in the linked list will you actually need to mutate?\n```\n\n```\nHint 3\nThere are four nodes that really matter in this entire process: the original tail of the linked list, which will point to the original head of the linked list, the original head of the linked list, which will be pointed to by the original tail of the linked list, the new tail of the linked list, and the new head of the linked list. Note that the new head is the node that the new tail points to in the original, unshifted linked list.\n```\n\n```\nHint 4\nYou can find the original tail of the linked list by simply traversing the linked list, starting at the original head of the linked list that you're given. You can find the new tail of the linked list by moving k positions from the original tail if k is positive (which means moving to the (lengthOfList - k)th position in the list, and you can easily count the length of the list as you traverse it to find its original tail). You can access the new head of the linked list once you've found its new tail, since it's the new tail's original next node. How will you handle the trickier values of k?\n```\n\n```\nOptimal Space & Time Complexity\nO(n) time | O(1) space - where n is the number of nodes in the Linked List\n```","basename":"shift-linked-list"},"shifted-binary-search":{"title":"Shifted Binary Search","tags":["hard","algoexpert"],"preview":"# Shifted Binary Search\n\nWrite a function that takes in a sorted array of distinct integers as well as a target integer. The caveat is that the integers in the array have been shifted by some amount; in other words, they've been moved to the left or to the right by one or more positions. For example, [1, 2, 3, 4] might have turned into [3, 4, 1, 2].\n\nThe function should use a variation of the Binary Search algorithm to determine if the target integer is contained in the array and should return its index if it is, otherwise -1.\n\nIf you're unfamiliar with Binary Search, we recommend watching the Conceptual Overview section of the Binary Search question's video explanation before starting to code.\n\n## Sample Input\n\n```\narray = [45, 61, 71, 72, 73, 0, 1, 21, 33, 37]\ntarget = 33\n```\n\n## Sample Output\n\n```\n8\n```\n\n### Hints\n\nHint 1\n> The Binary Search algorithm involves a left pointer and a right pointer and using those pointers to find the middle number in an array. Unlike with a normal sorted array however, you cannot simply find the middle number of the array and compare it to the target here, because the shift could lead you in the wrong direction. Instead, realize that whenever you find the middle number in the array, the following two scenarios are possible (assuming the middle number is not equal to the target number, in which case you're done): either the left-pointer number is smaller than or equal to the middle number, or it is bigger. Figure out a way to eliminate half of the array depending on the scenario.\n\nHint 2\n> In the scenario where the left-pointer number is smaller than or equal to the middle number, two other scenarios can arise: either the target number is smaller than the middle number and greater than or equal to the left-pointer number, or it's not. In the first scenario, the right half of the array can be eliminated; in the second scenario, the left half can be eliminated. Figure out the scenarios that can arise if the left-pointer number is greater than the middle number and apply whatever logic you come up with recursively until you find the target number or until you run out of numbers in the array.\n\nHint 3\n> Can you implement this algorithm iteratively? Are there any advantages to doing so?\n\n```\nOptimal Space & Time Complexity\nO(log(n)) time | O(1) space - where n is the length of the input array\n```\n\n![solution](image.png)\n\n### Notes\n\nThe numbers in the input array must be distinct in order for this algorithm to work all the time. The sample array in the video, which has a repeated 45, happens to work fine, but this is an exceptionnot the rule.\n\nTo understand why the numbers must be distinct, consider the following inputs:\n\n```\narray = [45, 33, 45, 45, 45]\ntarget = 33\n```\n\nWith these inputs, our first binary-search step would have the following indices:\n\n```\nleftIdx = 0 // 45\nmiddleIdx = 2 // 45\nrightIdx = 4 // 45\n```\n\nWe would then compare the left 45 to the middle 45 and conclude that the left half of the array was sorted, since 45 <= 45.\n\nThis would be incorrect, since the left subarray [45, 33, 45] clearly isn't sorted.\n\nThis would lead our algorithm down the wrong path, and our function would end up returning -1, which would be incorrect.","basename":"shifted-binary-search"},"shortest-bridge":{"title":"Shortest Bridge","description":"Return the smallest number of 0's you must flip to connect the two islands.","tags":["graph","medium","bfs"],"link":"https://leetcode.com/problems/shortest-bridge/","images":[],"preview":"### Description\n\nYou are given an `n x n` binary matrix grid where 1 represents land and 0 represents water.\n\nAn island is a 4-directionally connected group of 1's not connected to any other 1's. There are exactly two islands in grid.\n\nYou may change 0's to 1's to connect the two islands to form one island.\n\nReturn the smallest number of 0's you must flip to connect the two islands.\n\n### Example 1\n\n```bash\nInput: grid = [[0,1],[1,0]]\nOutput: 1\n```\n\n### Example 2\n\n```bash\nInput: grid = [[0,1,0],[0,0,0],[0,0,1]]\nOutput: 2\n```\n\n### Example 3\n\n```bash\nInput: grid = [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]\nOutput: 1\n```\n\n### Constraints:\n\n- n == grid.length == grid[i].length\n- 2 <= n <= 100\n- grid[i][j] is either 0 or 1.\n- There are exactly two islands in grid.","basename":"shortest-bridge"},"shortest-path-visiting-all-nodes":{"title":"Shortest Path Visiting All Nodes","description":"Return the length of the shortest path that visits every node. You may start and stop at any node, you may revisit nodes multiple times, and you may reuse edges.","tags":["hard","grand-dp","bitmasking"],"link":"https://leetcode.com/problems/shortest-path-visiting-all-nodes/","images":[],"preview":"### Description\n\nYou have an undirected, connected graph of n nodes labeled from 0 to n - 1. You are given an array graph where graph[i] is a list of all the nodes connected with node i by an edge.\n\nReturn the length of the shortest path that visits every node. You may start and stop at any node, you may revisit nodes multiple times, and you may reuse edges.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2021/05/12/shortest1-graph.jpg)\n\n```bash\nInput: graph = [[1,2,3],[0],[0],[0]]\nOutput: 4\nExplanation: One possible path is [1,0,2,0,3]\n```\n\n### Example 2\n\n![](https://assets.leetcode.com/uploads/2021/05/12/shortest2-graph.jpg)\n\n```bash\nInput: graph = [[1],[0,2,4],[1,3,4],[2],[1,2]]\nOutput: 4\nExplanation: One possible path is [0,1,4,2,3]\n```\n\n### Constraints:\n\n- n == graph.length\n- 1 <= n <= 12\n- 0 <= graph[i].length < n\n- graph[i] does not contain i.\n- If graph[a] contains b, then graph[b] contains a.\n- The input graph is always connected.","basename":"shortest-path-visiting-all-nodes"},"shortest-path-with-alternating-colors":{"title":"Shortest Path with Alternating Colors","description":"Return an array answer of length n, where each answer[x] is the length of the shortest path from node 0 to node x such that the edge colors alternate along the path, or -1 if such a path does not exist.","tags":["medium","graph","standard-traversal"],"link":"https://leetcode.com/problems/shortest-path-with-alternating-colors/","images":[],"preview":"### Description\n\nYou are given an integer n, the number of nodes in a directed graph where the nodes are labeled from 0 to n - 1. Each edge is red or blue in this graph, and there could be self-edges and parallel edges.\n\nYou are given two arrays redEdges and blueEdges where:\n\nredEdges[i] = [ai, bi] indicates that there is a directed red edge from node ai to node bi in the graph, and\nblueEdges[j] = [uj, vj] indicates that there is a directed blue edge from node uj to node vj in the graph.\nReturn an array answer of length n, where each answer[x] is the length of the shortest path from node 0 to node x such that the edge colors alternate along the path, or -1 if such a path does not exist.\n\n### Example 1\n\n```bash\nInput: n = 3, redEdges = [[0,1],[1,2]], blueEdges = []\nOutput: [0,1,-1]\n```\n\n### Example 2\n\n```bash\nInput: n = 3, redEdges = [[0,1]], blueEdges = [[2,1]]\nOutput: [0,1,-1]\n```\n\n### Constraints:\n\n- m == board.length\n- n == board[i].length\n- 1 <= m, n <= 200\n- board[i][j] is 'X' or 'O'.","basename":"shortest-path-with-alternating-colors"},"similar-string-groups":{"title":"Similar String Groups","description":"We are given a list strs of strings where every string in strs is an anagram of every other string in strs. How many groups are there?","tags":["hard","graph","union-find"],"link":"https://leetcode.com/problems/similar-string-groups","images":[],"preview":"### Description\n\nTwo strings, X and Y, are considered similar if either they are identical or we can make them equivalent by swapping at most two letters (in distinct positions) within the string X.\n\nFor example, \"tars\" and \"rats\" are similar (swapping at positions 0 and 2), and \"rats\" and \"arts\" are similar, but \"star\" is not similar to \"tars\", \"rats\", or \"arts\".\n\nTogether, these form two connected groups by similarity: {\"tars\", \"rats\", \"arts\"} and {\"star\"}.  Notice that \"tars\" and \"arts\" are in the same group even though they are not similar.  Formally, each group is such that a word is in the group if and only if it is similar to at least one other word in the group.\n\nWe are given a list strs of strings where every string in strs is an anagram of every other string in strs. How many groups are there?\n\n### Example 1\n\n```bash\nInput: strs = [\"tars\",\"rats\",\"arts\",\"star\"]\nOutput: 2\n```\n\n### Example 2\n\n```bash\nInput: strs = [\"omv\",\"ovm\"]\nOutput: 1\n```\n\n### Constraints:\n\n- 1 <= strs.length <= 300\n- 1 <= strs[i].length <= 300\n- strs[i] consists of lowercase letters only.\n- All words in strs have the same length and are anagrams of each other.","basename":"similar-string-groups"},"simple-division":{"title":"Simple Division","description":"A simple division example","tags":["neetcode","sample","neetcode"],"preview":"This is  a simple division example.\n\n```js\nimport { prompt } from 'dsa-cli';\nconst a = prompt('Enter a number: ');\nconst b = prompt('Enter another number: ');\nconsole.log(a / b);\n```\n\n```bash\n$ dsa run simple-division.js\nEnter a number: 10\n```","basename":"simple-division"},"simple-substraction":{"title":"Simple Substraction","description":"A simple substraction example","tags":["neetcode","sample","math","neetcode"],"preview":"This is  a simple substraction example.!\n\n```js\nimport { prompt } from 'dsa-cli';\nconst a = prompt('Enter a number: ');\nconst b = prompt('Enter another number: ');\nconsole.log(a - b);\n```\n\n```bash\n$ dsa run simple-substraction.js\nEnter a number: 11\nEnter another number: 5\n```","basename":"simple-substraction"},"simple-sum":{"title":"Simple Sum","description":"A simple sum example!","tags":["neetcode","sample","neetcode"],"preview":"This is  a simple sum example.\n\n```js\nimport { prompt } from 'dsa-cli';\nconst a = prompt('Enter a number: ');\nconst b = prompt('Enter another number: ');\nconsole.log(a + b);\n```\n\n```bash\n$ dsa run simple-sum.js\nEnter a number: 10\nEnter another number:\n```","basename":"simple-sum"},"simplify-path":{"title":"Simplify Path","description":"Given a string path, which is an absolute path (starting with a slash '/') to a file or directory in a Unix-style file system, convert it to the simplified canonical path.","tags":["stack","medium"],"link":"https://leetcode.com/problems/simplify-path","images":[],"preview":"### Description\n\nGiven a string path, which is an absolute path (starting with a slash '/') to a file or directory in a Unix-style file system, convert it to the simplified canonical path.\n\nIn a Unix-style file system, a period '.' refers to the current directory, a double period '..' refers to the directory up a level, and any multiple consecutive slashes (i.e. '//') are treated as a single slash '/'. For this problem, any other format of periods such as '...' are treated as file/directory names.\n\nThe canonical path should have the following format:\n\nThe path starts with a single slash '/'.\nAny two directories are separated by a single slash '/'.\nThe path does not end with a trailing '/'.\nThe path only contains the directories on the path from the root directory to the target file or directory (i.e., no period '.' or double period '..')\nReturn the simplified canonical path.\n\n\n### Example 1\n\n```bash\nInput: path = \"/home/\"\nOutput: \"/home\"\nExplanation: Note that there is no trailing slash after the last directory name.\n```\n\n### Example 2\n\n```bash\nInput: path = \"/../\"\nOutput: \"/\"\nExplanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go.\n```\n\n### Example 3\n\n```bash\nInput: path = \"/home//foo/\"\nOutput: \"/home/foo\"\nExplanation: In the canonical path, multiple consecutive slashes are replaced by a single one.\n```\n\n### Constraints:\n\n- 1 <= path.length <= 3000\n- path consists of English letters, digits, period '.', slash '/' or '_'.\n- path is a valid absolute Unix path.","basename":"simplify-path"},"single-number-ii":{"title":"Single Number II","description":"You must implement a solution with a linear runtime complexity and use only constant extra space.","tags":["medium","bit-manipulation"],"link":"https://leetcode.com/problems/single-number-ii/","images":[],"preview":"### Description\n\nGiven an integer array nums where every element appears three times except for one, which appears exactly once. Find the single element and return it.\n\nYou must implement a solution with a linear runtime complexity and use only constant extra space.\n\n### Example 1\n\n```bash\nInput: nums = [2,2,3,2]\nOutput: 3\n```\n\n### Example 2\n\n```bash\nInput: nums = [0,1,0,1,0,1,99]\nOutput: 99\n```\n\n### Constraints:\n\n- 1 <= nums.length <= 3 * 104\n- -231 <= nums[i] <= 231 - 1\n- Each element in nums appears exactly three times except for one element which appears once.","basename":"single-number-ii"},"single-number":{"title":"Single Number","description":"Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.","tags":["easy","math","neetcode"],"link":"https://leetcode.com/problems/single-number/","images":[],"preview":"### Description\n\nGiven a **non-empty** array of integers `nums`, every element appears twice except for one. Find that single one.\n\nYou must implement a solution with a linear runtime complexity and use only constant extra space.\n\n### Example 1\n\n```bash\nInput: nums = [2,2,1]\nOutput: 1\n\n```\n\n### Example 2\n\n```bash\nInput: nums = [4,1,2,1,2]\nOutput: 4\n\n```\n\n### Example 3\n\n```bash\nInput: nums = [1]\nOutput: 1\n```\n\n\n### Constraints:\n\n- 1 <= nums.length <= 3 * 104\n- -3 * 104 <= nums[i] <= 3 * 104\n- Each element in the array appears twice except for one element which appears only once.","basename":"single-number"},"smallest-sufficient-team":{"title":"Smallest Sufficient Team","description":"In a project, you have a list of required skills req_skills, and a list of people. The ith person people[i] contains a list of skills that the person has.","tags":["hard","grand-dp","bitmasking"],"link":"https://leetcode.com/problems/smallest-sufficient-team/","images":[],"preview":"### Description\n\nIn a project, you have a list of required skills req_skills, and a list of people. The ith person people[i] contains a list of skills that the person has.\n\nConsider a sufficient team: a set of people such that for every required skill in req_skills, there is at least one person in the team who has that skill. We can represent these teams by the index of each person.\n\n- For example, team = [0, 1, 3] represents the people with skills people[0], people[1], and people[3].\n\nReturn any sufficient team of the smallest possible size, represented by the index of each person. You may return the answer in any order.\n\nIt is guaranteed an answer exists.\n\n### Example 1\n\n```bash\nInput: req_skills = [\"java\",\"nodejs\",\"reactjs\"], people = [[\"java\"],[\"nodejs\"],[\"nodejs\",\"reactjs\"]]\nOutput: [0,2]\n```\n\n### Example 2\n\n```bash\nInput: req_skills = [\"algorithms\",\"math\",\"java\",\"reactjs\",\"csharp\",\"aws\"], people = [[\"algorithms\",\"math\",\"java\"],[\"algorithms\",\"math\",\"reactjs\"],[\"java\",\"csharp\",\"aws\"],[\"reactjs\",\"csharp\"],[\"csharp\",\"math\"],[\"aws\",\"java\"]]\nOutput: [1,2]\n```\n\n### Constraints:\n\n- 1 <= req_skills.length <= 16\n- 1 <= req_skills[i].length <= 16\n- req_skills[i] consists of lowercase English letters.\n- All the strings of req_skills are unique.\n- 1 <= people.length <= 60\n- 0 <= people[i].length <= 16\n- 1 <= people[i][j].length <= 16\n- people[i][j] consists of lowercase English letters.\n- All the strings of people[i] are unique.\n- Every skill in people[i] is a skill in req_skills.\n- It is guaranteed a sufficient team exists.","basename":"smallest-sufficient-team"},"snakes-and-ladders":{"title":"Snakes and Ladders","description":"Return the least number of moves required to reach the square n2. If it is not possible to reach the square, return -1.","tags":["medium","graph"],"link":"https://leetcode.com/problems/snakes-and-ladders","images":[],"preview":"### Description\n\nYou are given an n x n integer matrix board where the cells are labeled from 1 to n2 in a Boustrophedon style starting from the bottom left of the board (i.e. board[n - 1][0]) and alternating direction each row.\n\nYou start on square 1 of the board. In each move, starting from square curr, do the following:\n\nChoose a destination square next with a label in the range [curr + 1, min(curr + 6, n2)].\nThis choice simulates the result of a standard 6-sided die roll: i.e., there are always at most 6 destinations, regardless of the size of the board.\nIf next has a snake or ladder, you must move to the destination of that snake or ladder. Otherwise, you move to next.\nThe game ends when you reach the square n2.\nA board square on row r and column c has a snake or ladder if board[r][c] != -1. The destination of that snake or ladder is board[r][c]. Squares 1 and n2 do not have a snake or ladder.\n\nNote that you only take a snake or ladder at most once per move. If the destination to a snake or ladder is the start of another snake or ladder, you do not follow the subsequent snake or ladder.\n\nFor example, suppose the board is [[-1,4],[-1,3]], and on the first move, your destination square is 2. You follow the ladder to square 3, but do not follow the subsequent ladder to 4.\nReturn the least number of moves required to reach the square n2. If it is not possible to reach the square, return -1.\n\n### Example 1\n\n```bash\nInput: board = [[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,35,-1,-1,13,-1],[-1,-1,-1,-1,-1,-1],[-1,15,-1,-1,-1,-1]]\nOutput: 4\nExplanation: \nIn the beginning, you start at square 1 (at row 5, column 0).\nYou decide to move to square 2 and must take the ladder to square 15.\nYou then decide to move to square 17 and must take the snake to square 13.\nYou then decide to move to square 14 and must take the ladder to square 35.\nYou then decide to move to square 36, ending the game.\nThis is the lowest possible number of moves to reach the last square, so return 4.\n```\n\n### Example 2\n\n```bash\nInput: board = [[-1,-1],[-1,3]]\nOutput: 1\n```\n\n### Constraints:\n\n- n == board.length == board[i].length\n- 2 <= n <= 20\n- board[i][j] is either -1 or in the range [1, n2].\n- The squares labeled 1 and n2 do not have any ladders or snakes.","basename":"snakes-and-ladders"},"solve-sudoku":{"title":"Solve Sudoku","tags":["hard","algoexpert"],"preview":"# Solve Sudoku\n\nYou're given a two-dimensional array that represents a 9x9 partially filled Sudoku board. Write a function that returns the solved Sudoku board.\n\nSudoku is a famous number-placement puzzle in which you need to fill a 9x9 grid with integers in the range of 1-9. Each 9x9 Sudoku board is split into 9 3x3 subgrids, as seen in the illustration below, and starts out partially filled.\n\n``` \n- - 3 | - 2 - | 6 - - \n9 - - | 3 - 5 | - - 1 \n- - 1 | 8 - 6 | 4 - -\n- - - - - - - - - - - \n- - 8 | 1 - 2 | 9 - -\n7 - - | - - - | - - 8 \n- - 6 | 7 - 8 | 2 - -\n- - - - - - - - - - -\n- - 2 | 6 - 9 | 5 - - \n8 - - | 2 - 3 | - - 9\n- - 5 | - 1 - | 3 - -\n```\n\nThe objective is to fill the grid such that each row, column, and 3x3 subgrid contains the numbers 1-9 exactly once. In other words, no row may contain the same digit more than once, no column may contain the same digit more than once, and none of the 9 3x3 subgrids may contain the same digit more than once.\n\nYour input for this problem will always be a partially filled 9x9 two-dimensional array that represents a solvable Sudoku puzzle. Every element in the array will be an integer in the range of 0-9, where a 0 represents an empty square that must be filled by your algorithm.\n\nNote that you may modify the input array and that there will always be exactly one solution to each input Sudoku board.\n\n## Sample Input\n```\nboard =\n    [\n        [7, 8, 0, 4, 0, 0, 1, 2, 0],\n        [6, 0, 0, 0, 7, 5, 0, 0, 9],\n        [0, 0, 0, 6, 0, 1, 0, 7, 8],\n        [0, 0, 7, 0, 4, 0, 2, 6, 0],\n        [0, 0, 1, 0, 5, 0, 9, 3, 0],\n        [9, 0, 4, 0, 6, 0, 0, 0, 5],\n        [0, 7, 0, 3, 0, 0, 0, 1, 2],\n        [1, 2, 0, 0, 0, 7, 4, 0, 0],\n        [0, 4, 9, 2, 0, 6, 0, 0, 7],\n    ]\n```\n## Sample Output\n\n```\n[\n    [7, 8, 5, 4, 3, 9, 1, 2, 6],\n    [6, 1, 2, 8, 7, 5, 3, 4, 9],\n    [4, 9, 3, 6, 2, 1, 5, 7, 8],\n    [8, 5, 7, 9, 4, 3, 2, 6, 1],\n    [2, 6, 1, 7, 5, 8, 9, 3, 4],\n    [9, 3, 4, 1, 6, 2, 7, 8, 5],\n    [5, 7, 8, 3, 9, 4, 6, 1, 2],\n    [1, 2, 6, 5, 8, 7, 4, 9, 3],\n    [3, 4, 9, 2, 1, 6, 8, 5, 7],\n]\n```\n\n### Hints\n\nHint 1\n> The brute-force approach to this problem is to generate every possible Sudoku board and to check each one until you find one that's valid. The issue with this approach is that there are 9^81 possible 9x9 Sudoku boards. This is an extremely large number, which makes it practically impossible to take this approach. How can you avoid generating every possible Sudoku board?\n\nHint 2\n> Keep in mind that a Sudoku board doesn't need to be entirely filled to figure out if it's invalid and won't lead to a solution. Try generating partially filled Sudoku boards until they become invalid, thereby abandoning solutions that will never lead to a properly solved board.\n\nHint 3\n> The method described in Hint #2 is more formally known as backtracking. This involves attempting to place digits into empty positions in the Sudoku board and checking at each insertion if that newly inserted digit makes the Sudoku board invalid. If it does, then you try to insert another digit until you find one that doesn't invalidate the board. If it doesn't invalidate the board, you temporarily place that digit and continue to try to solve the rest of the board. If you ever reach a position where there are no valid digits to be inserted (every digit placed in that position leads to an invalid board), that means that one of the previously inserted digits is incorrect. Thus, you must backtrack and change previously placed digits. For more details on this approach, refer to the Conceptual Overview section of this question's video explanation.\n\n```\nOptimal Space & Time Complexity\nO(1) time | O(1) space - assuming a 9x9 input board\n```","basename":"solve-sudoku"},"solving-questions-with-brainpower":{"title":"Solve Questions with Brainpower","description":"You are given a 0-indexed 2D integer array questions where questions[i] = [pointsi, brainpoweri].","tags":["medium","general-1d","dp"],"link":"https://leetcode.com/problems/solving-questions-with-brainpower","images":[],"preview":"### Description\n\nYou are given a 0-indexed 2D integer array questions where questions[i] = [pointsi, brainpoweri].\n\nThe array describes the questions of an exam, where you have to process the questions in order (i.e., starting from question 0) and make a decision whether to solve or skip each question. Solving question i will earn you pointsi points but you will be unable to solve each of the next brainpoweri questions. If you skip question i, you get to make the decision on the next question.\n\nFor example, given questions = [[3, 2], [4, 3], [4, 4], [2, 5]]:\nIf question 0 is solved, you will earn 3 points but you will be unable to solve questions 1 and 2.\nIf instead, question 0 is skipped and question 1 is solved, you will earn 4 points but you will be unable to solve questions 2 and 3.\nReturn the maximum points you can earn for the exam.\n\n### Example 1\n\n```bash\nInput: questions = [[3,2],[4,3],[4,4],[2,5]]\nOutput: 5\nExplanation: The maximum points can be earned by solving questions 0 and 3.\n- Solve question 0: Earn 3 points, will be unable to solve the next 2 questions\n- Unable to solve questions 1 and 2\n- Solve question 3: Earn 2 points\nTotal points earned: 3 + 2 = 5. There is no other way to earn 5 or more points.\n```\n\n### Example 2\n\n```bash\nInput: questions = [[1,1],[2,2],[3,3],[4,4],[5,5]]\nOutput: 7\nExplanation: The maximum points can be earned by solving questions 1 and 4.\n- Skip question 0\n- Solve question 1: Earn 2 points, will be unable to solve the next 2 questions\n- Unable to solve questions 2 and 3\n- Solve question 4: Earn 5 points\nTotal points earned: 2 + 5 = 7. There is no other way to earn 7 or more points.\n```\n\n### Constraints:\n\n- 1 <= questions.length <= 105\n- questions[i].length == 2\n- 1 <= pointsi, brainpoweri <= 105","basename":"solving-questions-with-brainpower"},"sort-items-by-groups-respecting-dependencies":{"title":"Sort Items by Groups Respecting Dependencies","description":"Return any solution if there is more than one solution and return an empty list if there is no solution.","tags":["hard","graph","topological-sort"],"link":"https://leetcode.com/problems/sort-items-by-groups-respecting-dependencies/","images":[],"preview":"There are n items each belonging to zero or one of m groups where group[i] is the group that the i-th item belongs to and it's equal to -1 if the i-th item belongs to no group. The items and the groups are zero indexed. A group can have no item belonging to it.\n\nReturn a sorted list of the items such that:\n\nThe items that belong to the same group are next to each other in the sorted list.\nThere are some relations between these items where beforeItems[i] is a list containing all the items that should come before the i-th item in the sorted array (to the left of the i-th item).\nReturn any solution if there is more than one solution and return an empty list if there is no solution.\n\n### Example 1\n\n```bash\nInput: n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3,6],[],[],[]]\nOutput: [6,3,4,1,5,2,0,7]\n```\n\n### Example 2\n\n```bash\nInput: n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3],[],[4],[]]\nOutput: []\nExplanation: This is the same as example 1 except that 4 needs to be before 6 in the sorted list.\n```\n\n\n### Constraints:\n\n- 1 <= m <= n <= 3 * 104\n- group.length == beforeItems.length == n\n- -1 <= group[i] <= m - 1\n- 0 <= beforeItems[i].length <= n - 1\n- 0 <= beforeItems[i][j] <= n - 1\n- i != beforeItems[i][j]\n- beforeItems[i] does not contain duplicates elements.","basename":"sort-items-by-groups-respecting-dependencies"},"sort-list":{"title":"Sort List","description":"https://leetcode.com/problems/sort-list","tags":["divide-and-conquer","medium"],"link":"https://leetcode.com/problems/sort-list","images":["https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg"],"preview":"### Description\n\n\nGiven the head of a linked list, return the list after sorting it in ascending order.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg)\n\n```bash\nInput: head = [4,2,1,3]\nOutput: [1,2,3,4]\n```\n\n### Example 2\n\n![](https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg)\n\n```bash\nInput: head = [-1,5,3,4,0]\nOutput: [-1,0,3,4,5]\n```\n\n### Constraints:\n\n- The number of nodes in the list is in the range [0, 5 * 104].\n- -105 <= Node.val <= 105","basename":"sort-list"},"soup-servings":{"title":"Soup Servings","description":"Return the probability that soup A will be empty first, plus half the probability that A and B become empty at the same time. Answers within 10-5 of the actual answer will be accepted.","tags":[],"link":null,"images":[],"preview":"### Description\n\nThere are two types of soup: type A and type B. Initially, we have n ml of each type of soup. There are four kinds of operations:\n\n- Serve 100 ml of soup A and 0 ml of soup B,\n- Serve 75 ml of soup A and 25 ml of soup B,\n- Serve 50 ml of soup A and 50 ml of soup B, and\n- Serve 25 ml of soup A and 75 ml of soup B.\n\n\nWhen we serve some soup, we give it to someone, and we no longer have it. Each turn, we will choose from the four operations with an equal probability 0.25. If the remaining volume of soup is not enough to complete the operation, we will serve as much as possible. We stop once we no longer have some quantity of both types of soup.\n\nNote that we do not have an operation where all 100 ml's of soup B are used first.\n\nReturn the probability that soup A will be empty first, plus half the probability that A and B become empty at the same time. Answers within 10-5 of the actual answer will be accepted.\n\n### Example 1\n\n```bash\nInput: n = 50\nOutput: 0.62500\nExplanation: If we choose the first two operations, A will become empty first.\nFor the third operation, A and B will become empty at the same time.\nFor the fourth operation, B will become empty first.\nSo the total probability of A becoming empty first plus half the probability that A and B become empty at the same time, is 0.25 * (1 + 1 + 0.5 + 0) = 0.625.\n```\n\n### Example 2\n\n```bash\nInput: n = 100\nOutput: 0.71875\n```\n\n### Constraints:\n\n- 0 <= n <= 10^9","basename":"soup-servings"},"spiral-matrix":{"title":"Spiral Matrix","description":"Given an m x n matrix, return all elements of the matrix in spiral order.","tags":["neetcode","medium","math","neetcode","geometry"],"link":"https://leetcode.com/problems/spiral-matrix/","images":[],"preview":"### Description\n\nGiven an `m x n` matrix, return all elements of the matrix in spiral order.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg)\n\n```bash\nInput: matrix = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [1,2,3,6,9,8,7,4,5]\n```\n\n### Example 2\n\n![](https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg)\n\n```bash\nInput: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\nOutput: [1,2,3,4,8,12,11,10,9,5,6,7]\n```\n\n### Constraints:\n\n- m == matrix.length\n- n == matrix[i].length\n- 1 <= m, n <= 10\n- -100 <= matrix[i][j] <= 100","basename":"spiral-matrix"},"sqrtx":{"title":"Sqrt(x)","description":"Given a non-negative integer x, return the square root of x rounded down to the nearest integer. The returned integer should be non-negative as well.","tags":["easy","math"],"link":"https://leetcode.com/problems/sqrtx","images":[],"preview":"### Description\n\nGiven a non-negative integer x, return the square root of x rounded down to the nearest integer. The returned integer should be non-negative as well.\n\nYou must not use any built-in exponent function or operator.\n\nFor example, do not use pow(x, 0.5) in c++ or x ** 0.5 in python.\n \n\n### Example 1\n\n```bash\nInput: x = 4\nOutput: 2\nExplanation: The square root of 4 is 2, so we return 2.\n```\n\n### Example 2\n\n```bash\nInput: x = 8\nOutput: 2\nExplanation: The square root of 8 is 2.82842..., and since we round it down to the nearest integer, 2 is returned.\n```\n\n### Constraints:\n\n- 0 <= x <= 2^31 - 1","basename":"sqrtx"},"squirrel-simulation":{"title":"Squirrel Simulation","description":"Return the minimal distance for the squirrel to collect all the nuts and put them under the tree one by one.","tags":["medium","weekly-contest","greedy"],"link":"https://leetcode.com/problems/squirrel-simulation","images":[],"preview":"### Description\n\nYou are given two integers height and width representing a garden of size height x width. You are also given:\n\nan array tree where tree = [treer, treec] is the position of the tree in the garden,\nan array squirrel where squirrel = [squirrelr, squirrelc] is the position of the squirrel in the garden,\nand an array nuts where nuts[i] = [nutir, nutic] is the position of the ith nut in the garden.\nThe squirrel can only take at most one nut at one time and can move in four directions: up, down, left, and right, to the adjacent cell.\n\nReturn the minimal distance for the squirrel to collect all the nuts and put them under the tree one by one.\n\nThe distance is the number of moves.\n\n\n### Example 1\n\n```bash\nInput: height = 5, width = 7, tree = [2,2], squirrel = [4,4], nuts = [[3,0], [2,5]]\nOutput: 12\nExplanation: The squirrel should go to the nut at [2, 5] first to achieve a minimal distance.\n```\n\n![](https://assets.leetcode.com/uploads/2021/04/24/squirrel1-grid.jpg)\n\n\n### Example 2\n\n```bash\nInput: height = 1, width = 3, tree = [0,1], squirrel = [0,0], nuts = [[0,2]]\nOutput: 3\n```\n\n![](https://assets.leetcode.com/uploads/2021/04/24/squirrel2-grid.jpg)\n\n### Constraints:\n\n- 1 <= height, width <= 100\n- tree.length == 2\n- squirrel.length == 2\n- 1 <= nuts.length <= 5000\n- nuts[i].length == 2\n- 0 <= treer, squirrelr, nutir <= height\n- 0 <= treec, squirrelc, nutic <= width","basename":"squirrel-simulation"},"stone-game-ii":{"title":"Stone Game II","description":"Alice and Bob continue their games with piles of stones.  There are a number of piles arranged in a row, and each pile has a positive integer number of stones piles[i].  The objective of the game is to end with the most stones.","tags":[],"link":null,"images":[],"preview":"### Description\n\nAlice and Bob continue their games with piles of stones.  There are a number of piles arranged in a row, and each pile has a positive integer number of stones piles[i].  The objective of the game is to end with the most stones. \n\nAlice and Bob take turns, with Alice starting first.  Initially, M = 1.\n\nOn each player's turn, that player can take all the stones in the first X remaining piles, where 1 <= X <= 2M.  Then, we set M = max(M, X).\n\nThe game continues until all the stones have been taken.\n\nAssuming Alice and Bob play optimally, return the maximum number of stones Alice can get.\n\n### Example 1\n\n```bash\nInput: piles = [2,7,9,4,4]\nOutput: 10\nExplanation:  If Alice takes one pile at the beginning, Bob takes two piles, then Alice takes 2 piles again. Alice can get 2 + 4 + 4 = 10 piles in total. If Alice takes two piles at the beginning, then Bob can take all three piles left. In this case, Alice get 2 + 7 = 9 piles in total. So we return 10 since it's larger. \n```\n\n### Example 2\n\n```bash\nInput: piles = [1,2,3,4,5,100]\nOutput: 104\n```\n\n### Constraints:\n\n- 1 <= piles.length <= 100\n- 1 <= piles[i] <= 104","basename":"stone-game-ii"},"stone-game-iii":{"title":"Stone Games III","description":"Alice and Bob continue their games with piles of stones. There are several stones arranged in a row, and each stone has an associated value which is an integer given in the array stoneValue.","tags":[],"link":null,"images":[],"preview":"### Description\n\nAlice and Bob continue their games with piles of stones. There are several stones arranged in a row, and each stone has an associated value which is an integer given in the array stoneValue.\n\nAlice and Bob take turns, with Alice starting first. On each player's turn, that player can take 1, 2, or 3 stones from the first remaining stones in the row.\n\nThe score of each player is the sum of the values of the stones taken. The score of each player is 0 initially.\n\nThe objective of the game is to end with the highest score, and the winner is the player with the highest score and there could be a tie. The game continues until all the stones have been taken.\n\nAssume Alice and Bob play optimally.\n\nReturn \"Alice\" if Alice will win, \"Bob\" if Bob will win, or \"Tie\" if they will end the game with the same score.\n\n### Example 1\n\n```bash\nInput: stoneValue = [1,2,3,7]\nOutput: \"Bob\"\nExplanation: Alice will always lose. Her best move will be to take three piles and the score become 6. Now the score of Bob is 7 and Bob wins.\n```\n\n### Example 2\n\n```bash\nInput: stoneValue = [1,2,3,-9]\nOutput: \"Alice\"\nExplanation: Alice must choose all the three piles at the first move to win and leave Bob with negative score.\nIf Alice chooses one pile her score will be 1 and the next move Bob's score becomes 5. In the next move, Alice will take the pile with value = -9 and lose.\nIf Alice chooses two piles her score will be 3 and the next move Bob's score becomes 3. In the next move, Alice will take the pile with value = -9 and also lose.\nRemember that both play optimally so here Alice will choose the scenario that makes her win.\n```\n\n### Example 3\n\n```bash\nInput: stoneValue = [1,2,3,6]\nOutput: \"Tie\"\nExplanation: Alice cannot win this game. She can end the game in a draw if she decided to choose all the first three piles, otherwise she will lose.\n```\n\n### Constraints:\n\n- 1 <= stoneValue.length <= 5 * 104\n- -1000 <= stoneValue[i] <= 1000\n-","basename":"stone-game-iii"},"stone-game-iv":{"title":"Stone Game IV","description":"Alice and Bob take turns playing a game, with Alice starting first.","tags":["hard","grand-dp","game-theory"],"link":"https://leetcode.com/problems/stone-game-iv/","images":[],"preview":"### Description\n\nAlice and Bob take turns playing a game, with Alice starting first.\n\nInitially, there are n stones in a pile. On each player's turn, that player makes a move consisting of removing any non-zero square number of stones in the pile.\n\nAlso, if a player cannot make a move, he/she loses the game.\n\nGiven a positive integer n, return true if and only if Alice wins the game otherwise return false, assuming both players play optimally.\n\n \n\n### Example 1\n\n```bash\nInput: n = 1\nOutput: true\nExplanation: Alice can remove 1 stone winning the game because Bob doesn't have any moves.\n```\n\n### Example 2\n\n```bash\nInput: n = 2\nOutput: false\nExplanation: Alice can only remove 1 stone, after that Bob removes the last one winning the game (2 -> 1 -> 0).\n```\n\n### Example 3\n\n```bash\nInput: n = 4\nOutput: true\nExplanation: n is already a perfect square, Alice can win with one move, removing 4 stones (4 -> 0).\n```\n\n### Constraints:\n\n- 1 <= n <= 10^5","basename":"stone-game-iv"},"stone-game":{"title":"Stone Game","description":"Alice and Bob play a game with piles of stones. There are an even number of piles arranged in a row, and each pile has a positive integer number of stones piles[i].","tags":["medium","grand-dp","game-theory"],"link":"https://leetcode.com/problems/stone-game","images":[],"preview":"### Description\n\nAlice and Bob play a game with piles of stones. There are an even number of piles arranged in a row, and each pile has a positive integer number of stones piles[i].\n\nThe objective of the game is to end with the most stones. The total number of stones across all the piles is odd, so there are no ties.\n\nAlice and Bob take turns, with Alice starting first. Each turn, a player takes the entire pile of stones either from the beginning or from the end of the row. This continues until there are no more piles left, at which point the person with the most stones wins.\n\nAssuming Alice and Bob play optimally, return true if Alice wins the game, or false if Bob wins.\n\n### Example 1\n\n```bash\nInput: piles = [5,3,4,5]\nOutput: true\nExplanation: \nAlice starts first, and can only take the first 5 or the last 5.\nSay she takes the first 5, so that the row becomes [3, 4, 5].\nIf Bob takes 3, then the board is [4, 5], and Alice takes 5 to win with 10 points.\nIf Bob takes the last 5, then the board is [3, 4], and Alice takes 4 to win with 9 points.\nThis demonstrated that taking the first 5 was a winning move for Alice, so we return true.\n```\n\n### Example 2\n\n```bash\nInput: piles = [3,7,2,3]\nOutput: true\n```\n\n### Constraints:\n\n- 2 <= piles.length <= 500\n- piles.length is even.\n- 1 <= piles[i] <= 500\n- sum(piles[i]) is odd.","basename":"stone-game"},"strange-printer":{"title":"Strange Printer","description":"Given a string s, return the minimum number of turns the printer needed to print it.","tags":["hard","grand-dp","general-multi-d"],"link":"https://leetcode.com/problems/strange-printer","images":[],"preview":"### Description\n\nThere is a strange printer with the following two special properties:\n\n- The printer can only print a sequence of the same character each time.\n- At each turn, the printer can print new characters starting from and ending at any place and will cover the original existing characters.\n\nGiven a string s, return the minimum number of turns the printer needed to print it.\n\n \n\n### Example 1\n\n```bash\nInput: s = \"aaabbb\"\nOutput: 2\nExplanation: Print \"aaa\" first and then print \"bbb\".\n```\n\n### Example 2\n\n```bash\nInput: s = \"aba\"\nOutput: 2\nExplanation: Print \"aaa\" first and then print \"b\" from the second place of the string, which will cover the existing character 'a'.\n```\n\n### Constraints:\n\n- 1 <= s.length <= 100\n- s consists of lowercase English letters.","basename":"strange-printer"},"subarray-sort":{"title":"Subarray Sort","description":"Subarray sort","tags":["hard","algoexpert"],"preview":"# Subarray Sort\n\nWrite a function that takes in an array of at least two integers and that returns an array of the starting and ending indices of the smallest subarray in the input array that needs to be sorted in place in order for the entire input array to be sorted (in ascending order).\n\nIf the input array is already sorted, the function should return [-1, -1].\n\n## Sample Input\n\n```\narray = [1, 2, 4, 7, 10, 11, 7, 12, 6, 7, 16, 18, 19]\n```\n\n## Sample Output\n\n```\n[3, 9]\n```\n\n## Hints\n\n```\nHint 1\nRealize that even a single out-of-order number in the input array can call for a large subarray to have to be sorted. This is because, depending on how out-of-place the number is, it might need to be moved very far away from its original position in order to be in its sorted position.\n```\n\n```\nHint 2\nFind the smallest and largest numbers that are out of order in the input array. You should be able to do this in a single pass through the array.\n```\n\n```\nHint 3\nOnce you've found the smallest and largest out-of-order numbers mentioned in Hint #2, find their final sorted positions in the array. This should give you the extremities of the smallest subarray that needs to be sorted.\n```\n\n```\nOptimal Space & Time Complexity\nO(n) time | O(1) space - where n is the length of the input array\n```","basename":"subarray-sort"},"subsets-ii":{"title":"Subsets II","description":"Given an integer array nums that may contain duplicates, return all possible subsets (the power set).","tags":["neetcode","medium","backtracking"],"link":"https://leetcode.com/problems/subsets-ii/","images":[],"preview":"### Description\n\nGiven an integer array `nums` that may contain duplicates, return all possible subsets (the power set).\n\nThe solution set **must not** contain duplicate subsets. Return the solution in **any order**.\n\n### Example 1\n\n```bash\nInput: nums = [1,2,2]\nOutput: [[],[1],[1,2],[1,2,2],[2],[2,2]]\n```\n\n### Example 2\n\n```bash\nInput: nums = [0]\nOutput: [[],[0]]\n```\n\n### Constraints:\n\n- 1 <= nums.length <= 10\n- -10 <= nums[i] <= 10","basename":"subsets-ii"},"subsets":{"title":"Subsets","description":"Given an integer array nums of unique elements, return all possible subsets (the power set).","tags":["neetcode","medium","backtracking"],"link":"https://leetcode.com/problems/subsets/","images":[],"hints":["https://wngnelson.com/assets/img_src/dsa/subsets.gif"],"preview":"### Description\n\nGiven an integer array `nums` of **unique** elements, return all possible subsets (the power set).\n\nThe solution set **must not** contain duplicate subsets. Return the solution in any order.\n\n### Example 1\n\n```bash\nInput: nums = [1,2,3]\nOutput: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n```\n\n### Example 2\n\n```bash\nInput: nums = [0]\nOutput: [[],[0]]\n```\n\n### Constraints:\n\n-   1 <= nums.length <= 10\n-   -10 <= nums[i] <= 10\n-   All the numbers of nums are unique.","basename":"subsets"},"substring-with-concatenation-of-all-words":{"title":"Substring With Concatenation of All Words","description":"Return the starting indices of all the concatenated substrings in s. You can return the answer in any order.","tags":["hard","sliding-window"],"link":"https://leetcode.com/problems/substring-with-concatenation-of-all-words/","images":[],"preview":"### Description\n\nYou are given a string s and an array of strings words. All the strings of words are of the same length.\n\nA concatenated substring in s is a substring that contains all the strings of any permutation of words concatenated.\n\nFor example, if words = [\"ab\",\"cd\",\"ef\"], then \"abcdef\", \"abefcd\", \"cdabef\", \"cdefab\", \"efabcd\", and \"efcdab\" are all concatenated strings. \"acdbef\" is not a concatenated substring because it is not the concatenation of any permutation of words.\nReturn the starting indices of all the concatenated substrings in s. You can return the answer in any order.\n\n\n### Example 1\n\n```bash\nInput: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]\nOutput: [0,9]\nExplanation: Since words.length == 2 and words[i].length == 3, the concatenated substring has to be of length 6.\nThe substring starting at 0 is \"barfoo\". It is the concatenation of [\"bar\",\"foo\"] which is a permutation of words.\nThe substring starting at 9 is \"foobar\". It is the concatenation of [\"foo\",\"bar\"] which is a permutation of words.\nThe output order does not matter. Returning [9,0] is fine too.\n```\n\n### Example 2\n\n```bash\nInput: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\nOutput: []\nExplanation: Since words.length == 4 and words[i].length == 4, the concatenated substring has to be of length 16.\nThere is no substring of length 16 in s that is equal to the concatenation of any permutation of words.\nWe return an empty array.\n```\n\n\n### Example 3\n\n```bash \nInput: s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]\nOutput: [6,9,12]\nExplanation: Since words.length == 3 and words[i].length == 3, the concatenated substring has to be of length 9.\nThe substring starting at 6 is \"foobarthe\". It is the concatenation of [\"foo\",\"bar\",\"the\"] which is a permutation of words.\nThe substring starting at 9 is \"barthefoo\". It is the concatenation of [\"bar\",\"the\",\"foo\"] which is a permutation of words.\nThe substring starting at 12 is \"thefoobar\". It is the concatenation of [\"the\",\"foo\",\"bar\"] which is a permutation of words.\n```\n\n### Constraints:\n\n- 1 <= s.length <= 104\n- 1 <= words.length <= 5000\n- 1 <= words[i].length <= 30\n- s and words[i] consist of lowercase English letters.","basename":"substring-with-concatenation-of-all-words"},"subtree-of-another-tree":{"title":"Subtree of Another Tree","description":"A subtree of a binary tree tree is a tree that consists of a node in tree and all of this node's descendants. The tree tree could also be considered as a subtree of itself.","tags":["neetcode","easy","binary-tree"],"link":"https://leetcode.com/problems/subtree-of-another-tree/","images":["https://assets.leetcode.com/uploads/2021/02/18/tree1.jpg","https://assets.leetcode.com/uploads/2021/02/18/tree2.jpg"],"preview":"### Description\n\nGiven the roots of two binary trees `root` and `subRoot`, return true if there is a subtree of root with the same structure and node values of `subRoot` and `false` otherwise.\n\nA subtree of a binary tree `tree` is a tree that consists of a node in tree and all of this node's descendants. The tree `tree` could also be considered as a subtree of itself.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2021/02/18/tree1.jpg)\n\n```bash\nInput: root = [3,4,5,1,2], subRoot = [4,1,2]\nOutput: true\n```\n\n### Example 2\n\n![](https://assets.leetcode.com/uploads/2021/02/18/tree2.jpg)\n\n```bash\nInput: root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]\nOutput: false\n```\n\n### Constraints:\n\n- The number of nodes in the root tree is in the range [1, 2000]. \n- The number of nodes in the subRoot tree is in the range [1, 1000]. \n- -10^4 <= root.val <= 10^4 \n- -10^4 <= subRoot.val <= 10^4","basename":"subtree-of-another-tree"},"sum-of-absolute-differences-in-a-sorted-array":{"title":"Sum of Absolute Differences in a Sorted Array","description":"You are given an integer array nums sorted in non-decreasing order.","tags":["medium"],"link":"https://leetcode.com/problems/sum-of-absolute-differences-in-a-sorted-array/","images":[],"preview":"### Description\n\nYou are given an integer array nums sorted in non-decreasing order.\n\nBuild and return an integer array result with the same length as nums such that result[i] is equal to the summation of absolute differences between nums[i] and all the other elements in the array.\n\nIn other words, result[i] is equal to sum(|nums[i]-nums[j]|) where 0 <= j < nums.length and j != i (0-indexed).\n\n### Example 1\n\n```bash\nInput: nums = [2,3,5]\nOutput: [4,3,5]\nExplanation: Assuming the arrays are 0-indexed, then\nresult[0] = |2-2| + |2-3| + |2-5| = 0 + 1 + 3 = 4,\nresult[1] = |3-2| + |3-3| + |3-5| = 1 + 0 + 2 = 3,\nresult[2] = |5-2| + |5-3| + |5-5| = 3 + 2 + 0 = 5.\n```\n\n### Example 2\n\n```bash\nInput: nums = [1,4,6,8,10]\nOutput: [24,15,13,15,21]\n```\n\n### Constraints:\n\n- 2 <= nums.length <= 105\n- 1 <= nums[i] <= nums[i + 1] <= 104","basename":"sum-of-absolute-differences-in-a-sorted-array"},"sum-of-two-integers":{"title":"Sum of Two Integers","description":"Given two integers a and b, return the sum of the two integers without using the operators + and -.","tags":["medium","bit-manipulation"],"link":"https://leetcode.com/problems/sum-of-two-integers/","images":[],"preview":"### Description\n\nGiven two integers `a` and `b`, return the sum of the two integers without using the operators `+` and `-`.\n\n### Example 1\n\n```bash\nInput: a = 1, b = 2\nOutput: 3\n```\n\n### Example 2\n\n```bash\nInput: a = 2, b = 3\nOutput: 5\n```\n\n### Constraints:\n\n- -1000 <= a, b <= 1000","basename":"sum-of-two-integers"},"sum-root-to-leaf-numbers":{"title":"Sum Root to Leaf Numbers","description":"Return the total sum of all root-to-leaf numbers. Test cases are generated so that the answer will fit in a 32-bit integer","tags":["binary-tree","medium"],"link":"https://leetcode.com/problems/sum-root-to-leaf-numbers","images":[],"preview":"### Description\n\nYou are given the root of a binary tree containing digits from `0` to `9` only.\n\nEach root-to-leaf path in the tree represents a number.\n\nFor example, the root-to-leaf path `1 -> 2 -> 3` represents the number `123`.\nReturn the total sum of all root-to-leaf numbers. Test cases are generated so that the answer will fit in a `32-bit` integer.\n\nA leaf node is a node with no children.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2021/02/19/num1tree.jpg)\n\n```bash\nInput: root = [1,2,3]\nOutput: 25\nExplanation:\nThe root-to-leaf path 1->2 represents the number 12.\nThe root-to-leaf path 1->3 represents the number 13.\nTherefore, sum = 12 + 13 = 25.\n```\n\n### Example 2\n\n![](https://assets.leetcode.com/uploads/2021/02/19/num2tree.jpg)\n\n```bash\nInput: root = [4,9,0,5,1]\nOutput: 1026\nExplanation:\nThe root-to-leaf path 4->9->5 represents the number 495.\nThe root-to-leaf path 4->9->1 represents the number 491.\nThe root-to-leaf path 4->0 represents the number 40.\nTherefore, sum = 495 + 491 + 40 = 1026.\n```\n\n### Constraints:\n\n- The number of nodes in the tree is in the range [1, 1000].\n- 0 <= Node.val <= 9\n- The depth of the tree will not exceed 10.","basename":"sum-root-to-leaf-numbers"},"summary-ranges":{"title":"Summary Ranges","description":"Return the smallest sorted list of ranges that cover all the numbers in the array exactly. That is, each element of nums is covered by exactly one of the ranges, and there is no integer x such that x is in one of the ranges but not in nums.","tags":["intervals","leetcode"],"link":"https://leetcode.com/problems/summary-ranges/?envType=study-plan-v2&envId=top-interview-150","images":[],"preview":"### Description\n\nYou are given a sorted unique integer array nums.\n\nA range [a,b] is the set of all integers from a to b (inclusive).\n\nReturn the smallest sorted list of ranges that cover all the numbers in the array exactly. That is, each element of nums is covered by exactly one of the ranges, and there is no integer x such that x is in one of the ranges but not in nums.\n\nEach range [a,b] in the list should be output as:\n\n\"a->b\" if a != b\n\"a\" if a == b\n\n### Example 1\n\n```bash\nInput: nums = [0,1,2,4,5,7]\nOutput: [\"0->2\",\"4->5\",\"7\"]\nExplanation: The ranges are:\n[0,2] --> \"0->2\"\n[4,5] --> \"4->5\"\n[7,7] --> \"7\"\n```\n\n### Example 2\n\n```bash\nInput: nums = [0,2,3,4,6,8,9]\nOutput: [\"0\",\"2->4\",\"6\",\"8->9\"]\nExplanation: The ranges are:\n[0,0] --> \"0\"\n[2,4] --> \"2->4\"\n[6,6] --> \"6\"\n[8,9] --> \"8->9\"\n```\n\n### Constraints:\n\n- 0 <= nums.length <= 20\n- -231 <= nums[i] <= 231 - 1\n- All the values of nums are unique.\n- nums is sorted in ascending order.","basename":"summary-ranges"},"super-egg-drop":{"title":"Super Egg Drops","description":"You are given k identical eggs and you have access to a building with n floors labeled from 1 to n.","tags":["hard","grand-dp","with-binary-search"],"link":"https://leetcode.com/problems/super-egg-drop","images":[],"preview":"### Description\n\nYou are given k identical eggs and you have access to a building with n floors labeled from 1 to n.\n\nYou know that there exists a floor f where 0 <= f <= n such that any egg dropped at a floor higher than f will break, and any egg dropped at or below floor f will not break.\n\nEach move, you may take an unbroken egg and drop it from any floor x (where 1 <= x <= n). If the egg breaks, you can no longer use it. However, if the egg does not break, you may reuse it in future moves.\n\nReturn the minimum number of moves that you need to determine with certainty what the value of f is.\n\n### Example 1\n\n```bash\nInput: k = 1, n = 2\nOutput: 2\nExplanation: \nDrop the egg from floor 1. If it breaks, we know that f = 0.\nOtherwise, drop the egg from floor 2. If it breaks, we know that f = 1.\nIf it does not break, then we know f = 2.\nHence, we need at minimum 2 moves to determine with certainty what the value of f is.\n```\n\n### Example 2\n\n```bash\nInput: k = 2, n = 6\nOutput: 3\n```\n\n### Constraints:\n\n- 1 <= k <= 100\n- 1 <= n <= 10^4","basename":"super-egg-drop"},"surrounded-regions":{"title":"Surrounded Regions","description":"Given an m x n matrix board containing 'X' and 'O', capture all regions that are 4-directionally surrounded by 'X'.","tags":["neetcode","medium","graphs"],"link":"https://leetcode.com/problems/surrounded-regions/","images":["https://assets.leetcode.com/uploads/2021/02/19/xogrid.jpg"],"hints":["https://wngnelson.com/assets/img_src/dsa/surrounded.gif"],"preview":"### Description\n\nGiven an `m x n` matrix board containing 'X' and 'O', capture all regions that are 4-directionally surrounded by 'X'.\n\nA region is **captured** by flipping all 'O's into 'X's in that surrounded region.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2021/02/19/xogrid.jpg)\n\n```bash\nInput: board = [[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"O\",\"X\"],[\"X\",\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]]\nOutput: [[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]]\nExplanation: Notice that an 'O' should not be flipped if:\n- It is on the border, or\n- It is adjacent to an 'O' that should not be flipped.\nThe bottom 'O' is on the border, so it is not flipped.\nThe other three 'O' form a surrounded region, so they are flipped.\n```\n\n### Example 2\n\n```bash\nInput: board = [[\"X\"]]\nOutput: [[\"X\"]]\n```\n\n### Constraints:\n\n- m == board.length\n- n == board[i].length\n- 1 <= m, n <= 200\n- board[i][j] is 'X' or 'O'","basename":"surrounded-regions"},"symmetric-tree":{"title":"Symmetric Tree","description":"Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).","tags":["binary-tree","easy"],"link":"https://leetcode.com/problems/symmetric-tree/","images":[],"preview":"### Description\n\nGiven the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).\n\n### Example 1\n\n\n![](https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg)\n\n```bash\nInput: root = [1,2,2,3,4,4,3]\nOutput: true\n```\n\n### Example 2\n\n![](https://assets.leetcode.com/uploads/2021/02/19/symtree2.jpg)\n\n```bash\nInput: root = [1,2,2,null,3,null,3]\nOutput: false\n```\n\n### Constraints:\n\n- The number of nodes in the tree is in the range [1, 1000].\n- -100 <= Node.val <= 100","basename":"symmetric-tree"},"tallest-billboard":{"title":"Tallest Billboard","description":"Return the largest possible height of your billboard installation. If you cannot support the billboard, return 0.","tags":["hard","grand-dp","probability"],"link":"https://leetcode.com/problems/tallest-billboard","images":[],"preview":"### Description\n\nYou are installing a billboard and want it to have the largest height. The billboard will have two steel supports, one on each side. Each steel support must be an equal height.\n\nYou are given a collection of rods that can be welded together. For example, if you have rods of lengths 1, 2, and 3, you can weld them together to make a support of length 6.\n\nReturn the largest possible height of your billboard installation. If you cannot support the billboard, return 0.\n\n### Example 1\n\n```bash\nInput: rods = [1,2,3,6]\nOutput: 6\nExplanation: We have two disjoint subsets {1,2,3} and {6}, which have the same sum = 6.\n```\n\n### Example 2\n\n```bash\nInput: rods = [1,2,3,4,5,6]\nOutput: 10\nExplanation: We have two disjoint subsets {2,3,5} and {4,6}, which have the same sum = 10.\n```\n\n### Constraints:\n\n- 1 <= rods.length <= 20\n- 1 <= rods[i] <= 1000\n- sum(rods[i]) <= 5000","basename":"tallest-billboard"},"task-assigment":{"title":"Task Assignment","description":"task assignment","tags":["medium","algoexpert"],"preview":"# Task Assignment\n\nYou're given an integer k representing a number of workers and an array of positive integers representing durations of tasks that must be completed by the workers. Specifically, each worker must complete two unique tasks and can only work on one task at a time. The number of tasks will always be equal to 2k such that each worker always has exactly two tasks to complete. All tasks are independent of one another and can be completed in any order. Workers will complete their assigned tasks in parallel, and the time taken to complete all tasks will be equal to the time taken to complete the longest pair of tasks (see the sample output for an explanation).\n\nWrite a function that returns the optimal assignment of tasks to each worker such that the tasks are completed as fast as possible. Your function should return a list of pairs, where each pair stores the indices of the tasks that should be completed by one worker. The pairs should be in the following format: [task1, task2], where the order of task1 and task2 doesn't matter. Your function can return the pairs in any order. If multiple optimal assignments exist, any correct answer will be accepted.\n\nNote: you'll always be given at least one worker (i.e., k will always be greater than 0).\n\n## Sample Input\n\n```\nk = 3\ntasks = [1, 3, 5, 3, 1, 4]\n```\n\n## Sample Output\n\n```\n[\n  [0, 2], // tasks[0] = 1, tasks[2] = 5 | 1 + 5 = 6\n  [4, 5], // tasks[4] = 1, tasks[5] = 4 | 1 + 4 = 5\n  [1, 3], // tasks[1] = 3, tasks[3] = 3 | 3 + 3 = 6\n] // The fastest time to complete all tasks is 6.\n\n// Note: there are multiple correct answers for this sample input.\n// The following is an example of another correct answer:\n// [\n//   [2, 4],\n//   [0, 5],\n//   [1, 3]\n// [\n```\n\n### Hints\n\nHint 1\n> Start by considering which pairs of tasks will lead to the longest possible time to complete all tasks.\n\nHint 2\n> The amount of time it'll take to complete all tasks will be dictated by the pair of tasks that has the longest total duration. This means that you'll want to avoid pairing long tasks together.\n\nHint 3\n> Since the pair of tasks with the longest total duration is the time it takes for us to finish all tasks, we want to minimize this pair's duration. To do this, we can simply pair the shortest-duration task with the longest-duration task and repeat the process with all other tasks.\n\nHint 4\n> Start by sorting the tasks array in ascending order. Then, pair the shortest-duration task with the longest-duration task, and add that pair to some output array. Repeat this process until you've paired all tasks. This will lead to an optimal pairing, because your pair of tasks with the longest duration will have the shortest duration that it can possibly have.\n\n```\nOptimal Space & Time Complexity\nO(nlog(n)) time | O(n) space - where n is the number of tasks\n```","basename":"task-assigment"},"task-scheduler":{"title":"Task Scheduler","description":"Return the least number of units of times that the CPU will take to finish all the given tasks.","tags":["neetcode","medium","heap"],"link":"https://leetcode.com/problems/task-scheduler/","images":[],"preview":"### Description\n\nGiven a characters array tasks, representing the tasks a CPU needs to do, where each letter represents a different task. Tasks could be done in any order. Each task is done in one unit of time. For each unit of time, the CPU could complete either one task or just be idle.\n\nHowever, there is a non-negative integer n that represents the cooldown period between two **same tasks** (the same letter in the array), that is that there must be at least n units of time between any two same tasks.\n\nReturn the least number of units of times that the CPU will take to finish all the given tasks.\n\n### Example 1\n\n```bash\nInput: tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2\nOutput: 8\nExplanation: \nA -> B -> idle -> A -> B -> idle -> A -> B\nThere is at least 2 units of time between any two same tasks.\n```\n\n### Example 2\n\n```bash\nInput: tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 0\nOutput: 6\nExplanation: On this case any permutation of size 6 would work since n = 0.\n[\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"]\n[\"A\",\"B\",\"A\",\"B\",\"A\",\"B\"]\n[\"B\",\"B\",\"B\",\"A\",\"A\",\"A\"]\n...\nAnd so on.\n```\n\n### Example 3\n\n```bash\nInput: tasks = [\"A\",\"A\",\"A\",\"A\",\"A\",\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\"], n = 2\nOutput: 16\nExplanation: \nOne possible solution is\nA -> B -> C -> A -> D -> E -> A -> F -> G -> A -> idle -> idle -> A -> idle -> idle -> A\n```\n\n### Constraints:\n\n- 1 <= task.length <= 10^4 \n- tasks[i] is upper-case English letter. \n- The integer n is in the range [0, 100].","basename":"task-scheduler"},"the-maze-ii":{"title":"The Maze II","description":"The distance is the number of empty spaces traveled by the ball from the start position (excluded) to the destination (included).","tags":["medium","graph","dijistra"],"link":"https://leetcode.com/problems/the-maze-ii/","images":["https://assets.leetcode.com/uploads/2021/03/31/maze1-1-grid.jpg","https://assets.leetcode.com/uploads/2021/03/31/maze1-2-grid.jpg"],"preview":"### Description\n\nThere is a ball in a maze with empty spaces (represented as 0) and walls (represented as 1). The ball can go through the empty spaces by rolling **up, down, left or right**, but it won't stop rolling until hitting a wall. When the ball stops, it could choose the next direction.\n\nGiven the m x n maze, the ball's start position and the destination, where start = [startrow, startcol] and destination = [destinationrow, destinationcol], return the shortest distance for the ball to stop at the destination. If the ball cannot stop at destination, return -1.\n\nThe **distance** is the number of **empty spaces** traveled by the ball from the start position (excluded) to the destination (included).\n\nYou may assume that the borders of the maze are **all walls** (see examples).\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2021/03/31/maze1-1-grid.jpg)\n\n```bash\nInput: maze = [[0,0,1,0,0],[0,0,0,0,0],[0,0,0,1,0],[1,1,0,1,1],[0,0,0,0,0]], start = [0,4], destination = [4,4]\nOutput: 12\nExplanation: One possible way is : left -> down -> left -> down -> right -> down -> right.\nThe length of the path is 1 + 1 + 3 + 1 + 2 + 2 + 2 = 12.\n```\n\n### Example 2\n\n![](https://assets.leetcode.com/uploads/2021/03/31/maze1-2-grid.jpg)\n\n```bash\nInput: maze = [[0,0,1,0,0],[0,0,0,0,0],[0,0,0,1,0],[1,1,0,1,1],[0,0,0,0,0]], start = [0,4], destination = [3,2]\nOutput: -1\nExplanation: There is no way for the ball to stop at the destination. Notice that you can pass through the destination but you cannot stop there.\n```\n\n### Example 3\n\n```bash\nInput: maze = [[0,0,0,0,0],[1,1,0,0,1],[0,0,0,0,0],[0,1,0,0,1],[0,1,0,0,0]], start = [4,3], destination = [0,1]\nOutput: -1\n```\n\n\n### Constraints:\n\n- m == maze.length\n- n == maze[i].length\n- 1 <= m, n <= 100\n- maze[i][j] is 0 or 1.\n- start.length == 2\n- destination.length == 2\n- 0 <= startrow, destinationrow < m\n- 0 <= startcol, destinationcol < n\n- Both the ball and the destination exist in an empty space, and they will not be in the same position initially.\n- The maze contains at least 2 empty spaces","basename":"the-maze-ii"},"the-maze-iii":{"title":"The Maze III","description":"The distance is the number of empty spaces traveled by the ball from the start position (excluded) to the destination (included).","tags":["hard","graph","dijistra"],"link":"https://leetcode.com/problems/the-maze-iii/?envType=study-plan-v2&envId=graph-theory","images":[],"preview":"### Description\n\nThere is a ball in a maze with empty spaces (represented as 0) and walls (represented as 1). The ball can go through the empty spaces by rolling up, down, left or right, but it won't stop rolling until hitting a wall. When the ball stops, it could choose the next direction. There is also a hole in this maze. The ball will drop into the hole if it rolls onto the hole.\n\nGiven the m x n maze, the ball's position ball and the hole's position hole, where ball = [ballrow, ballcol] and hole = [holerow, holecol], return a string instructions of all the instructions that the ball should follow to drop in the hole with the **shortest distance** possible. If there are multiple valid instructions, return the **lexicographically minimum** one. If the ball can't drop in the hole, return \"impossible\".\n\nIf there is a way for the ball to drop in the hole, the answer instructions should contain the characters 'u' (i.e., up), 'd' (i.e., down), 'l' (i.e., left), and 'r' (i.e., right).\n\nThe **distance** is the number of **empty spaces** traveled by the ball from the start position (excluded) to the destination (included).\n\nYou may assume that the borders of **the maze are all walls** (see examples).\n\n \n\n### Example 1\n\n```bash\nInput: maze = [[0,0,0,0,0],[1,1,0,0,1],[0,0,0,0,0],[0,1,0,0,1],[0,1,0,0,0]], ball = [4,3], hole = [0,1]\nOutput: \"lul\"\nExplanation: There are two shortest ways for the ball to drop into the hole.\nThe first way is left -> up -> left, represented by \"lul\".\nThe second way is up -> left, represented by 'ul'.\nBoth ways have shortest distance 6, but the first way is lexicographically smaller because 'l' < 'u'. So the output is \"lul\".\n```\n\n### Example 2\n\n```bash\nInput: maze = [[0,0,0,0,0],[1,1,0,0,1],[0,0,0,0,0],[0,1,0,0,1],[0,1,0,0,0]], ball = [4,3], hole = [3,0]\nOutput: \"impossible\"\nExplanation: The ball cannot reach the hole.\n```\n\n### Constraints:\n\n- m == maze.length\n- n == maze[i].length\n- 1 <= m, n <= 100\n- maze[i][j] is 0 or 1.\n- ball.length == 2\n- hole.length == 2\n- 0 <= ballrow, holerow <= m\n- 0 <= ballcol, holecol <= n\n- Both the ball and the hole exist in an empty space, and they will not be in the same position initially.\n- The maze contains at least 2 empty spaces.","basename":"the-maze-iii"},"three-number-sum":{"title":"Three Number Sum","description":"A nice problem","tags":["neetcode","array","neetcode"],"link":"https://leetcode.com/problems/3sum/","preview":"### Three Number Sum\n\nGiven an integer array nums, return all the triplets nums[i], nums[j], nums[k] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\n\nNotice that the solution set must not contain duplicate triplets.\n\n \n\n### Example 1:\n\n```bash\nInput: nums = [-1,0,1,2,-1,-4]\nOutput: [[-1,-1,2],[-1,0,1]]\nExplanation: \nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\nThe distinct triplets are [-1,0,1] and [-1,-1,2].\nNotice that the order of the output and the order of the triplets does not matter.\n```\n\n### Example 2:\n\n```bash\nInput: nums = [0,1,1]\nOutput: []\nExplanation: The only possible triplet does not sum up to 0.\n```\n\n### Example 3:\n\n```bash\nInput: nums = [0,0,0]\nOutput: [[0,0,0]]\nExplanation: The only possible triplet sums up to 0.\n```","basename":"three-number-sum"},"time-needed-to-inform-all-employees":{"title":"Time Needed to Inform All Employees","description":"https://leetcode.com/problems/time-needed-to-inform-all-employees","tags":["medium","graph","dfs"],"link":"https://leetcode.com/problems/time-needed-to-inform-all-employees","images":["https://assets.leetcode.com/uploads/2020/02/27/graph.png"],"preview":"### Description\n\nA company has n employees with a unique ID for each employee from 0 to n - 1. The head of the company is the one with headID.\n\nEach employee has one direct manager given in the manager array where manager[i] is the direct manager of the i-th employee, manager[headID] = -1. Also, it is guaranteed that the subordination relationships have a tree structure.\n\nThe head of the company wants to inform all the company employees of an urgent piece of news. He will inform his direct subordinates, and they will inform their subordinates, and so on until all employees know about the urgent news.\n\nThe i-th employee needs informTime[i] minutes to inform all of his direct subordinates (i.e., After informTime[i] minutes, all his direct subordinates can start spreading the news).\n\nReturn the number of minutes needed to inform all the employees about the urgent news.\n\n### Example 1\n\n```bash\nInput: n = 1, headID = 0, manager = [-1], informTime = [0]\nOutput: 0\nExplanation: The head of the company is the only employee in the company.\n```\n\n### Example 2\n\n![](https://assets.leetcode.com/uploads/2020/02/27/graph.png)\n\n```bash\nInput: n = 6, headID = 2, manager = [2,2,-1,2,2,2], informTime = [0,0,1,0,0,0]\nOutput: 1\nExplanation: The head of the company with id = 2 is the direct manager of all the employees in the company and needs 1 minute to inform them all.\nThe tree structure of the employees in the company is shown.\n```\n\n### Constraints:\n\n- 1 <= n <= 105\n- 0 <= headID < n\n- manager.length == n\n- 0 <= manager[i] < n\n- manager[headID] == -1\n- informTime.length == n\n- 0 <= informTime[i] <= 1000\n- informTime[i] == 0 if employee i has no subordinates.\n- It is guaranteed that all the employees can be informed.","basename":"time-needed-to-inform-all-employees"},"topological-sort":{"title":"Topological Sort","tags":["hard","algoexpert"],"preview":"# Topological Sort\n\nYou're given a list of arbitrary jobs that need to be completed; these jobs are represented by distinct integers. You're also given a list of dependencies. A dependency is represented as a pair of jobs where the first job is a prerequisite of the second one. In other words, the second job depends on the first one; it can only be completed once the first job is completed.\n\nWrite a function that takes in a list of jobs and a list of dependencies and returns a list containing a valid order in which the given jobs can be completed. If no such order exists, the function should return an empty array.\n\n## Sample Input\n\n```\njobs = [1, 2, 3, 4]\ndeps = [[1, 2], [1, 3], [3, 2], [4, 2], [4, 3]]\n```\n\n## Sample Output\n\n```\n[1, 4, 3, 2] or [4, 1, 3, 2]\n```\n\n### Hints\n\nHint 1\n> Try representing the jobs and dependencies as a graph, where each vertex is a job and each edge is a dependency. How can you traverse this graph to topologically sort the list of jobs?\n\nHint 2\n> One approach to solving this problem is to traverse the graph mentioned in Hint #1 using Depth-first Search. Starting at a random job, traverse its prerequisite jobs in Depth-first Search fashion until you reach a job with no prerequisites; such a job can safely be appended to the final order. Once you've traversed and added all prerequisites of a job to the final order, you can append the job in question to the order. This approach will have to track whether nodes have been traversed already, whether they're in the process of being traversed (which would indicate a cycle in the graph and therefore no valid topological order), or whether they're ready to be traversed.\n\nHint 3\n> Another approach to solving this problem is to traverse the graph mentioned in Hint #1 starting specifically with jobs that have no prerequisites. Keep track of all the jobs that have no prerequisites, traverse them one by one, and append them to the final order. For all of these jobs, remove their dependencies from the graph and update the number of prerequisites for each of these dependencies accordingly (these dependencies should now have one prerequisite less since one of their prerequisite job has just been added to the final order). As you update the number of prerequisites for these other jobs, keep track of the ones that no longer have prerequisites and that are ready to be traversed. You'll eventually go through all of the jobs if there are no cycles in the graph. If there is a cycle in the graph, there will still be jobs with prerequisites and you'll know that there is no valid topological order. This approach will involve keeping track of the number of prerequisites per job as well as all the actual dependencies of each job.\n\n```\nOptimal Space & Time Complexity\nO(j + d) time | O(j + d) space - where j is the number of jobs and d is the number of dependencies\n```","basename":"topological-sort"},"toss-strange-coins":{"title":"Toss Strange Coins","description":"Return the probability that the number of coins facing heads equals target if you toss every coin exactly once.","tags":["medium","grand-dp","probability"],"link":"https://leetcode.com/problems/toss-strange-coins","images":[],"preview":"### Description\n\nYou have some coins.  The i-th coin has a probability prob[i] of facing heads when tossed.\n\nReturn the probability that the number of coins facing heads equals target if you toss every coin exactly once.\n\n### Example 1\n\n```bash\nInput: prob = [0.4], target = 1\nOutput: 0.40000\n```\n\n### Example 2\n\n```bash\nInput: prob = [0.5,0.5,0.5,0.5,0.5], target = 0\nOutput: 0.03125\n```\n\n### Constraints:\n\n- 1 <= prob.length <= 1000\n- 0 <= prob[i] <= 1\n- 0 <= target <= prob.length\n- Answers will be accepted as correct if they are within 10^-5 of the correct answer.","basename":"toss-strange-coins"},"trapping-rain-water":{"title":"Trapping Rain Water","description":"A trapping rain water example","tags":["neetcode","hard","array"],"link":"https://leetcode.com/problems/trapping-rain-water/","preview":"Given `n` non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\n\nExample 1\n\n![](https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png)\n\n```\nInput: height = [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6\nExplanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\n```\n\nExample 2\n\n```\nInput: height = [4,2,0,3,2,5]\nOutput: 9\n```","basename":"trapping-rain-water"},"triangle":{"title":"Triangle","description":"Given a triangle array, return the minimum path sum from top to bottom.","tags":["medium","multidimensional-dp"],"link":"https://leetcode.com/problems/triangle","images":[],"preview":"### Description\n\nGiven a triangle array, return the minimum path sum from top to bottom.\n\nFor each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row.\n\n### Example 1\n\n```bash\nInput: triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]\nOutput: 11\nExplanation: The triangle looks like:\n   2\n  3 4\n 6 5 7\n4 1 8 3\nThe minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (underlined above).\n```\n\n### Example 2\n\n```bash\nInput: triangle = [[-10]]\nOutput: -10\n```\n\n### Constraints:\n\n- 1 <= triangle.length <= 200\n- triangle[0].length == 1\n- triangle[i].length == triangle[i - 1].length + 1\n- -104 <= triangle[i][j] <= 104","basename":"triangle"},"uncrossed-lines":{"title":"Uncrossed Lines","description":"Note that a connecting line cannot intersect even at the endpoints (i.e., each number can only belong to one connecting line).","tags":["medium","dp","longest-common-subsequence"],"link":"https://leetcode.com/problems/uncrossed-lines","images":[],"preview":"### Description\n\nYou are given two integer arrays nums1 and nums2. We write the integers of nums1 and nums2 (in the order they are given) on two separate horizontal lines.\n\nWe may draw connecting lines: a straight line connecting two numbers nums1[i] and nums2[j] such that:\n\n- nums1[i] == nums2[j], and\n- the line we draw does not intersect any other connecting (non-horizontal) line.\n\nNote that a connecting line cannot intersect even at the endpoints (i.e., each number can only belong to one connecting line).\n\nReturn the maximum number of connecting lines we can draw in this way.\n\n### Example 1\n\n```bash\nInput: nums1 = [1,4,2], nums2 = [1,2,4]\nOutput: 2\nExplanation: We can draw 2 uncrossed lines as in the diagram.\nWe cannot draw 3 uncrossed lines, because the line from nums1[1] = 4 to nums2[2] = 4 will intersect the line from nums1[2]=2 to nums2[1]=2.\n```\n\n### Example 2\n\n```bash\nInput: nums1 = [2,5,1,2,5], nums2 = [10,5,2,1,5,2]\nOutput: 3\n```\n\n### Constraints:\n\n- 1 <= nums1.length, nums2.length <= 500\n- 1 <= nums1[i], nums2[j] <= 2000","basename":"uncrossed-lines"},"unique-binary-search-trees-ii":{"title":"Unique Binary Search Trees II","description":"Given an integer n, return all the structurally unique BST's (binary search trees), which has exactly n nodes of unique values from 1 to n. Return the answer in any order.","tags":[],"link":"https://leetcode.com/problems/unique-binary-search-trees-ii","images":[],"preview":"### Description\n\n\nGiven an integer n, return all the structurally unique BST's (binary search trees), which has exactly n nodes of unique values from 1 to n. Return the answer in any order.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg)\n\n```bash\nInput: n = 3\nOutput: [[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]\n```\n\n### Example 2\n\n```bash\nInput: n = 1\nOutput: [[1]]\n```\n\n### Constraints:\n\n- 1 <= n <= 8","basename":"unique-binary-search-trees-ii"},"unique-binary-search-trees":{"title":"Unique Binary Search Trees","description":"Given an integer n, return the number of structurally unique BST's (binary search trees) which has exactly n nodes of unique values from 1 to n.","tags":["medium","dp","on-tree"],"link":"https://leetcode.com/problems/unique-binary-search-trees","images":[],"preview":"### Description\n\nGiven an integer n, return the number of structurally unique BST's (binary search trees) which has exactly n nodes of unique values from 1 to n.\n\n \n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg)\n\n```bash\nInput: n = 3\nOutput: 5\n```\n\n### Example 2\n\n```bash\nInput: n = 1\nOutput: 1\n```\n\n### Constraints:\n\n- 1 <= n <= 19","basename":"unique-binary-search-trees"},"unique-paths-ii":{"title":"Unique Paths II","description":"Return the number of possible unique paths that the robot can take to reach the bottom-right corner.","tags":["medium","multi-dimensional-dp"],"link":"https://leetcode.com/problems/unique-paths-ii","images":[],"preview":"### Description\n\nYou are given an m x n integer array grid. There is a robot initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.\n\nAn obstacle and space are marked as 1 or 0 respectively in grid. A path that the robot takes cannot include any square that is an obstacle.\n\nReturn the number of possible unique paths that the robot can take to reach the bottom-right corner.\n\nThe testcases are generated so that the answer will be less than or equal to 2 * 109.\n\n \n\n### Example 1\n\n```bash\nInput: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]\nOutput: 2\nExplanation: There is one obstacle in the middle of the 3x3 grid above.\nThere are two ways to reach the bottom-right corner:\n1. Right -> Right -> Down -> Down\n2. Down -> Down -> Right -> Right\n```\n\n### Example 2\n\n```bash\nInput: obstacleGrid = [[0,1],[0,0]]\nOutput: 1\n```\n\n### Constraints:\n\n- m == obstacleGrid.length\n- n == obstacleGrid[i].length\n- 1 <= m, n <= 100\n- obstacleGrid[i][j] is 0 or 1.","basename":"unique-paths-ii"},"unique-paths":{"title":"Unique Paths","description":"Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.","tags":["medium","multi-dimensional-dp"],"link":"https://leetcode.com/problems/unique-paths/","images":[],"preview":"### Description\n\nThere is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.\n\nGiven the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.\n\nThe test cases are generated so that the answer will be less than or equal to 2 * 109.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png)\n\n```bash\nInput: m = 3, n = 7\nOutput: 28\n```\n\n### Example 2\n\n```bash\nInput: m = 3, n = 2\nOutput: 3\nExplanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\n1. Right -> Down -> Down\n2. Down -> Down -> Right\n3. Down -> Right -> Down\n```\n\n### Constraints:\n\n- 1 <= m, n <= 100","basename":"unique-paths"},"valid-parentheses":{"title":"Valid Parentheses","description":"Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.","tags":["neetcode","easy","stack"],"link":"https://leetcode.com/problems/valid-parentheses/","hints":["https://wngnelson.com/assets/img_src/dsa/validparentheses.gif"],"preview":"### Description\n\nGiven a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n\nAn input string is valid if:\n\nOpen brackets must be closed by the same type of brackets.\nOpen brackets must be closed in the correct order.\nEvery close bracket has a corresponding open bracket of the same type.\n\n\n### Example 1\n```bash\nInput: s = \"()\"\nOutput: true\n```\n\n### Example 2\n```bash\nInput: s = \"()[]{}\"\nOutput: true\n```\n\n### Example 3\n```bash\nInput: s = \"(]\"\nOutput: false\n```\n\n### Constraints:\n\n-      1 <= s.length <= 104     \n-      s consists of parentheses only '()[]{}'.","basename":"valid-parentheses"},"valid-parenthesis-string":{"title":"Valid Parenthesis String","description":"Given a string s containing only three types of characters - '(', ')' and '*', return true if s is valid.","tags":["medium","greedy","neetcode"],"link":"https://leetcode.com/problems/valid-parenthesis-string/","images":[],"preview":"### Description\n\nGiven a string s containing only three types of characters: '(', ')' and '*', return true if s is valid.\n\nThe following rules define a valid string:\n\n- Any left parenthesis '(' must have a corresponding right parenthesis ')'.\n- Any right parenthesis ')' must have a corresponding left parenthesis '('.\n- Left parenthesis '(' must go before the corresponding right parenthesis ')'.\n- '*' could be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string \"\".\n\n\n### Example 1\n\n```bash\nInput: s = \"()\"\nOutput: true\n```\n\n### Example 2\n\n```bash\nInput: s = \"(*)\"\nOutput: true\n```\n\n### Example 3\n\n```bash\nInput: s = \"(*))\"\nOutput: true\n```\n\n\n### Constraints:\n\n- 1 <= s.length <= 100\n- s[i] is '(', ')' or '*'.","basename":"valid-parenthesis-string"},"validate-binary-search-tree":{"title":"Validate Binary Search Tree","description":"Given the root of a binary tree, determine if it is a valid binary search tree (BST).","tags":["neetcode","medium","binary-tree"],"link":"https://leetcode.com/problems/validate-binary-search-tree/","images":["https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg","https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg"],"preview":"### Description\n\nGiven the root of a binary tree, determine if it is a valid binary search tree (BST).\n\nA valid BST is defined as follows:\n\n- The left subtree of a node contains only nodes with keys less than the node's key.\n- The right subtree of a node contains only nodes with keys greater than the node's key.\n- Both the left and right subtrees must also be binary search trees.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg)\n\n```bash\nInput: root = [2,1,3]\nOutput: true\n```\n\n### Example 2\n\n![](https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg)\n\n```bash\nInput: root = [5,1,4,null,null,3,6]\nOutput: false\nExplanation: The root node's value is 5 but its right child's value is 4.\n```\n\n### Constraints:\n\n- The number of nodes in the tree is in the range [1, 104].\n- -2^31 <= Node.val <= 2^31 - 1","basename":"validate-binary-search-tree"},"validate-three-nodes":{"title":"Validate Three Nodes","description":"Validate Three Nodes","tags":["hard","algoexpert"],"link":null,"images":[],"preview":"# Validate Three Nodes\n\nYou're given three nodes that are contained in the same Binary Search Tree: nodeOne, nodeTwo, and nodeThree. Write a function that returns a boolean representing whether one of nodeOne or nodeThree is an ancestor of nodeTwo and the other node is a descendant of nodeTwo. For example, if your function determines that nodeOne is an ancestor of nodeTwo, then it needs to see if nodeThree is a descendant of nodeTwo. If your function determines that nodeThree is an ancestor, then it needs to see if nodeOne is a descendant.\n\nA descendant of a node N is defined as a node contained in the tree rooted at N. A node N is an ancestor of another node M if M is a descendant of N.\n\nIt isn't guaranteed that nodeOne or nodeThree will be ancestors or descendants of nodeTwo, but it is guaranteed that all three nodes will be unique and will never be None / null. In other words, you'll be given valid input nodes.\n\nEach BST node has an integer value, a left child node, and a right child node. A node is said to be a valid BST node if and only if it satisfies the BST property: its value is strictly greater than the values of every node to its left; its value is less than or equal to the values of every node to its right; and its children nodes are either valid BST nodes themselves or None / null.\n\n## Sample Input\n\n``` \ntree =    5\n       /     \\\n      2       7\n    /   \\   /   \\\n   1     4 6     8\n  /     /\n 0     3  \n// This tree won't actually be passed as an input; it's here to help you visualize the problem.\nnodeOne = 5 // The actual node with value 5.\nnodeTwo = 2 // The actual node with value 2.\nnodeThree = 3 // The actual node with value 3.\n```\n\n## Sample Output\n\n```\ntrue // nodeOne is an ancestor of nodeTwo, and nodeThree is a descendant of nodeTwo.\n```\n\n### Hints\n\n```\nHint 1\nKeep in mind that the nodes passed to you are contained in a Binary Search Treenot just a normal Binary Tree. How might this help you traverse the tree faster?\n```\n\n```\nHint 2\nThere are multiple ways to solve this problem, but the simplest is to just check the possible relationships between the nodes. Since you're looking for a descendant and an ancestor, simply check if nodeOne is a descendant of nodeTwo, and if it is, then check if nodeThree is an ancestor of nodeTwo. If the previous checks come out negative, check if nodeThree is a descendant of nodeTwo, and if it is, then check if nodeOne is an ancestor of nodeTwo.\n```\n\n```\nHint 3\nAlthough the approach mentioned in Hint #2 is fairly efficient (it runs in O(h) time, where h is the height of the tree), there's a way to solve this problem faster. It involves realizing that, when searching for nodeTwo from either nodeOne or nodeThree, if you ever reach nodeThree from nodeOne or nodeOne from nodeThree before reaching nodeTwo, then you can immediately stop the algorithm, because nodeTwo cannot be between these nodes. See the Conceptual Overview section of this question's video explanation for a more in-depth explanation.\n```\n\n```\nOptimal Space & Time Complexity\nO(d) time | O(1) space - where d is the distance between nodeOne and nodeThree\n```","basename":"validate-three-nodes"},"walls-and-gates":{"title":"Walls and Gates","description":"Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should be filled with INF.","tags":["neetcode","medium","graphs"],"link":"https://tenderleo.gitbooks.io/leetcode-solutions-/content/GoogleMedium/286.html","images":[],"preview":"### Description\n\nYou are given a m x n 2D grid initialized with these three possible values.\n\n-1 - A wall or an obstacle. 0 - A gate. INF - Infinity means an empty room. We use the value 231 - 1 = 2147483647 to represent INF as you may assume that the distance to a gate is less than 2147483647. Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should be filled with INF.\n\n### Example 1\n\n```bash\nINF  -1  0  INF\nINF INF INF  -1\nINF  -1 INF  -1\n  0  -1 INF INF\n```\nAfter running the function, the 2D grid should be:\n\n```bash\n  3  -1   0   1\n  2   2   1  -1\n  1  -1   2  -1\n  0  -1   3   4\n```\n\n### Constraints:\n\n- m == rooms.length\n- n == rooms[i].length","basename":"walls-and-gates"},"wiggle-subsequence":{"title":"Wiggle Subsequence","description":"A subsequence is obtained by deleting some elements (possibly zero) from the original sequence, leaving the remaining elements in their original order.","tags":["medium","dp","general-1d"],"link":"https://leetcode.com/problems/wiggle-subsequence","images":[],"preview":"### Description\n\nA wiggle sequence is a sequence where the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with one element and a sequence with two non-equal elements are trivially wiggle sequences.\n\nFor example, [1, 7, 4, 9, 2, 5] is a wiggle sequence because the differences (6, -3, 5, -7, 3) alternate between positive and negative.\nIn contrast, [1, 4, 7, 2, 5] and [1, 7, 4, 5, 5] are not wiggle sequences. The first is not because its first two differences are positive, and the second is not because its last difference is zero.\nA subsequence is obtained by deleting some elements (possibly zero) from the original sequence, leaving the remaining elements in their original order.\n\nGiven an integer array nums, return the length of the longest wiggle subsequence of\n\n### Example 1\n\n```bash\nInput: nums = [1,7,4,9,2,5]\nOutput: 6\nExplanation: The entire sequence is a wiggle sequence with differences (6, -3, 5, -7, 3).\n```\n\n### Example 2\n\n```bash\nInput: nums = [1,17,5,10,13,15,10,5,16,8]\nOutput: 7\nExplanation: There are several subsequences that achieve this length.\n\nOne is [1, 17, 10, 13, 10, 16, 8] with differences (16, -7, 3, -3, 6, -8).\n```\n\n### Constraints:\n\n- 1 <= nums.length <= 1000\n- 0 <= nums[i] <= 1000","basename":"wiggle-subsequence"},"word-break":{"title":"Word Break","description":"Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words.","tags":["medium","dp","neetcode"],"link":"https://leetcode.com/problems/word-break/","images":[],"hints":["https://wngnelson.com/assets/img_src/dsa/wordbreak.gif"],"preview":"### Description\n\nGiven a string `s` and a dictionary of strings `wordDict`, return `true` if `s` can be segmented into a space-separated sequence of one or more dictionary words.\n\n**Note** that the same word in the dictionary may be reused multiple times in the segmentation.\n\n### Example 1\n\n```bash\nInput: s = \"leetcode\", wordDict = [\"leet\",\"code\"]\nOutput: true\nExplanation: Return true because \"leetcode\" can be segmented as \"leet code\".\n```\n\n### Example 2\n\n```bash\nInput: s = \"applepenapple\", wordDict = [\"apple\",\"pen\"]\nOutput: true\nExplanation: Return true because \"applepenapple\" can be segmented as \"apple pen apple\".\nNote that you are allowed to reuse a dictionary word.\n```\n\n### Example 3\n\n```bash\nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\nOutput: false\n```\n\n\n### Constraints:\n\n- 1 <= s.length <= 300\n- 1 <= wordDict.length <= 1000\n- 1 <= wordDict[i].length <= 20\n- s and wordDict[i] consist of only lowercase English letters.\n- All the strings of wordDict are unique.","basename":"word-break"},"word-ladder":{"title":"Word Ladder","description":"Given two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.","tags":["neetcode","hard","graphs","bfs"],"link":"https://leetcode.com/problems/word-ladder/","images":[],"preview":"### Description\n\nA transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n\n- Every adjacent pair of words differs by a single letter.\n- Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList.\n- sk == endWord\n\n\nGiven two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.\n\n \n\n### Example 1\n\n```bash\nInput: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\nOutput: 5\nExplanation: One shortest transformation sequence is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> cog\", which is 5 words long.\n```\n\n### Example 2\n\n```bash\nInput: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\nOutput: 0\nExplanation: The endWord \"cog\" is not in wordList, therefore there is no valid transformation sequence.\n```\n\n### Constraints:\n\n- 1 <= beginWord.length <= 10\n- endWord.length == beginWord.length\n- 1 <= wordList.length <= 5000\n- wordList[i].length == beginWord.length\n- beginWord, endWord, and wordList[i] consist of lowercase English letters.\n- beginWord != endWord\n- All the words in wordList are unique.","basename":"word-ladder"},"word-pattern":{"title":"Word Pattern","description":"Given a pattern and a string s, find if s follows the same pattern. Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.","tags":["hashmap","easy","leetcode"],"link":"https://leetcode.com/problems/word-pattern/","images":[],"preview":"### Description\n\nGiven a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.\n\n### Example 1\n\n```bash\nInput: pattern = \"abba\", s = \"dog cat cat dog\"\nOutput: true\n```\n\n### Example 2\n\n```bash\nInput: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\n```\n\n### Constraints:\n\n- 1 <= pattern.length <= 300\n- pattern contains only lower-case English letters.\n- 1 <= s.length <= 3000\n- s contains only lowercase English letters and spaces ' '.\n- s does not contain any leading or trailing spaces.\n- All the words in s are separated by a single space.","basename":"word-pattern"},"word-search-ii":{"title":"Word Search II","description":"Given an m x n board of characters and a list of strings words, return all words on the board.","tags":["neetcode","hard","trie"],"link":"https://leetcode.com/problems/word-search-ii/","images":["https://assets.leetcode.com/uploads/2020/11/07/search1.jpg","https://assets.leetcode.com/uploads/2020/11/07/search2.jpg"],"hints":["https://wngnelson.com/assets/img_src/dsa/wordsearch2.gif"],"preview":"### Description\n\nGiven an m x n board of characters and a list of strings words, return all words on the board.\n\nEach word must be constructed from letters of sequentially adjacent cells, where **adjacent cells** are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2020/11/07/search1.jpg)\n\n```bash\nInput: board = [[\"o\",\"a\",\"a\",\"n\"],[\"e\",\"t\",\"a\",\"e\"],[\"i\",\"h\",\"k\",\"r\"],[\"i\",\"f\",\"l\",\"v\"]], words = [\"oath\",\"pea\",\"eat\",\"rain\"]\nOutput: [\"eat\",\"oath\"]\n```\n\n### Example 2\n\n![](https://assets.leetcode.com/uploads/2020/11/07/search2.jpg)\n\n\n```bash\nInput: board = [[\"a\",\"b\"],[\"c\",\"d\"]], words = [\"abcb\"]\nOutput: []\n```\n\n### Constraints:\n\n- m == board.length\n- n == board[i].length\n- 1 <= m, n <= 12\n- board[i][j] is a lowercase English letter.\n- 1 <= words.length <= 3 * 10^4\n- 1 <= words[i].length <= 10\n- words[i] consists of lowercase English letters.\n- All the strings of `words` are unique.","basename":"word-search-ii"},"word-search":{"title":"Word Search","description":"Given an m x n grid of characters board and a string word, return true if word exists in the grid.","tags":["neetcode","trie","medium"],"link":"https://leetcode.com/problems/word-search/","images":["https://assets.leetcode.com/uploads/2020/11/04/word2.jpg","https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg","https://assets.leetcode.com/uploads/2020/10/15/word3.jpg"],"hints":["https://wngnelson.com/assets/img_src/dsa/word-search.gif"],"preview":"### Description\n\nGiven an `m x n` grid of characters `board` and a string `word`, return `true` if word exists in the grid.\nThe word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.\n\n### Example 1\n\n![](https://assets.leetcode.com/uploads/2020/11/04/word2.jpg)\n\n```bash\nInput: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"\nOutput: true\n```\n\n### Example 2\n\n![](https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg)\n\n```bash\nInput: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"SEE\"\nOutput: true\n```\n\n### Example 3\n\n![](https://assets.leetcode.com/uploads/2020/10/15/word3.jpg)\n\n```bash\nInput: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCB\"\nOutput: false\n```\n\n### Constraints:\n\n- m == board.length \n- n = board[i].length \n- 1 <= m, n <= 6 \n- 1 <= word.length <= 15 \n- board and word consists of only lowercase and uppercase English letters.","basename":"word-search"},"zigzag-traverse":{"title":"Zigzag Traverse","description":"Zigzag Traverse","tags":["hard","algoexpert"],"link":null,"images":[],"preview":"# Zigzag Traverse\n\nWrite a function that takes in an n x m two-dimensional array (that can be square-shaped when n == m) and returns a one-dimensional array of all the array's elements in zigzag order.\n\nZigzag order starts at the top left corner of the two-dimensional array, goes down by one element, and proceeds in a zigzag pattern all the way to the bottom right corner.\n\n## Sample Input\n```\narray = [\n    [1,  3,  4, 10],\n    [2,  5,  9, 11],\n    [6,  8, 12, 15],\n    [7, 13, 14, 16],\n]\n```\n\n## Sample Output\n\n```\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]\n```\n\n### Hints\n\nHint 1\n> Don't overthink this question by trying to come up with a clever way of getting the zigzag order. Think about the simplest checks that need to be made to decide when and how to change direction throughout the zigzag traversal.\n\nHint 2\n> Starting at the top left corner, iterate through the two-dimensional array by keeping track of the direction that you're moving in (up or down). If you're moving up, you know that you need to move in an up-right pattern and that you need to handle the case where you hit the top or the right borders of the array. If you're moving down, you know that you need to move in a down-left pattern and that you need to handle the case where you hit the left or the bottom borders of the array.\n\nHint 3\n> When going up, if you hit the right border, you'll have to go down one element; if you hit the top border, you'll have to go right one element. Similarly, when going down, if you hit the left border, you'll have to go down one element; if you hit the bottom border, you'll have to go right one element.\n\n```\nOptimal Space & Time Complexity\nO(n) time | O(n) space - where n is the total number of elements in the two-dimensional array\n```","basename":"zigzag-traverse"}}